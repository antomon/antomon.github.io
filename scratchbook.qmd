



#### Formal definition

To formally understand functional completeness in homomorphic encryption, it's important to start with the algebraic foundations. In algebra, a **homomorphism** is a structure-preserving map between two algebraic structures, such as groups, rings, or fields. This means that the operations defined in one structure are preserved under the mapping to the other structure. In the context of homomorphic encryption, the homomorphism property allows operations to be carried out on encrypted data that mirror operations on the plaintext.

The algebraic structures we are concerned with here are typically **groups**, **fields**, and **rings**. A group is a set equipped with an operation that satisfies closure, associativity, has an identity element, and where every element has an inverse. When we extend these properties to include additional operations like multiplication, we get **rings** and **fields**, which have more complex properties. In a **ring**, both addition and multiplication are defined, but not every element necessarily has a multiplicative inverse. In a **field**, every non-zero element has a multiplicative inverse, making it a richer structure.

In homomorphic encryption, we work with these algebraic structures because they provide the foundation for well-defined operations on encrypted data. The key operations, namely addition** and multiplication, are defined over these structures in a way that ensures they behave predictably and securely. When we say that an encryption scheme is homomorphic, we mean that it allows addition and multiplication to be performed on encrypted values, and the result, when decrypted, matches what would have been obtained if the operations were performed directly on the plaintext values.

Functional completeness, in this context, refers to the ability of an encryption scheme to support arbitrary computations on encrypted data by leveraging both addition and multiplication. These two operations are fundamental because they form a functionally complete set over finite fields. The latter distinction is important because functional completeness is well-defined in finite fields due to properties like closure under addition and multiplication. In infinite fields, however, the same guarantees may not hold, and constructing certain functions can be more challenging. The finite nature ensures that every combination of addition and multiplication stays within the set, which is a crucial requirement for functional completeness in encryption schemes. Moreover, since physical computations in digital systems are inherently carried out over finite fields, this limitation does not affect practical applications. As a matter of fact, digital systems use finite representations (such as bits), and operations are performed over well-defined finite fields like GF(2)[^GF2-homomorphic-encryption-developers]. 

[^GF2-homomorphic-encryption-developers]: GF(2), or Galois Field of order 2, is a finite field consisting of just two elements: usually represented as 0 and 1. 

To clarify the connection with the previous discussion, consider **Boolean circuits**, which are a model of computation used in computer science to represent logical functions. A Boolean circuit consists of logic gates such as XOR and AND, which can be seen as parallels to addition and multiplication, and can be combined to represent any possible computation, as supported by the concept of Turing completeness, which states that any computation can be performed given sufficient resources and the right set of operations, such as XOR and AND, which were previously introduced as parallels to addition and multiplication, and together are sufficient to represent any computable function. Similarly, in arithmetic circuits, **addition** and **multiplication** serve as the fundamental operations. By chaining these operations together, we can construct any polynomial function. The ability to construct polynomial functions is significant because, according to the **Stone-Weierstrass theorem**, any continuous function can be approximated by a polynomial to any desired degree of accuracy. This means that by constructing polynomial functions, we can represent a wide range of complex computations, including those needed for encryption and data processing. In the context of homomorphic encryption, this enables us to perform arbitrary functions on encrypted data, ultimately allowing powerful and flexible operations while preserving data privacy. In the context of homomorphic encryption, this means we can perform a wide variety of operations on encrypted data, ultimately allowing us to evaluate arbitrary functions while preserving data privacy. This explanation builds on the algebraic foundations discussed earlier, demonstrating how addition and multiplication form a functionally complete set for building complex computations, both in logical and arithmetic contexts.

In homomorphic encryption, an encryption scheme is said to be **fully homomorphic** if it supports both addition and multiplication on encrypted data, without needing to decrypt it. This property allows for the evaluation of any arithmetic circuit or Boolean circuit on encrypted data, effectively enabling arbitrary computation while preserving the confidentiality of the original data.

For instance, in the context of Boolean logic, **XOR** can be represented by addition (without carry), and **AND** can be represented by multiplication. These two gates are sufficient to build any Boolean function, making them functionally complete. Therefore, an encryption scheme that supports homomorphic addition and multiplication can evaluate any Boolean function, making it a fully homomorphic encryption (FHE) scheme.

## Importance of Functional Completeness in Homomorphic Encryption

The concept of functional completeness is crucial because it determines the power and flexibility of a homomorphic encryption scheme. If an encryption scheme can only support addition or only multiplication, it is called **partially homomorphic**. Such schemes can perform useful but limited computations, like adding encrypted numbers together or multiplying them by a constant. However, they cannot handle more complex functions that require a combination of both operations.

Examples of partially homomorphic encryption schemes include **RSA**, which is **multiplicatively homomorphic**, and **Paillier**, which is **additively homomorphic**. These schemes allow for specific types of computations on encrypted data but lack the flexibility of fully homomorphic encryption.

A **fully homomorphic encryption** scheme, on the other hand, allows for arbitrary computations on encrypted data. This means that any function, no matter how complex, can be evaluated while the data remains encrypted. This capability has significant implications for data privacy and security, especially in fields like cloud computing, where sensitive data can be processed by third-party servers without exposing the underlying information.

In summary, functional completeness in homomorphic encryption refers to the ability to perform both addition and multiplication on encrypted data, enabling the evaluation of any arbitrary function. This makes fully homomorphic encryption a powerful tool for maintaining data privacy while still allowing computations to be performed.

