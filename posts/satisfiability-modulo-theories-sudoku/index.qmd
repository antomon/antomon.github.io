---
title: "Sudoku and Satisfiability Modulo Theories"
subtitle: "You can solve it the standard way or... with Python amd math"
format:
  html:
    toc: true
    toc-expand: 3
description: "."
author: "Antonio Montano"
date: "2024-09-05"
date-modified: "2024-09-05"
categories: [mathematics, Python, theory, 🇬🇧]
image: "smt-sudoku.webp"
comments: 
  utterances:
    repo: antomon/antomon-utterances
    theme: github-light
---

## Introduction

Imagine you're trying to solve a puzzle where you have to figure out whether certain statements can all be true at the same time. This might sound simple, but what if those statements involve complex rules and relationships? Problems like these are at the heart of **SAT (Boolean Satisfiability Problem)** and **SMT (Satisfiability Modulo Theories)**, two important topics in computer science and logic. They help us solve complex puzzles in many areas, from designing computer chips to scheduling tasks. This essay will explore what SAT and SMT are, why they matter, and how they are used in real-world situations. 

As a fun and practical example of how these tools can be used, we’ll end this post by showing how SMT can be used to solve Sudoku puzzles, turning a well-known puzzle into a logic-based problem-solving task.

## SAT

**SAT** stands for **Boolean Satisfiability Problem**. It’s all about answering a basic question: _"Can we assign True or False values to certain variables in a way that makes a given logical formula true?"_

Think of SAT as a logic puzzle. Here’s an example:

You’re given the statements:

1. $x$ or $y$ (meaning one of them, or both, must be True).

2. Not $x$ or $z$ (meaning either $x$ is False, or $z$ is True, or both).

3. Not $y$ or not $z$ (meaning at least one of $y$ or $z$ must be False).

Can you assign True or False values to $x$, $y$, and $z$ that make all of these statements true at the same time?

This is a SAT problem! The goal is to find a solution where the statements don’t contradict each other, or determine if no such solution exists.

### Propositional logic

**Propositional logic**, also known as **Boolean logic**, deals with statements that can either be **True** or **False**. These statements are called **propositions**, and they are combined using logical operators to form **propositional logic formulas**.

A **proposition** is a statement that has a definite truth value—either True or False. For example:

- “It is raining” is a proposition, and it can be either True or False.

- In mathematical terms, we often use **variables** to represent propositions. For example, we might let:

  - $x$ represent “It is raining”.

  - $y$ represent “It is cloudy”.

Each of these variables can take the value True or False.

In propositional logic, we use **logical operators** to combine propositions into more complex formulas. The most important operators are:

- **AND ( ∧ )**: The expression $x \land y$ is True only if both $x$ and $y$ are True. Example: "It is raining **and** it is cloudy" is only True if both things are happening.
  
- **OR ( ∨ )**: The expression $x \lor y$ is True if either $x$ or $y$ (or both) are True. Example: "It is raining **or** it is cloudy" is True if at least one of them is happening.
  
- **NOT ( ¬ )**: The expression $\neg x$ (read as "not $x$") is True if $x$ is False. Example: "It is **not** raining" is True if $x$ is False (i.e., it is not raining).
  
- **Implication ( → )**: The expression $x \rightarrow y$ (read as "if $x$, then $y$") is True unless $x$ is True and $y$ is False. Example: "If it is raining, then it is cloudy" is True unless it’s raining but not cloudy.

A **propositional logic formula** is a combination of variables and logical operators that can be evaluated as True or False, depending on the values of the variables.

For example, consider the formula:

$$
(x \lor y) \land (\neg x \lor z)
$$

This formula combines the variables $x$, $y$, and $z$ using the logical operators AND, OR, and NOT. The task is to determine whether there are values for $x$, $y$, and $z$ that make the whole formula True. This is exactly what the SAT problem asks us to solve.

### Decision problems

A **decision problem** is a question that can be answered with a simple **Yes** or **No**. In the case of SAT, the decision problem is:

_"Given a propositional logic formula, is there an assignment of True/False values to the variables that makes the formula True?"_

If such an assignment exists, the answer is **Yes**, and we say the formula is **satisfiable**. If no such assignment exists, the answer is **No**, and we say the formula is **unsatisfiable**.

Let’s consider a simple SAT problem:

$$
(x \lor y) \land (\neg x \lor z) \land (\neg y \lor \neg z)
$$

We want to know if there’s a way to assign True or False values to $x$, $y$, and $z$ so that the entire formula is True.

Let’s try a few combinations:

- If $x = \mathrm{True}, y = \mathrm{True}, z = \mathrm{True}$: $(x \lor y)$ is $\mathrm{True}$, $(\neg x \lor z)$ is $\mathrm{True}$, but $(\neg y \lor \neg z)$ is $\mathrm{False}$. This assignment does **not** satisfy the formula.
  
- If $x = \mathrm{True}, y = \mathrm{False}, z = \mathrm{True}$: $(x \lor y)$ is $\mathrm{True}$, $(\neg x \lor z)$ is $\mathrm{True}$, and $(\neg y \lor \neg z)$ is $\mathrm{True}$. This assignment **does** satisfy the formula!

So, the formula is satisfiable, and the answer to the SAT problem is Yes.

### Standardizing SAT problems

Many SAT problems are written in a special format called **Conjunctive Normal Form (CNF)**. A formula is in CNF if it is a conjunction (AND) of one or more **clauses**, where each clause is a disjunction (OR) of **literals**. A literal is simply a variable or its negation.

For example, the formula:

$$
(x \lor \neg y) \land (\neg x \lor z \lor y)
$$

is in CNF because it is an AND of two OR clauses.

Why is CNF important? SAT solvers (programs designed to solve SAT problems) work more efficiently when the formula is in CNF. In fact, any propositional logic formula can be converted into CNF without changing its satisfiability.

### NP-complete problems

**SAT is the first problem ever proven to be NP-complete.** This means that:

1. **SAT is in NP**: Given a solution (an assignment of True/False values), we can check if it satisfies the formula in a reasonable amount of time (in polynomial time).

2. **SAT is NP-hard**: Every problem in NP can be reduced to SAT in polynomial time. In simpler terms, if we can solve SAT quickly, we can solve every problem in NP quickly.

This discovery has huge implications in computer science because it shows how SAT is connected to many other difficult problems. If we can find an efficient algorithm to solve SAT, we can apply it to a wide range of important problems, like optimization, scheduling, and even cryptography.

### SAT solvers: how do they work?

SAT problems can get very complicated, especially when there are many variables and clauses. To solve them efficiently, we use **SAT solvers**, which are computer programs designed to find solutions to SAT problems. SAT solvers use several smart strategies to speed up the search for a solution. Two of the most common strategies are:

- **Backtracking**: The solver tries different assignments of True/False values, and if it hits a dead end (an unsatisfiable assignment), it backtracks and tries a different path.

- **Unit propagation**: If a clause contains only one unassigned variable, the solver can immediately assign it a value that satisfies the clause.

Modern SAT solvers can solve problems with thousands or even millions of variables and clauses. These solvers are used in many applications, including verifying that hardware circuits work correctly and solving complex puzzles like Sudoku.

### Real-world applications

Now that we know what SAT is, let’s explore some real-world uses:

- **Hardware and software verification**: Before building a computer chip, engineers use SAT to check that the design behaves correctly. A mistake in the design could cause a computer to crash or malfunction. SAT solvers help catch these errors before they become costly problems. Similarly, SAT is used in software verification to ensure that a program behaves as expected under all possible conditions.

- **AI and decision making**: In artificial intelligence (AI), SAT is used to solve planning and decision-making problems. For example, SAT can help an AI system figure out the best sequence of actions to achieve a goal while following certain rules.

- **Puzzles and games**: Many logic-based puzzles, like Sudoku or Minesweeper, can be turned into SAT problems. A SAT solver can then be used to find the solution to the puzzle, or to check if the puzzle has a unique solution.

## SMT

Now that we have a solid understanding of **SAT** and how it helps us solve problems using **propositional logic** (True/False values), let’s take things a step further with **SMT**, or **Satisfiability Modulo Theories**. While SAT focuses only on whether a logical formula can be true or false, SMT opens the door to solving more complex mathematical problems that involve numbers, functions, arrays, and even more abstract concepts. SMT combines the power of SAT with other **theories** from mathematics to tackle a wider range of problems.

Like SAT, SMT asks whether a certain formula can be made True, but it doesn’t limit itself to just logical variables (True/False values). Instead, SMT allows us to work with **mathematical objects** like:

- **Integers** (whole numbers).

- **Real numbers** (including fractions and decimals).

- **Arrays** (lists of elements).

- **Functions** (mathematical relationships).

With SMT, we can ask questions that involve not just logic but also arithmetic, like: “Is there a way to assign values to $x$ and $y$ such that $x + y = 5$ and $x > 2$?”

In this case, $x$ and $y$ are not just True or False; they are numbers. SMT solvers, just like SAT solvers, try to find values for the variables that satisfy all the given conditions.

### Theories

In SMT, the word **theory** refers to a set of rules that describe how certain kinds of mathematical objects behave. These theories help the SMT solver understand and solve problems that go beyond simple logic. Let’s take a look at some common theories used in SMT:

- **Linear arithmetic**: This theory deals with equations and inequalities involving numbers. It allows us to solve problems like:
  
  - $x + y = 10$.

  - $3x - 2y \leq 5$.

  - $x \geq 0$.

The SMT solver uses the rules of arithmetic to find values for $x$ and $y$ that satisfy these equations.

- **Bit-vectors**: Bit-vectors represent numbers in **binary form** (0s and 1s), which is how computers store and manipulate data. Bit-vector theory is important in verifying how computer hardware (like circuits) works. For example:

  - $x \& y = 1$.

  - $x \text{ shifted left by } 2 = z$.

  These operations are common in low-level computing tasks, and SMT solvers can handle them by using the rules of bit-wise operations.

- **Arrays and functions**: Arrays are lists of numbers or objects, and functions describe how inputs are mapped to outputs. SMT solvers can reason about arrays and functions using logical and mathematical rules. For example, in array theory, you might ask: “Is there a way to assign values to an array such that the sum of all its elements is 20?”, or in function theory: “Is there a function $f(x)$ that satisfies $f(2) = 4$ and $f(3) = 9$?”.

### How SMT solvers work

SMT solvers work in two main steps:

1. **Boolean abstraction**: The solver first treats the problem as a SAT problem by working with the Boolean logic part. It temporarily ignores the complicated mathematical parts (like numbers or arrays) and focuses on the logical structure.
  
2. **Theory solving**: After the SAT part is solved, the SMT solver checks if the numbers, arrays, or functions meet the additional constraints defined by the theory. If the SAT part leads to a solution that violates the mathematical rules (e.g., if the solution says $x + y = 10$ but the theory says that’s not possible), the solver tries a different assignment.

This combination of logical reasoning (like in SAT) and mathematical reasoning (using theories) makes SMT solvers extremely powerful.

### Complexity

**SMT is NP-hard**, meaning it is at least as hard as the hardest problems in **NP**. This is important because many real-world problems can be formulated as SMT problems, and solving them efficiently is difficult. Like SAT, SMT involves searching through many possible assignments for variables, but in addition to simple logic, the solver must also deal with more complex mathematical theories (such as arithmetic or arrays).

This makes SMT harder to solve than pure SAT problems because the solver not only needs to find a logical assignment but also ensure that it satisfies the rules of the mathematical theory involved. Despite this complexity, SMT solvers have become incredibly advanced and are used in many real-world applications.

### Why SMT is powerful

While **SAT** is a powerful tool for solving logical problems that involve only True/False values, **SMT** goes much further. It combines logic with mathematics, allowing us to solve more complex problems that involve not just logical variables, but also numbers, functions, arrays, and other mathematical structures. By incorporating **theories** such as arithmetic, arrays, and functions, SMT enables us to reason about problems that SAT alone cannot handle.

In a SAT problem, we are limited to determining whether a set of logical conditions can all be true at once, with variables that can only be **True** or **False**. While this is useful in many areas (like circuit verification and puzzle-solving), it doesn't account for problems that involve numbers, functions, or more abstract data types.

SMT enhances SAT by allowing us to work with variables that take on more complex values and obey specific rules (or **theories**). This means that SMT can handle problems like:

- Arithmetic: **Finding numbers** that satisfy equations or inequalities.

- Bit-vectors: **Verifying computer hardware** by modeling numbers as binary digits.

- Arrays: **Working with data structures**, such as lists or tables, and reasoning about how elements are stored and accessed.

- Functions: **Handling relationships** between inputs and outputs, which is useful for reasoning about computer programs or mathematical models.

For example, consider a problem where you need to find two numbers, $x$ and $y$, such that:

- $x + y = 10$.

- $x > 3$.

- $y \leq 6$.

A simple SAT solver cannot deal with this because it only works with True/False values. An SMT solver, however, can use **linear arithmetic theory** to find values for $x$ and $y$ that satisfy these conditions.

### Real-world applications

Because SMT solvers can handle both logic and mathematics, they are used in a wide range of **real-world applications**. These applications often involve problems where both logical conditions and numerical relationships must be satisfied at the same time. Here are a few important areas where SMT solvers play a critical role:

- **Verifying computer programs**: In the world of software, programs are expected to behave correctly no matter what inputs they receive or what paths their execution follows. SMT solvers are used to **formally verify** that programs do not crash, run into errors, or behave unexpectedly.

  For instance, if you write a program that calculates the square root of a number, you need to make sure it never tries to compute the square root of a negative number (which would cause an error). An SMT solver can check all possible inputs to ensure that the program handles every situation correctly, even the edge cases that a human might miss.

  By using SMT, software engineers can catch potential bugs **before** they happen, preventing costly errors in industries like aerospace, medical devices, or financial systems, where software correctness is absolutely critical.

- **Solving scheduling problems**: SMT solvers are also used in **scheduling**—a problem that involves assigning tasks to people, machines, or time slots while following certain rules. These rules might include constraints like:

  - A task can only start after another task is finished.

  - Some tasks cannot be done at the same time.

  - Certain workers are only available at specific times.

  Imagine trying to schedule a series of construction tasks on a large building site. Each task depends on other tasks being completed (you can’t install the windows before the walls are built!), and you only have a limited number of workers available. SMT solvers can process these constraints and find an **optimal schedule** that minimizes delays and uses resources efficiently.

  This ability to handle both logical dependencies and numerical constraints makes SMT invaluable for **resource allocation**, **project planning**, and **logistics** in industries like manufacturing, transportation, and healthcare.

- **Optimizing circuit designs**: In hardware design, particularly for computer chips, engineers need to ensure that the circuit behaves correctly under all possible input combinations. This is critical because even a small error can lead to catastrophic consequences, like a computer crashing or malfunctioning. Using **bit-vector theory**, SMT solvers model how circuits manipulate binary data (0s and 1s) and check whether the circuit design meets the required specifications. For example, SMT can verify that:

  - A chip correctly adds two numbers without overflow.

  - A processor handles all operations within its performance constraints.

  In addition, SMT solvers can **optimize designs** by ensuring that the chip uses the least amount of resources (such as power or space) while still functioning correctly. This makes them indispensable in the **semiconductor industry**, where efficient design is key to building faster, smaller, and more energy-efficient devices.

### Efficiency and scalability of SMT solvers

**SMT solvers** are designed to handle highly complex problems, often involving thousands or even millions of variables and constraints. This capability to scale and manage complexity efficiently is one of the key reasons why SMT solvers have become indispensable in many fields. Unlike simpler solvers that can only handle basic logical formulas, modern SMT solvers—such as Z3 (developed by Microsoft)—can work on incredibly large and intricate problems that require the integration of both logic and mathematics.

#### Large-Scale software verification

Software verification is a critical application of SMT solvers. Large and complex codebases, like those used in operating systems or flight control software, require guarantees that they behave correctly in every possible situation. This is especially important for **safety-critical systems**, where even a small bug could lead to catastrophic consequences (such as an airplane malfunctioning or a medical device failing). SMT solvers are used to **automatically verify** that a program adheres to its specifications by checking all possible inputs and paths the software might take.

For example, verifying that a piece of software does not crash when it processes certain inputs might require checking billions of different combinations of inputs and internal states. An SMT solver can analyze these possibilities using logical and mathematical models, ensuring that the software behaves as expected across all cases. This process, known as **formal verification**, is a step beyond typical software testing because it proves the absence of errors rather than simply checking for errors that are found during testing.

#### Optimizing systems

Another area where SMT solvers excel is **system optimization**. Many real-world systems—such as networks, electronic circuits, or transportation schedules—are incredibly complex, involving a large number of interacting components that must work together efficiently. SMT solvers help **optimize** these systems by finding the best possible configuration that meets all the necessary constraints.

For instance, in **network design**, you might need to ensure that data flows through the network as efficiently as possible while minimizing costs and avoiding congestion. SMT solvers can handle the complexity of these requirements, modeling both the logical rules that govern the network’s behavior and the mathematical constraints, such as bandwidth limits or latency requirements.

In **circuit design**, SMT solvers are used to minimize the power consumption, size, and heat production of electronic circuits while ensuring they perform their intended functions correctly. As circuits become more advanced and compact, this optimization process becomes critical for the performance of modern electronics, including smartphones and computer processors.

In large-scale **scheduling** problems—such as assigning shifts to employees or scheduling jobs on machines—SMT solvers help find optimal solutions that balance competing demands, such as time constraints, available resources, and efficiency goals. Because SMT solvers can scale to handle thousands of tasks or constraints, they are a powerful tool for solving these optimization problems in real-world industrial settings.

#### Advanced techniques

Even though SMT is **NP-hard**, meaning that, in the worst cases, solving these problems can take an enormous amount of time—the development of **advanced algorithms** and **heuristics** has made SMT solvers much faster and more practical for real-world applications. SMT solvers use several techniques to reduce the time and resources required to find a solution, including:

- **Backtracking**: The solver explores possible solutions and, if it hits a dead end (where a solution doesn’t work), it backtracks to an earlier decision point and tries a different path. This helps the solver avoid wasting time on unworkable solutions.

- **Conflict-Driven Clause Learning (CDCL)**: When the solver encounters a conflict (a situation where no solution can satisfy the current set of constraints), it learns from this conflict to avoid making similar mistakes in the future. This dramatically speeds up the solving process by preventing the solver from revisiting paths that are known to be dead ends.

- **Theory Propagation**: Theories in SMT (such as arithmetic or arrays) have their own specific rules. SMT solvers use **theory propagation** to narrow down the possible values for variables based on the rules of these theories. For example, if a variable must satisfy a certain arithmetic equation, the solver can limit the range of possible values for that variable, which reduces the complexity of the search.

By combining these techniques, SMT solvers are able to handle problems that would be intractable for simpler solvers, allowing them to efficiently solve highly complex and large-scale problems.

### Combining multiple theories

One of the key strengths of **SMT solvers** is their ability to handle multiple theories simultaneously, allowing them to solve problems that involve not just simple logic but a mixture of complex mathematical domains. This combination of theories allows SMT solvers to model real-world systems with a higher degree of accuracy and sophistication. By integrating diverse theories, SMT solvers can solve problems that span multiple **domains of mathematics and logic** in a seamless way. Let's take a closer look at how multiple theories work together in SMT, and why this makes SMT solvers exceptionally powerful.

When we talk about SMT solvers "combining multiple theories," what we really mean is that the solver is capable of reasoning about different kinds of constraints that apply to different types of data—all at the same time. 

Each theory brings its own set of **rules and constraints**. For example:

- Arithmetic theory deals with equations and inequalities.

- Array theory includes operations like indexing and updating.

- Bit-vector theory includes binary manipulations like bit-shifting or bitwise AND/OR operations.

In real-world applications, it's rare for a problem to belong to just one theory. Often, multiple theories are at play. SMT solvers shine in such scenarios by integrating these different theories and **coordinating the solving process** so that constraints from all applicable theories are satisfied simultaneously.

Let’s now explore some concrete examples where multiple theories interact in SMT.

### Verifying software with mixed data types

Consider a software verification problem in which a program performs both arithmetic computations and manipulates arrays. Suppose the program performs operations like:

1. **Arithmetic**: $x = a + b$.

2. **Array access**: Reading an element from an array $arr[i]$.

3. **Bitwise operations**: $z = x \& y$, where $\&$ is the bitwise AND operation.

To ensure the correctness of this program, we need to check if the program will behave correctly for any given inputs. Here’s how **multiple theories** would be combined by the SMT solver:

1. **Arithmetic theory** will handle the equation $x = a + b$, ensuring that the sum is computed correctly according to arithmetic rules. The solver will also check that variables like $x$, $a$, and $b$ are appropriately constrained (e.g., $x$ must be an integer).

2. **Array theory** will handle the operation $arr[i]$, ensuring that the index $i$ is valid (i.e., it lies within the bounds of the array). It will also ensure that the right value is retrieved from the array and assigned to the right variable. The solver checks that accessing $arr[i]$ doesn't lead to an out-of-bounds error.

3. **Bit-vector theory** will manage the bitwise operation $z = x \& y$, ensuring that the binary representation of $x$ and $y$ is correctly manipulated at the bit level. This is crucial for many low-level computing tasks, such as encoding or encryption, where binary data is processed.

By combining these theories, the SMT solver verifies that the program will execute correctly, no matter what values are assigned to the variables. The solver considers all possible inputs and execution paths to prove that there are no runtime errors, incorrect calculations, or invalid memory accesses.

### A coordinated process

The magic of SMT solvers lies in their ability to coordinate between these multiple theories while solving a problem. Theories often interact in complex ways, so SMT solvers must **communicate between theories** to resolve constraints effectively. This involves a process known as **theory combination** or **theory propagation**.

1. **Theory propagation**: Each theory can propagate constraints based on its specific rules. For example, if the arithmetic theory deduces that $x > 10$, then this information is passed to the array theory to check if accessing $arr[x]$ is still valid, ensuring $x$ doesn’t exceed the array bounds.

2. **Conflict resolution**: If a conflict arises—such as the arithmetic theory concluding $x = 5$, while the bit-vector theory requires $x$ to have a binary value that would make $x = 3$, the solver identifies this conflict and attempts to resolve it by exploring alternative solutions. This iterative process is essential for finding a solution that satisfies all constraints across different theories.

3. **Theory interpolation**: When two different theories interact, SMT solvers use techniques like **theory interpolation** to reconcile their different views of the problem. For instance, arithmetic may dictate that $x = 4$, while array theory may require that $x$ be within certain index limits. The solver navigates these competing constraints by narrowing down possible values for $x$ that satisfy both theories.

These interactions make SMT solvers **more efficient** at solving problems that would be too difficult for simpler solvers that only handle one theory at a time.

### Flexibility across domains

The flexibility of SMT solvers to combine multiple theories makes them incredibly versatile. Here are a few real-world examples that highlight their power across different domains:

- **Cryptographic verification**: SMT solvers are used to verify cryptographic algorithms, such as those used for data encryption and digital signatures. Cryptographic operations often involve both **arithmetic** (modular arithmetic over large numbers) and **bitwise manipulations** (such as shifting bits or performing XOR operations).

  For instance, verifying the correctness of a **RSA encryption algorithm** requires an SMT solver to:

  - Check the **modular arithmetic** involved in key generation and encryption.

  - Ensure the **bitwise operations** used to encode and decode messages are performed correctly.

  By integrating arithmetic and bit-vector theories, an SMT solver can ensure that the algorithm is mathematically secure and functions as expected for all inputs.

- **Optimizing robotic movements**: In modern factories, robots are often programmed to perform complex tasks that involve both **decision-making** (logic) and **precise control of movement** (arithmetic). SMT solvers are used to **optimize robotic movements**, ensuring that they follow the most efficient path while respecting physical constraints like speed, distance, and safety.

  An SMT solver may combine:

  - **Linear arithmetic** to model the robot’s physical movements.

  - **Logic** to represent decision-making rules, such as "if an obstacle is detected, stop the robot."

  - **Array theory** to manage data about the robot's environment and task status.

  By solving these constraints together, the SMT solver finds an optimal plan for the robot that minimizes movement time, avoids obstacles, and completes tasks in the most efficient way possible.

- **Artificial Intelligence: Planning and Scheduling**: AI systems often need to make decisions that involve both logic and time-based scheduling. For example, an AI planning system might need to schedule tasks for multiple robots working in parallel, ensuring that each robot finishes its task without clashing with others.

  SMT solvers can:
  - Use **arithmetic theory** to track time constraints, such as ensuring that task A is completed before task B starts.

  - Use **array theory** to keep track of which robot is performing which task.

  - Use **logical reasoning** to decide the best sequence of actions.

  By combining these theories, SMT solvers can efficiently plan out the most effective way for robots to complete tasks without delays or conflicts, making AI systems smarter and more reliable.

## Z3

[**Z3**](https://www.microsoft.com/en-us/research/project/z3-3/)[^1-satisfiability-modulo-theories-sudoku] is one of the most widely-used and powerful SMT solvers, developed by **Microsoft Research**. It is designed to solve logical and mathematical problems that involve both Boolean logic (True/False values) and a variety of mathematical structures, such as integers, real numbers, arrays, bit-vectors, and more. Z3 has become the go-to tool for a wide range of applications, from verifying software correctness to optimizing systems in industrial engineering. Its ability to handle large and complex problems efficiently, while combining different mathematical theories, sets it apart from other solvers.

[^1-satisfiability-modulo-theories-sudoku]: de Moura, L., & Bjørner, N. (2008). **Z3: An Efficient SMT Solver**. *Tools and Algorithms for the Construction and Analysis of Systems (TACAS)*. [Link to paper](https://www.microsoft.com/en-us/research/publication/z3-an-efficient-smt-solver/)

### Key features

- **Multi-theory solver**: Z3 can handle problems that involve multiple theories simultaneously, such as **arithmetic**, **bit-vectors**, **arrays**, and **functions**. This makes it versatile enough to solve complex real-world problems that span multiple domains of logic and mathematics. Whether you are working with numerical constraints, manipulating data structures like arrays, or verifying hardware circuits that operate at the bit level, Z3 can manage these interactions seamlessly.

- **High efficiency**: Z3 is designed to solve extremely large problems with millions of variables and constraints. It employs advanced techniques, such as **conflict-driven clause learning (CDCL)**, **backtracking**, and **theory propagation**, to explore the search space efficiently. These techniques enable Z3 to quickly find solutions or prove that no solution exists, even for problems that are computationally intensive.

- **Combining logical and mathematical constraints**: One of Z3’s most powerful features is its ability to combine **logical constraints** (such as those used in SAT solving) with **mathematical constraints** (such as equations and inequalities). For example, in software verification, Z3 can check both the logical flow of the program and the correctness of its arithmetic operations, ensuring that a program behaves as expected in all possible scenarios.

- **Modularity and extensibility**: Z3 is highly modular, which means that users can extend its capabilities to suit specific applications. It allows developers to define custom theories and tailor the solver’s behavior to fit the particular needs of their problem domain. This flexibility makes Z3 suitable for a wide range of industries, including aerospace, finance, cybersecurity, and hardware design.

- **Rich API support**: Z3 provides rich API support for various programming languages, including Python, C++, and Java. This means that users can integrate Z3 into their existing software tools and workflows easily. For instance, developers can use Z3 within a Python environment to model complex optimization problems, check for software bugs, or verify hardware designs. Its user-friendly interface and robust API make Z3 accessible to both researchers and engineers.

- **Proving and model generation**: In addition to solving for satisfiability, Z3 can also be used to **prove the correctness** of formulas or **generate models** that demonstrate specific properties. For example, in verifying a software system, Z3 can either provide a counterexample where the program fails or prove that no such failure exists under any circumstances. This capability is essential in formal methods for software and hardware verification.

## Sudoku time!

### 9x9 size

Here is the Python code for solving a Sudoku puzzle using Z3, including a function that takes the puzzle as input and returns the solved puzzle, along with a main function that demonstrates its use.

Let's solve the following:

```{=html}
<table>
  <tr><td>5</td><td>3</td><td>0</td><td>0</td><td>7</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
  <tr><td>6</td><td>0</td><td>0</td><td>1</td><td>9</td><td>5</td><td>0</td><td>0</td><td>0</td></tr>
  <tr><td>0</td><td>9</td><td>8</td><td>0</td><td>0</td><td>0</td><td>0</td><td>6</td><td>0</td></tr>
  <tr><td>8</td><td>0</td><td>0</td><td>0</td><td>6</td><td>0</td><td>0</td><td>0</td><td>3</td></tr>
  <tr><td>4</td><td>0</td><td>0</td><td>8</td><td>0</td><td>3</td><td>0</td><td>0</td><td>1</td></tr>
  <tr><td>7</td><td>0</td><td>0</td><td>0</td><td>2</td><td>0</td><td>0</td><td>0</td><td>6</td></tr>
  <tr><td>0</td><td>6</td><td>0</td><td>0</td><td>0</td><td>0</td><td>2</td><td>8</td><td>0</td></tr>
  <tr><td>0</td><td>0</td><td>0</td><td>4</td><td>1</td><td>9</td><td>0</td><td>0</td><td>5</td></tr>
  <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>8</td><td>0</td><td>0</td><td>7</td><td>9</td></tr>
</table>
```

```python
from z3 import Int, Solver, And, Distinct, sat  # <1>

# Function to check if the solved Sudoku is correct
def is_valid_sudoku(board):
  # Combined row and column checks in a single loop
  for i in range(9):
    # Check distinct values in row
    if len(set(board[i])) != 9:  
      return False  # <2>
    
    # Check distinct values in column
    col = [board[j][i] for j in range(9)]

    if len(set(col)) != 9:
      return False  # <3>

  # Check 3x3 subgrids
  for i in range(0, 9, 3):
    for j in range(0, 9, 3):
      subgrid = [board[i + di][j + dj] for di in range(3) for dj in range(3)]

      if len(set(subgrid)) != 9:
        return False  # <4>

  return True  # <5>

# Function to solve a Sudoku puzzle using Z3
def solve_sudoku(puzzle):
  # Create a 9x9 matrix of integer variables
  X = [[Int(f"x_{i}_{j}") for j in range(9)] for i in range(9)]  # <6>
  
  # Define the solver
  solver = Solver()  # <7>
  
  # Add constraints for cell values between 1 and 9
  solver.add([And(X[i][j] >= 1, X[i][j] <= 9) for i in range(9) for j in range(9)])  # <8>
  
  # Add constraints for the pre-filled cells
  solver.add([X[i][j] == puzzle[i][j] for i in range(9) for j in range(9) if puzzle[i][j] != 0])  # <9>
  
  # Add constraints for rows, columns, and subgrids to contain distinct values
  solver.add([Distinct(X[i]) for i in range(9)])  # Row distinct  # <10>
  solver.add([Distinct([X[i][j] for i in range(9)]) for j in range(9)])  # Column distinct  # <11>
  solver.add([Distinct([X[i + di][j + dj] for di in range(3) for dj in range(3)])
              for i in range(0, 9, 3) for j in range(0, 9, 3)])  # Subgrid distinct  # <12>
  
  # Check if the Sudoku puzzle is solvable
  if solver.check() == sat:  # <13>
    model = solver.model()

    result = [[model.evaluate(X[i][j]).as_long() for j in range(9)] for i in range(9)]  # <14>

    return result  # <15>

  else:
    return None  # <16>

# Example of solving and checking a Sudoku puzzle
if __name__ == "__main__":
  # Input Sudoku puzzle (0 represents empty cells)
  puzzle = [
    [5, 3, 0, 0, 7, 0, 0, 0, 0],
    [6, 0, 0, 1, 9, 5, 0, 0, 0],
    [0, 9, 8, 0, 0, 0, 0, 6, 0],
    [8, 0, 0, 0, 6, 0, 0, 0, 3],
    [4, 0, 0, 8, 0, 3, 0, 0, 1],
    [7, 0, 0, 0, 2, 0, 0, 0, 6],
    [0, 6, 0, 0, 0, 0, 2, 8, 0],
    [0, 0, 0, 4, 1, 9, 0, 0, 5],
    [0, 0, 0, 0, 8, 0, 0, 7, 9]
  ]  # <17>

  # Solve the Sudoku puzzle
  solved = solve_sudoku(puzzle)  # <18>

  # Print the solved Sudoku puzzle and check if it's valid
  if solved:
    for row in solved:
      print(row)  # <19>

    # Check if the solution is valid
    if is_valid_sudoku(solved):
      print("The solution is valid!")  # <20>

    else:
      print("The solution is not valid!")  # <21>

  else:
    print("No solution found.")  # <22>
```
1. Import required components from the Z3 solver library.
2. Check distinct values in row: Ensures each row contains distinct values (1 to 9).
3. Check distinct values in column: Ensures each column contains distinct values (1 to 9).
4. Check 3x3 subgrids: Ensures each 3x3 subgrid contains distinct values.
5. Return `True` if the board is valid, otherwise return `False`.
6. Create a 9x9 matrix of integer variables using Z3’s `Int` to represent each cell.
7. Initialize the Z3 solver to begin solving the problem.
8. Add constraints to ensure that each cell value is between 1 and 9.
9. Add constraints for the pre-filled cells (the given values from the puzzle) to keep them unchanged.
10. Add row constraints: Each row must contain distinct values.
11. Add column constraints: Each column must contain distinct values.
12. Add subgrid constraints: Each 3x3 subgrid must contain distinct values.
13. Check if the Sudoku is solvable using the Z3 solver.
14. Extract the solution: If a solution is found, extract it from the model.
15. Return the solved puzzle.
16. Return `None` if no solution is found.
17. Input Sudoku puzzle: A 9x9 grid where `0` represents empty cells.
18. Solve the puzzle: Call the `solve_sudoku()` function.
19. Print the solved puzzle.
20. Check if the solution is valid using the `is_valid_sudoku()` function.
21. Print an error message if the solution is not valid.
22. Print "No solution found" if no solution can be found by the solver. 

and Z3 gives us:

```{=html}
<table>
  <tr><td>5</td><td>3</td><td>4</td><td>6</td><td>7</td><td>8</td><td>9</td><td>1</td><td>2</td></tr>
  <tr><td>6</td><td>7</td><td>2</td><td>1</td><td>9</td><td>5</td><td>3</td><td>4</td><td>8</td></tr>
  <tr><td>1</td><td>9</td><td>8</td><td>3</td><td>4</td><td>2</td><td>5</td><td>6</td><td>7</td></tr>
  <tr><td>8</td><td>5</td><td>9</td><td>7</td><td>6</td><td>1</td><td>4</td><td>2</td><td>3</td></tr>
  <tr><td>4</td><td>2</td><td>6</td><td>8</td><td>5</td><td>3</td><td>7</td><td>9</td><td>1</td></tr>
  <tr><td>7</td><td>1</td><td>3</td><td>9</td><td>2</td><td>4</td><td>8</td><td>5</td><td>6</td></tr>
  <tr><td>9</td><td>6</td><td>1</td><td>5</td><td>3</td><td>7</td><td>2</td><td>8</td><td>4</td></tr>
  <tr><td>2</td><td>8</td><td>7</td><td>4</td><td>1</td><td>9</td><td>6</td><td>3</td><td>5</td></tr>
  <tr><td>3</td><td>4</td><td>5</td><td>2</td><td>8</td><td>6</td><td>1</td><td>7</td><td>9</td></tr>
</table>
```

### Some improvements

Now we'll modify the code to handle Sudoku grids of different sizes and provide all solutions.

```python

```

