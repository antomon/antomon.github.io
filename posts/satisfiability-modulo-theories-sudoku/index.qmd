---
title: "Sudoku and Satisfiability Modulo Theories"
subtitle: "You can solve it the standard way or... with Python amd math"
format:
  html:
    toc: true
    toc-expand: 3
description: "."
author: "Antonio Montano"
date: "2024-09-05"
date-modified: "2024-09-05"
categories: [mathematics, Python, theory, 🇬🇧]
image: "smt-sudoku.webp"
comments: 
  utterances:
    repo: antomon/antomon-utterances
    theme: github-light
---

## Introduction

Imagine you're trying to solve a puzzle where you have to figure out whether certain statements can all be true at the same time. This might sound simple, but what if those statements involve complex rules and relationships? Problems like these are at the heart of **SAT (Boolean Satisfiability Problem)** and **SMT (Satisfiability Modulo Theories)**, two important topics in computer science and logic. They help us solve complex puzzles in many areas, from designing computer chips to scheduling tasks. This essay will explore what SAT and SMT are, why they matter, and how they are used in real-world situations. 

As a fun and practical example of how these tools can be used, we’ll end this post by showing how SMT can be used to solve Sudoku puzzles, turning a well-known puzzle into a logic-based problem-solving task.

## SAT

**SAT** stands for **Boolean Satisfiability Problem**. It’s all about answering a basic question: _"Can we assign True or False values to certain variables in a way that makes a given logical formula true?"_

Think of SAT as a logic puzzle. Here’s an example:

You’re given the statements:

1. $x$ or $y$ (meaning one of them, or both, must be True).

2. Not $x$ or $z$ (meaning either $x$ is False, or $z$ is True, or both).

3. Not $y$ or not $z$ (meaning at least one of $y$ or $z$ must be False).

Can you assign True or False values to $x$, $y$, and $z$ that make all of these statements true at the same time?

This is a SAT problem! The goal is to find a solution where the statements don’t contradict each other, or determine if no such solution exists.

### Propositional logic

**Propositional logic**, also known as **Boolean logic**, deals with statements that can either be **True** or **False**. These statements are called **propositions**, and they are combined using logical operators to form **propositional logic formulas**.

A **proposition** is a statement that has a definite truth value—either True or False. For example:

- “It is raining” is a proposition, and it can be either True or False.

- In mathematical terms, we often use **variables** to represent propositions. For example, we might let:

  - $x$ represent “It is raining”.

  - $y$ represent “It is cloudy”.

Each of these variables can take the value True or False.

In propositional logic, we use **logical operators** to combine propositions into more complex formulas. The most important operators are:

- **AND ( ∧ )**: The expression $x \land y$ is True only if both $x$ and $y$ are True. Example: "It is raining **and** it is cloudy" is only True if both things are happening.
  
- **OR ( ∨ )**: The expression $x \lor y$ is True if either $x$ or $y$ (or both) are True. Example: "It is raining **or** it is cloudy" is True if at least one of them is happening.
  
- **NOT ( ¬ )**: The expression $\neg x$ (read as "not $x$") is True if $x$ is False. Example: "It is **not** raining" is True if $x$ is False (i.e., it is not raining).
  
- **Implication ( → )**: The expression $x \rightarrow y$ (read as "if $x$, then $y$") is True unless $x$ is True and $y$ is False. Example: "If it is raining, then it is cloudy" is True unless it’s raining but not cloudy.

A **propositional logic formula** is a combination of variables and logical operators that can be evaluated as True or False, depending on the values of the variables.

For example, consider the formula:

$$
(x \lor y) \land (\neg x \lor z)
$$

This formula combines the variables $x$, $y$, and $z$ using the logical operators AND, OR, and NOT. The task is to determine whether there are values for $x$, $y$, and $z$ that make the whole formula True. This is exactly what the SAT problem asks us to solve.

### Decision problems

A **decision problem** is a question that can be answered with a simple **Yes** or **No**. In the case of SAT, the decision problem is:

_"Given a propositional logic formula, is there an assignment of True/False values to the variables that makes the formula True?"_

If such an assignment exists, the answer is **Yes**, and we say the formula is **satisfiable**. If no such assignment exists, the answer is **No**, and we say the formula is **unsatisfiable**.

Let’s consider a simple SAT problem:

$$
(x \lor y) \land (\neg x \lor z) \land (\neg y \lor \neg z)
$$

We want to know if there’s a way to assign True or False values to $x$, $y$, and $z$ so that the entire formula is True.

Let’s try a few combinations:

- If $x = \mathrm{True}, y = \mathrm{True}, z = \mathrm{True}$: $(x \lor y)$ is $\mathrm{True}$, $(\neg x \lor z)$ is $\mathrm{True}$, but $(\neg y \lor \neg z)$ is $\mathrm{False}$. This assignment does **not** satisfy the formula.
  
- If $x = \mathrm{True}, y = \mathrm{False}, z = \mathrm{True}$: $(x \lor y)$ is $\mathrm{True}$, $(\neg x \lor z)$ is $\mathrm{True}$, and $(\neg y \lor \neg z)$ is $\mathrm{True}$. This assignment **does** satisfy the formula!

So, the formula is satisfiable, and the answer to the SAT problem is Yes.

### Standardizing SAT problems

Many SAT problems are written in a special format called **Conjunctive Normal Form (CNF)**. A formula is in CNF if it is a conjunction (AND) of one or more **clauses**, where each clause is a disjunction (OR) of **literals**. A literal is simply a variable or its negation.

For example, the formula:

$$
(x \lor \neg y) \land (\neg x \lor z \lor y)
$$

is in CNF because it is an AND of two OR clauses.

Why is CNF important? SAT solvers (programs designed to solve SAT problems) work more efficiently when the formula is in CNF. In fact, any propositional logic formula can be converted into CNF without changing its satisfiability.

### NP-complete problems

**SAT is the first problem ever proven to be NP-complete.** This means that:

1. **SAT is in NP**: Given a solution (an assignment of True/False values), we can check if it satisfies the formula in a reasonable amount of time (in polynomial time).

2. **SAT is NP-hard**: Every problem in NP can be reduced to SAT in polynomial time. In simpler terms, if we can solve SAT quickly, we can solve every problem in NP quickly.

This discovery has huge implications in computer science because it shows how SAT is connected to many other difficult problems. If we can find an efficient algorithm to solve SAT, we can apply it to a wide range of important problems, like optimization, scheduling, and even cryptography.

### SAT solvers: how do they work?

SAT problems can get very complicated, especially when there are many variables and clauses. To solve them efficiently, we use **SAT solvers**, which are computer programs designed to find solutions to SAT problems. SAT solvers use several smart strategies to speed up the search for a solution. Two of the most common strategies are:

- **Backtracking**: The solver tries different assignments of True/False values, and if it hits a dead end (an unsatisfiable assignment), it backtracks and tries a different path.

- **Unit propagation**: If a clause contains only one unassigned variable, the solver can immediately assign it a value that satisfies the clause.

Modern SAT solvers can solve problems with thousands or even millions of variables and clauses. These solvers are used in many applications, including verifying that hardware circuits work correctly and solving complex puzzles like Sudoku.

### Real-world applications

Now that we know what SAT is, let’s explore some real-world uses:

- **Hardware and software verification**: Before building a computer chip, engineers use SAT to check that the design behaves correctly. A mistake in the design could cause a computer to crash or malfunction. SAT solvers help catch these errors before they become costly problems. Similarly, SAT is used in software verification to ensure that a program behaves as expected under all possible conditions.

- **AI and decision making**: In artificial intelligence (AI), SAT is used to solve planning and decision-making problems. For example, SAT can help an AI system figure out the best sequence of actions to achieve a goal while following certain rules.

- **Puzzles and games**: Many logic-based puzzles, like Sudoku or Minesweeper, can be turned into SAT problems. A SAT solver can then be used to find the solution to the puzzle, or to check if the puzzle has a unique solution.

## SMT

Now that we have a solid understanding of **SAT** and how it helps us solve problems using **propositional logic** (True/False values), let’s take things a step further with **SMT**, or **Satisfiability Modulo Theories**. While SAT focuses only on whether a logical formula can be true or false, SMT opens the door to solving more complex mathematical problems that involve numbers, functions, arrays, and even more abstract concepts. SMT combines the power of SAT with other **theories** from mathematics to tackle a wider range of problems.

Like SAT, SMT asks whether a certain formula can be made True, but it doesn’t limit itself to just logical variables (True/False values). Instead, SMT allows us to work with **mathematical objects** like:

- **Integers** (whole numbers).

- **Real numbers** (including fractions and decimals).

- **Arrays** (lists of elements).

- **Functions** (mathematical relationships).

With SMT, we can ask questions that involve not just logic but also arithmetic, like: “Is there a way to assign values to $x$ and $y$ such that $x + y = 5$ and $x > 2$?”

In this case, $x$ and $y$ are not just True or False; they are numbers. SMT solvers, just like SAT solvers, try to find values for the variables that satisfy all the given conditions.

### Theories

In SMT, the word **theory** refers to a set of rules that describe how certain kinds of mathematical objects behave. These theories help the SMT solver understand and solve problems that go beyond simple logic. Let’s take a look at some common theories used in SMT:

- **Linear arithmetic**: This theory deals with equations and inequalities involving numbers. It allows us to solve problems like:
  
  - $x + y = 10$.

  - $3x - 2y \leq 5$.

  - $x \geq 0$.

The SMT solver uses the rules of arithmetic to find values for $x$ and $y$ that satisfy these equations.

- **Bit-vectors**: Bit-vectors represent numbers in **binary form** (0s and 1s), which is how computers store and manipulate data. Bit-vector theory is important in verifying how computer hardware (like circuits) works. For example:

  - $x \& y = 1$.

  - $x \text{ shifted left by } 2 = z$.

  These operations are common in low-level computing tasks, and SMT solvers can handle them by using the rules of bit-wise operations.

- **Arrays and functions**: Arrays are lists of numbers or objects, and functions describe how inputs are mapped to outputs. SMT solvers can reason about arrays and functions using logical and mathematical rules. For example, in array theory, you might ask: “Is there a way to assign values to an array such that the sum of all its elements is 20?”, or in function theory: “Is there a function $f(x)$ that satisfies $f(2) = 4$ and $f(3) = 9$?”.

### How SMT solvers work

SMT solvers work in two main steps:

1. **Boolean abstraction**: The solver first treats the problem as a SAT problem by working with the Boolean logic part. It temporarily ignores the complicated mathematical parts (like numbers or arrays) and focuses on the logical structure.
  
2. **Theory solving**: After the SAT part is solved, the SMT solver checks if the numbers, arrays, or functions meet the additional constraints defined by the theory. If the SAT part leads to a solution that violates the mathematical rules (e.g., if the solution says $x + y = 10$ but the theory says that’s not possible), the solver tries a different assignment.

This combination of logical reasoning (like in SAT) and mathematical reasoning (using theories) makes SMT solvers extremely powerful.

### Complexity

**SMT is NP-hard**, meaning it is at least as hard as the hardest problems in **NP**. This is important because many real-world problems can be formulated as SMT problems, and solving them efficiently is difficult. Like SAT, SMT involves searching through many possible assignments for variables, but in addition to simple logic, the solver must also deal with more complex mathematical theories (such as arithmetic or arrays).

This makes SMT harder to solve than pure SAT problems because the solver not only needs to find a logical assignment but also ensure that it satisfies the rules of the mathematical theory involved. Despite this complexity, SMT solvers have become incredibly advanced and are used in many real-world applications.

### Why SMT is powerful

While **SAT** is a powerful tool for solving logical problems that involve only True/False values, **SMT** goes much further. It combines logic with mathematics, allowing us to solve more complex problems that involve not just logical variables, but also numbers, functions, arrays, and other mathematical structures. By incorporating **theories** such as arithmetic, arrays, and functions, SMT enables us to reason about problems that SAT alone cannot handle.

In a SAT problem, we are limited to determining whether a set of logical conditions can all be true at once, with variables that can only be **True** or **False**. While this is useful in many areas (like circuit verification and puzzle-solving), it doesn't account for problems that involve numbers, functions, or more abstract data types.

SMT enhances SAT by allowing us to work with variables that take on more complex values and obey specific rules (or **theories**). This means that SMT can handle problems like:

- Arithmetic: **Finding numbers** that satisfy equations or inequalities.

- Bit-vectors: **Verifying computer hardware** by modeling numbers as binary digits.

- Arrays: **Working with data structures**, such as lists or tables, and reasoning about how elements are stored and accessed.

- Functions: **Handling relationships** between inputs and outputs, which is useful for reasoning about computer programs or mathematical models.

For example, consider a problem where you need to find two numbers, $x$ and $y$, such that:

- $x + y = 10$.

- $x > 3$.

- $y \leq 6$.

A simple SAT solver cannot deal with this because it only works with True/False values. An SMT solver, however, can use **linear arithmetic theory** to find values for $x$ and $y$ that satisfy these conditions.

### Real-world applications

Because SMT solvers can handle both logic and mathematics, they are used in a wide range of **real-world applications**. These applications often involve problems where both logical conditions and numerical relationships must be satisfied at the same time. Here are a few important areas where SMT solvers play a critical role:

- **Verifying computer programs**: In the world of software, programs are expected to behave correctly no matter what inputs they receive or what paths their execution follows. SMT solvers are used to **formally verify** that programs do not crash, run into errors, or behave unexpectedly.

  For instance, if you write a program that calculates the square root of a number, you need to make sure it never tries to compute the square root of a negative number (which would cause an error). An SMT solver can check all possible inputs to ensure that the program handles every situation correctly, even the edge cases that a human might miss.

  By using SMT, software engineers can catch potential bugs **before** they happen, preventing costly errors in industries like aerospace, medical devices, or financial systems, where software correctness is absolutely critical.

- **Solving scheduling problems**: SMT solvers are also used in **scheduling**—a problem that involves assigning tasks to people, machines, or time slots while following certain rules. These rules might include constraints like:

  - A task can only start after another task is finished.

  - Some tasks cannot be done at the same time.

  - Certain workers are only available at specific times.

  Imagine trying to schedule a series of construction tasks on a large building site. Each task depends on other tasks being completed (you can’t install the windows before the walls are built!), and you only have a limited number of workers available. SMT solvers can process these constraints and find an **optimal schedule** that minimizes delays and uses resources efficiently.

  This ability to handle both logical dependencies and numerical constraints makes SMT invaluable for **resource allocation**, **project planning**, and **logistics** in industries like manufacturing, transportation, and healthcare.

- **Optimizing circuit designs**: In hardware design, particularly for computer chips, engineers need to ensure that the circuit behaves correctly under all possible input combinations. This is critical because even a small error can lead to catastrophic consequences, like a computer crashing or malfunctioning. Using **bit-vector theory**, SMT solvers model how circuits manipulate binary data (0s and 1s) and check whether the circuit design meets the required specifications. For example, SMT can verify that:

  - A chip correctly adds two numbers without overflow.

  - A processor handles all operations within its performance constraints.

  In addition, SMT solvers can **optimize designs** by ensuring that the chip uses the least amount of resources (such as power or space) while still functioning correctly. This makes them indispensable in the **semiconductor industry**, where efficient design is key to building faster, smaller, and more energy-efficient devices.

- **Efficiency and scalability**: SMT solvers are designed to handle incredibly complex problems efficiently. Modern SMT solvers, like **Z3** (developed by Microsoft), can deal with problems involving thousands or even millions of variables and constraints. This scalability makes SMT solvers incredibly powerful for:

- **Large-scale software verification**: Ensuring that huge codebases (like operating systems or flight control software) work as intended.

- **Optimizing systems**: Designing more efficient networks, circuits, or schedules, even for very large projects.

Even though SMT is **NP-hard**, meaning that solving these problems can take a long time in the worst cases, the development of advanced algorithms and heuristics has made SMT solvers practical for many real-world applications. They use techniques like **backtracking**, **conflict-driven clause learning**, and **theory propagation** to narrow down the search space and find solutions faster.

- **Combining multiple theories**: One of the most powerful aspects of SMT is its ability to **combine multiple theories** within a single problem. For example, you might have a problem that involves both:

  - **Arithmetic** (finding numbers that satisfy equations).

  - **Arrays** (managing lists of data).

  - **Bit-vectors** (handling binary data).

An SMT solver can integrate these theories, solving a problem that involves many different types of constraints at once. This flexibility is what makes SMT such a versatile tool for solving problems that span both **logic** and **mathematics**.

