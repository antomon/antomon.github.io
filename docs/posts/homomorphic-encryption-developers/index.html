<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Antonio Montano">
<meta name="dcterms.date" content="2022-06-23">
<meta name="keywords" content="cryptography, homomorphic encryption, RSA">
<meta name="description" content="As data privacy becomes a critical concern in the digital era, cryptographic innovations such as Homomorphic Encryption are paving the way for secure and private data processing. HE allows computations on encrypted data without decryption, enabling privacy-preserving operations across diverse fields like healthcare, finance, cloud computing, and blockchain. This tutorial explores the principles of HE, its different flavors, and its integration with complementary techniques like Differential Privacy, Secure Multiparty Computation, and Zero-Knowledge Proofs. While it holds transformative potential, challenges such as computational overheads, ciphertext expansion, and scalability hinder its widespread adoption. By addressing these barriers and advancing cryptographic research, Homomorphic Encryption can unlock unprecedented opportunities for secure data collaboration and innovation, safeguarding privacy without compromising utility.">

<title>Homomorphic Encryption for Developers – Random Bits of Knowledge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-a6e161b2431e1f94a14e0f5d32135a3c.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-b2a7339694e06740d032edc158978459.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="../../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">
<script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=663ff7b280d7c0001914e592&amp;product=sticky-share-buttons" async="async"></script>
<script src="https://cdn.jsdelivr.net/npm/typewriter-effect@latest/dist/core.js"></script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="Homomorphic Encryption for Developers – Random Bits of Knowledge">
<meta property="og:description" content="As data privacy becomes a critical concern in the digital era, cryptographic innovations such as Homomorphic Encryption are paving the way for secure and private data processing. HE allows computations on encrypted data without decryption, enabling privacy-preserving operations across diverse fields like healthcare, finance, cloud computing, and blockchain. This tutorial explores the principles of HE, its different flavors, and its integration with complementary techniques like Differential Privacy, Secure Multiparty Computation, and Zero-Knowledge Proofs. While it holds transformative potential, challenges such as computational overheads, ciphertext expansion, and scalability hinder its widespread adoption. By addressing these barriers and advancing cryptographic research, Homomorphic Encryption can unlock unprecedented opportunities for secure data collaboration and innovation, safeguarding privacy without compromising utility.">
<meta property="og:image" content="https://antomon.github.io/posts/homomorphic-encryption-developers/homomorphic-encryption.webp">
<meta property="og:site_name" content="Random Bits of Knowledge">
<meta name="twitter:title" content="Homomorphic Encryption for Developers – Random Bits of Knowledge">
<meta name="twitter:description" content="As data privacy becomes a critical concern in the digital era, cryptographic innovations such as Homomorphic Encryption are paving the way for secure and private data processing. HE allows computations on encrypted data without decryption, enabling privacy-preserving operations across diverse fields like healthcare, finance, cloud computing, and blockchain. This tutorial explores the principles of HE, its different flavors, and its integration with complementary techniques like Differential Privacy, Secure Multiparty Computation, and Zero-Knowledge Proofs. While it holds transformative potential, challenges such as computational overheads, ciphertext expansion, and scalability hinder its widespread adoption. By addressing these barriers and advancing cryptographic research, Homomorphic Encryption can unlock unprecedented opportunities for secure data collaboration and innovation, safeguarding privacy without compromising utility.">
<meta name="twitter:image" content="https://antomon.github.io/posts/homomorphic-encryption-developers/homomorphic-encryption.webp">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar docked nav-fixed slimcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../favicon.png" alt="AM logo" class="navbar-logo light-content">
    <img src="../../favicon.png" alt="AM logo" class="navbar-logo dark-content">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Random Bits of Knowledge</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../contents/services.html"> 
<span class="menu-text">Services</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-collections" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Collections</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-collections">    
        <li>
    <a class="dropdown-item" href="../../collections/bookmarks-inspiration.html">
 <span class="dropdown-text">Bookmarks of Inspiration</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../collections/cabinet-digital-curiosities.html">
 <span class="dropdown-text">Cabinet of Digital Curiosities</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../collections/free-knowledge.html">
 <span class="dropdown-text">Free Knowledge</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="https://4m4.it/corso-python/"> 
<span class="menu-text">Corso Python</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/montano/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/antomon"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/antomon"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <a class="flex-grow-1 no-decor" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
          <h1 class="quarto-secondary-nav-title">Homomorphic Encryption for Developers</h1>
        </a>     
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title d-none d-lg-block">Homomorphic Encryption for Developers</h1>
            <p class="subtitle lead">Unlocking data privacy with powerful cryptographic techniques</p>
                  <div>
        <div class="description">
          As data privacy becomes a critical concern in the digital era, cryptographic innovations such as Homomorphic Encryption are paving the way for secure and private data processing. HE allows computations on encrypted data without decryption, enabling privacy-preserving operations across diverse fields like healthcare, finance, cloud computing, and blockchain. This tutorial explores the principles of HE, its different flavors, and its integration with complementary techniques like Differential Privacy, Secure Multiparty Computation, and Zero-Knowledge Proofs. While it holds transformative potential, challenges such as computational overheads, ciphertext expansion, and scalability hinder its widespread adoption. By addressing these barriers and advancing cryptographic research, Homomorphic Encryption can unlock unprecedented opportunities for secure data collaboration and innovation, safeguarding privacy without compromising utility.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">cryptography</div>
                <div class="quarto-category">Python</div>
                <div class="quarto-category">tutorial</div>
                <div class="quarto-category">🇬🇧</div>
              </div>
                  </div>
  </div>
    
  <div class="quarto-title-meta-author">
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-heading">Affiliation</div>
    
      <div class="quarto-title-meta-contents">
      <p class="author">Antonio Montano <a href="mailto:antonio.montano.contact@gmail.com" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> <a href="https://orcid.org/0009-0007-2429-1921" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
    </div>
    <div class="quarto-title-meta-contents">
          <p class="affiliation">
              4M4
            </p>
        </div>
    </div>

  <div class="quarto-title-meta">

        
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">June 23, 2022</p>
      </div>
    </div>
    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">December 30, 2024</p>
      </div>
    </div>
      
    </div>
    

  <div>
    <div class="keywords">
      <div class="block-title">Keywords</div>
      <p>cryptography, homomorphic encryption, RSA</p>
    </div>
  </div>
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
      <a href="../../index.html" class="sidebar-logo-link">
      </a>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="5">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#roadmap" id="toc-roadmap" class="nav-link active" data-scroll-target="#roadmap">Roadmap</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#the-challenge-with-data-security" id="toc-the-challenge-with-data-security" class="nav-link" data-scroll-target="#the-challenge-with-data-security">The challenge with data security</a></li>
  <li><a href="#computing-on-encrypted-data" id="toc-computing-on-encrypted-data" class="nav-link" data-scroll-target="#computing-on-encrypted-data">Computing on encrypted data</a></li>
  <li><a href="#semantic-security-and-controlled-malleability" id="toc-semantic-security-and-controlled-malleability" class="nav-link" data-scroll-target="#semantic-security-and-controlled-malleability">Semantic security and controlled malleability</a></li>
  <li><a href="#types-of-he" id="toc-types-of-he" class="nav-link" data-scroll-target="#types-of-he">Types of HE</a></li>
  <li><a href="#how-he-enhances-private-computing" id="toc-how-he-enhances-private-computing" class="nav-link" data-scroll-target="#how-he-enhances-private-computing">How HE enhances private computing</a></li>
  <li><a href="#applications-of-he" id="toc-applications-of-he" class="nav-link" data-scroll-target="#applications-of-he">Applications of HE</a></li>
  <li><a href="#beyond-he" id="toc-beyond-he" class="nav-link" data-scroll-target="#beyond-he">Beyond HE</a></li>
  </ul></li>
  <li><a href="#foundations-of-he" id="toc-foundations-of-he" class="nav-link" data-scroll-target="#foundations-of-he">Foundations of HE</a>
  <ul class="collapse">
  <li><a href="#homomorphisms" id="toc-homomorphisms" class="nav-link" data-scroll-target="#homomorphisms">Homomorphisms</a></li>
  <li><a href="#he-scheme" id="toc-he-scheme" class="nav-link" data-scroll-target="#he-scheme">HE scheme</a></li>
  <li><a href="#functional-completeness" id="toc-functional-completeness" class="nav-link" data-scroll-target="#functional-completeness">Functional completeness</a></li>
  <li><a href="#symmetric-vs.-asymmetric-he" id="toc-symmetric-vs.-asymmetric-he" class="nav-link" data-scroll-target="#symmetric-vs.-asymmetric-he">Symmetric vs.&nbsp;asymmetric HE</a></li>
  <li><a href="#key-components-of-an-he-scheme" id="toc-key-components-of-an-he-scheme" class="nav-link" data-scroll-target="#key-components-of-an-he-scheme">Key components of an HE scheme</a></li>
  </ul></li>
  <li><a href="#homomorphism-on-the-rsa" id="toc-homomorphism-on-the-rsa" class="nav-link" data-scroll-target="#homomorphism-on-the-rsa">Homomorphism on the RSA</a>
  <ul class="collapse">
  <li><a href="#number-theory" id="toc-number-theory" class="nav-link" data-scroll-target="#number-theory">Number theory</a></li>
  <li><a href="#modular-arithmetic" id="toc-modular-arithmetic" class="nav-link" data-scroll-target="#modular-arithmetic">Modular arithmetic</a></li>
  <li><a href="#group-theory" id="toc-group-theory" class="nav-link" data-scroll-target="#group-theory">Group theory</a></li>
  </ul></li>
  <li><a href="#the-rsa-cryptosystem" id="toc-the-rsa-cryptosystem" class="nav-link" data-scroll-target="#the-rsa-cryptosystem">The RSA cryptosystem</a>
  <ul class="collapse">
  <li><a href="#key-generation" id="toc-key-generation" class="nav-link" data-scroll-target="#key-generation">Key generation</a></li>
  <li><a href="#encryption-and-decryption" id="toc-encryption-and-decryption" class="nav-link" data-scroll-target="#encryption-and-decryption">Encryption and decryption</a></li>
  <li><a href="#homomorphic-evaluation" id="toc-homomorphic-evaluation" class="nav-link" data-scroll-target="#homomorphic-evaluation">Homomorphic evaluation</a></li>
  <li><a href="#example" id="toc-example" class="nav-link" data-scroll-target="#example">Example</a></li>
  </ul></li>
  <li><a href="#fhe-programming-example" id="toc-fhe-programming-example" class="nav-link" data-scroll-target="#fhe-programming-example">FHE programming example</a>
  <ul class="collapse">
  <li><a href="#installation" id="toc-installation" class="nav-link" data-scroll-target="#installation">Installation</a></li>
  <li><a href="#code" id="toc-code" class="nav-link" data-scroll-target="#code">Code</a></li>
  <li><a href="#further-experiments" id="toc-further-experiments" class="nav-link" data-scroll-target="#further-experiments">Further experiments</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">






<div class="no-row-height column-margin column-container"><div class="">
<p><img src="homomorphic-encryption.png" class="img-fluid" data-fig-format="png,webp"></p>
</div></div><section id="roadmap" class="level2">
<h2 class="anchored" data-anchor-id="roadmap">Roadmap</h2>
<p>In this tutorial, you’ll learn:</p>
<ul>
<li><p>Motivation for homomorphic encryption: Why processing on encrypted data matters in real-world scenarios (healthcare, finance, public cloud).</p></li>
<li><p>Fundamental building blocks: We recap the necessary number theory, group theory, and RSA to establish a strong cryptographic foundation.</p></li>
<li><p>Types of homomorphic encryption: We’ll dissect partially, somewhat, and fully homomorphic schemes, clarifying their strengths and limitations.</p></li>
<li><p>Integration with other privacy techniques: You’ll see how HE connects with Differential Privacy, Secure Multiparty Computation, Zero-Knowledge Proofs, and more.</p></li>
<li><p>Use cases and applications: Cloud computing, blockchain, secure data federation, private information retrieval, and advanced cryptographic protocols.</p></li>
<li><p>Challenges, limitations, and future directions: Noise growth, performance overhead, circuit depth, key management, as well as emerging research directions and post-quantum considerations.</p></li>
</ul>
<p>By the end, you’ll understand how HE fits into the broader cryptographic ecosystem, and you’ll be ready to start prototyping with existing HE libraries.</p>
</section>
<section id="introduction" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Imagine you’re building a healthcare app that needs to analyze patient data stored in the cloud. Since the data is sensitive, you encrypt it before sending it. However, every time you need to analyze the data, you have to decrypt it, which means the data is exposed and creates a security risk.</p>
<p>This is the main problem with traditional encryption systems like RSA<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> and AES<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. They protect data while it’s stored or sent, but as soon as you need to use the data, you have to decrypt it. It’s like keeping money in a safe but needing to take it out every time you want to count it. This fundamental limitation makes it challenging to keep sensitive information secure throughout its lifecycle, especially as more applications rely on cloud computing, where the need for remote processing is common.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;The RSA algorithm is named after its inventors: Rivest, Shamir, and Adleman, who developed it in 1977. It is a widely-used asymmetric encryption method that relies on the computational difficulty of factoring large integers, currently enabling secure data transmission with a public key for encryption and a private key for decryption. Quantum computers can use Shor’s algorithm to factor integers exponentially faster than classical algorithms, making RSA effectively insecure against quantum attacks. See: Rivest, R. L., Shamir, A., &amp; Adleman, L. (1978). <strong>A method for obtaining digital signatures and public-key cryptosystems</strong>. <em>Communications of the ACM</em>, 21(2), 120–126. <a href="https://doi.org/10.1145/359340.359342">DOI</a>, and Shor, P. W. (1994). <strong>Algorithms for quantum computation: Discrete logarithms and factoring</strong>. <em>Proceedings of the 35th Annual Symposium on Foundations of Computer Science</em>, 124–134. IEEE. <a href="https://doi.org/10.1109/SFCS.1994.365700">DOI</a></p></div><div id="fn2"><p><sup>2</sup>&nbsp;The AES algorithm (Advanced Encryption Standard) is a symmetric encryption standard established by the National Institute of Standards and Technology (NIST) in 2001, based on the Rijndael cipher designed by Joan Daemen and Vincent Rijmen. It is widely used for secure data encryption due to its speed and robustness. See: Daemen, J., &amp; Rijmen, V. (2001). <strong>Advanced Encryption Standard (AES) (FIPS PUB 197)</strong>. <em>Federal Information Processing Standards Publications</em>. National Institute of Standards and Technology (NIST). <a href="https://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">Download</a>. AES relies on the computational difficulty of brute-forcing keys, which requires trying all possible key combinations. Quantum computers can use <strong>Grover’s algorithm</strong>, which provides a quadratic speedup for searching through possible keys. Instead of taking <span class="math inline">2^n</span> steps to brute-force an <span class="math inline">n</span>-bit key, Grover’s algorithm reduces it to approximately <span class="math inline">2^{n/2}</span> steps. This means that AES-128 (128-bit keys) would have the equivalent security of a 64-bit key against a quantum computer, making it potentially vulnerable. AES-256 is considered quantum-resistant for the foreseeable future because Grover’s algorithm would reduce its effective strength to <span class="math inline">2^{128}</span>, which is still computationally infeasible. See: UK National Cyber Security Centre. <strong>On the practical cost of Grover’s algorithm for AES key recovery</strong>. <em>Fifth PQC Standardization Conference</em>. <a href="https://csrc.nist.gov/csrc/media/Events/2024/fifth-pqc-standardization-conference/documents/papers/on-practical-cost-of-grover.pdf">Download</a></p></div></div><p>Homomorphic encryption (HE) aims to solve this problem by allowing data to remain encrypted even while it’s being processed. It promises to make the cloud much safer for storing and analyzing data, which could have far-reaching impacts on healthcare, finance, and many other fields. Imagine being able to calculate the average income of a group of people without ever knowing how much any individual earns, that’s the promise of HE.</p>
<section id="the-challenge-with-data-security" class="level3">
<h3 class="anchored" data-anchor-id="the-challenge-with-data-security">The challenge with data security</h3>
<p>Even when data is encrypted and stored in the cloud, there are still some risks:</p>
<ol type="1">
<li><p>Metadata exposure: Even if the data is encrypted, cloud providers can still see some information:</p>
<ul>
<li>When the data is accessed.</li>
<li>How much data is being processed.</li>
<li>Patterns of usage that could reveal some details.</li>
</ul>
<p>Metadata may not contain the actual content of the data, but it can still provide insights that compromise privacy. For instance, frequent access to a medical record could imply a serious health condition, even if the actual diagnosis remains encrypted.</p></li>
<li><p>Trust issues: Cloud providers or intermediaries who have access to encryption keys could:</p>
<ul>
<li>Access decrypted data when it’s being processed.</li>
<li>Keep metadata even after the service ends.</li>
<li>Create privacy risks by storing information about data access, which could help them infer details even if the data itself is never fully decrypted</li>
</ul>
<p>These issues highlight the importance of removing the need to trust third parties. HE can help solve this problem by ensuring that data remains encrypted, even when it’s being analyzed.</p></li>
</ol>
</section>
<section id="computing-on-encrypted-data" class="level3">
<h3 class="anchored" data-anchor-id="computing-on-encrypted-data">Computing on encrypted data</h3>
<p>Let’s say Alice has some data <span class="math inline">m</span>, and Bob has a function <span class="math inline">f</span>. Alice wants to know the answer to <span class="math inline">f(m)</span>:</p>
<ul>
<li>Traditional approach: Alice has to share <span class="math inline">m</span> with Bob.</li>
</ul>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div id="fig-traditional-approach-diagram" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-traditional-approach-diagram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<pre class="mermaid mermaid-js" data-label="fig-traditional-approach-diagram">%%{init: {"theme": "neo", "look": "handDrawn"}}%%
flowchart TD
  subgraph Client["Client"]
    C1[["Step 1: Prepare private data $$\ m$$"]]
    C2[/"Step 2: Send $$\ m$$ to Server"/]
    C3[["Step 5: Receive $$\ f(m)$$ from Server"]]
  end
  subgraph Server["Server"]
    S1[["Step 3: Perform computation $$\ f(m)$$"]]
    S2[/"Step 4: Send $$\ f(m)$$ back to Client"/]
  end
  C1 --&gt; C2
  C2 --&gt; S1
  S1 --&gt; S2
  S2 --&gt; C3

  style C1 stroke:#000000
  style C2 stroke:#000000
  style C3 stroke:#000000
  style S1 stroke:#000000
  style S2 stroke:#000000
  style Client stroke:#00C853,fill:#00C853,color:#000000
  style Server stroke:#FFD600,fill:#FFD600,color:#000000
  linkStyle 0 stroke:#000000,fill:none
  linkStyle 1 stroke:#000000,fill:none
  linkStyle 2 stroke:#000000,fill:none
  linkStyle 3 stroke:#000000
</pre>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-traditional-approach-diagram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: A simple client-server scenario for the traditional approach, where C is Client (Alice) and S is Server (Bob)
</figcaption>
</figure>
</div>
</div>
</div>
<ul>
<li>HE approach: Alice sends an encrypted version of <span class="math inline">m</span> to Bob, and Bob does the calculations on the encrypted data.</li>
</ul>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div id="fig-simple-he-diagram" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-simple-he-diagram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<pre class="mermaid mermaid-js" data-label="fig-simple-he-diagram">%%{init: {"theme": "neo", "look": "handDrawn"}}%%
flowchart TD
  subgraph Client["Client"]
    C1[["Step 1: Encrypt private data $$\ Enc(m)$$"]]
    C2[/"Step 2: Send $$\ Enc(m)\ $$ to Server"/]
    C3[/"Step 3: Send query $$\ f()\ $$ to Server"/]
    C4[["Step 6: Compute $$\ Dec(Enc(f(m)))=f(m)\ $$"]]
  end
  subgraph Server["Server"]
    S1[["Step 4: Perform $$\ Eval(f, Enc(m))=Enc(f(m))\ $$"]]
    S2[\"Step 5: Return $$\ Enc(f(m))\ $$ to Client"\]
  end
  C1 --&gt; C2
  C2 --&gt; C3
  C3 --&gt; S1
  S1 --&gt; S2
  S2 --&gt; C4

  style C1 stroke:#000000
  style C2 stroke:#000000
  style C3 stroke:#000000
  style C4 stroke:#000000
  style S1 stroke:#000000
  style S2 stroke:#000000
  style Client stroke:#00C853,fill:#00C853,color:#000000
  style Server stroke:#FFD600,fill:#FFD600,color:#000000
  linkStyle 0 stroke:#000000,fill:none
  linkStyle 1 stroke:#000000,fill:none
  linkStyle 2 stroke:#000000,fill:none
  linkStyle 3 stroke:#000000,fill:none
  linkStyle 4 stroke:#000000
</pre>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-simple-he-diagram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: A simple client-server HE scenario, where C is Client (Alice) and S is Server (Bob)
</figcaption>
</figure>
</div>
</div>
</div>
<p>Conventional semantically secure schemes are designed to be non-malleable; useful computation is not supported by design. HE intentionally reintroduces carefully controlled malleability. HE is different, because it keeps the relationships between numbers, even when they’re encrypted. Here’s a simple example:</p>
<ul>
<li><p>Let’s say you have two numbers, <span class="math inline">a</span> and <span class="math inline">b</span>.</p></li>
<li><p>You encrypt them to get <span class="math inline">Enc(a)</span> and <span class="math inline">Enc(b)</span>.</p></li>
<li><p>With HE, you can add <span class="math inline">Enc(a)</span> and <span class="math inline">Enc(b)</span> and get an encrypted result that, when decrypted, gives you <span class="math inline">a + b</span>.</p></li>
</ul>
<p>This means you can perform calculations on encrypted data without having to decrypt it first. The ability to compute on encrypted data without decryption is what makes HE so revolutionary. In essence, it allows data to stay secure throughout its entire lifecycle, from collection to storage to processing.</p>
<p>HE works by using complex mathematical operations that preserve the structure of the data even when it’s encrypted. The mathematics behind this is quite advanced, involving abstract algebra and number theory. These mathematical techniques ensure that operations such as addition and multiplication can be performed on the encrypted data in a way that yields correct results when decrypted.</p>
</section>
<section id="semantic-security-and-controlled-malleability" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="semantic-security-and-controlled-malleability">Semantic security and controlled malleability</h3>
<p>HE is possible thanks to two key cryptographic concepts: <strong>semantic security</strong> and <strong>controlled malleability</strong>. While these might sound technical, they’re not too hard to understand when broken down.</p>
<p>First, let’s talk about semantic security. This property ensures that encrypted data reveals absolutely nothing about the original data. For example, even if you encrypt the same message twice, the results will look completely different every time, like writing a note and hiding it in different locked boxes that look unique each time. This randomness makes it impossible for someone to guess the original message just by looking at the encrypted result. Semantic security (IND-CPA<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>) is a cornerstone of most modern encryption schemes, such as AES for secure data storage and RSA for transmitting confidential messages over the internet. <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> In these systems, semantic security ensures that an attacker cannot deduce the plaintext, even if they intercept encrypted messages.</p>
<div class="no-row-height column-margin column-container"><div id="fn3"><p><sup>3</sup>&nbsp;IND-CCA stands for indistinguishability under chosen-ciphertext attack. It strengthens IND-CPA by allowing the adversary to not only choose plaintexts for encryption but also query a decryption oracle on arbitrary ciphertexts (except the challenge one). A scheme is IND-CCA secure if the attacker still cannot distinguish which of two messages was encrypted, even with that extra power. In practice, this rules out malleability attacks such as Bleichenbacher’s on raw RSA. Achieving IND-CCA usually requires carefully designed padding and mode of operation: e.g.&nbsp;RSA with OAEP (for encryption) or schemes like Cramer–Shoup.</p></div><div id="fn4"><p><sup>4</sup>&nbsp;Strictly speaking, textbook RSA is <em>not</em> semantically secure (IND-CPA). Without padding, it is deterministic and leaks information because the same plaintext always yields the same ciphertext. Semantic security in practice is achieved only when RSA is combined with proper padding schemes such as OAEP (Optimal Asymmetric Encryption Padding), or when used in hybrid constructions where RSA encrypts a symmetric key and the actual message is protected with a semantically secure symmetric cipher in AEAD mode (e.g., AES-GCM or ChaCha20-Poly1305). See Bellare, M., &amp; Rogaway, P. (1995). <strong>Optimal asymmetric encryption—How to encrypt with RSA.</strong> In A. De Santis (Ed.), <em>Advances in cryptology—EUROCRYPT ’94: Workshop on the theory and application of cryptographic techniques</em>, Perugia, Italy, May 9–12, 1994, Proceedings (pp.&nbsp;92–111). Springer. <a href="https://doi.org/10.1007/BFb0053428">DOI</a></p></div></div><p>Now, let’s look at controlled malleability. Normally, encryption schemes are designed to prevent any modification of encrypted data. For example, in secure messaging or financial transactions, tampering with ciphertexts could lead to corruption or malicious alterations. This is why many encryption schemes aim to be non-malleable, ensuring ciphertexts cannot be manipulated in any meaningful way. However, some cryptographic protocols intentionally use a controlled form of malleability. For instance:</p>
<ul>
<li><p>RSA encryption supports a basic level of malleability, enabling certain transformations (e.g., multiplying ciphertexts) that correspond to transformations on the plaintext.</p></li>
<li><p>Secure Multi-Party Computation (SMC) uses malleable properties to allow multiple parties to jointly compute a function over their inputs without revealing them to each other.</p></li>
</ul>
<p>HE takes controlled malleability a step further by enabling a rich set of mathematical operations, such as additions and multiplications, to be performed directly on encrypted data. This means that encrypted data can be actively processed, opening up new possibilities for secure computation without exposing sensitive information.</p>
<p>By combining semantic security with controlled malleability, HE represents a powerful new paradigm in cryptography. While semantic security ensures that the original data remains completely hidden, controlled malleability allows computations on that hidden data in a secure and predictable way. Together, these concepts extend the boundaries of what encryption can achieve, enabling privacy-preserving technologies that go far beyond the limitations of traditional cryptographic schemes.</p>
</section>
<section id="types-of-he" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="types-of-he">Types of HE</h3>
<p>HE encompasses various schemes, each with distinct capabilities, applications, and a shared mathematical heritage that connects their evolution. These different types of HE have progressively built on one another, with each advancement adding new capabilities while maintaining foundational principles rooted in number theory and algebra.</p>
<ol type="1">
<li><p><strong>Partially Homomorphic Encryption (PHE):</strong></p>
<ul>
<li><p>PHE supports a single type of operation, either addition or multiplication, on encrypted data, which offers high efficiency due to its limited operational scope.</p></li>
<li><p>Applications: Ideal for scenarios requiring only one type of computation. For instance, PHE is utilized in secure voting systems, where votes are encrypted and then aggregated (added) without decryption, ensuring voter privacy and data integrity.</p></li>
<li><p>Historical context: The concept of PHE dates back to 1978 with the introduction of the RSA algorithm, which supports multiplicative homomorphism. Subsequent schemes, such as the Paillier cryptosystem introduced in 1999, provided additive homomorphism, allowing for the addition of encrypted values. These early approaches laid the mathematical foundation for later, more complex forms of HE. The development of RSA was also a part of broader cryptographic breakthroughs in public-key cryptography, which fundamentally changed secure communication by allowing encryption without pre-shared keys.</p></li>
<li><p>Some notable examples:</p>
<ul>
<li>RSA: Supports multiplication as the homomorphic operation.</li>
<li>Paillier: Addition.</li>
<li>ElGamal is homomorphic multiplicatively</li>
<li>Goldwasser-Micali over bits supports XOR (i.e., additive mod 2).</li>
<li>Okamoto-Uchiyama: Addition.</li>
</ul></li>
</ul></li>
<li><p><strong>Somewhat Homomorphic Encryption (SWHE):</strong></p>
<ul>
<li><p>SWHE enables both addition and multiplication operations but only up to a certain depth or number of operations. It balances between operational flexibility and computational efficiency, making it suitable for applications with limited computational requirements.</p></li>
<li><p>Applications: SWHE is applied in secure data aggregation, where a limited number of operations are performed on encrypted data to compute aggregate statistics without exposing individual data points.</p></li>
<li><p>Historical context: SWHE schemes emerged as researchers sought to extend the capabilities of PHE. By building on the foundational mathematics of PHE, these schemes introduced the ability to perform both additive and multiplicative operations, though with certain limitations. This progression marked an important step towards achieving fully HE. The development of SWHE was influenced by lattice-based cryptography, which also played a crucial role in providing security against quantum computing attacks, linking SWHE to advances in post-quantum cryptography.</p></li>
</ul></li>
<li><p><strong>Fully Homomorphic Encryption (FHE):</strong></p>
<ul>
<li><p>FHE allows an unlimited number of both addition and multiplication operations on encrypted data. While computationally intensive, FHE provides the most comprehensive functionality, enabling complex computations on encrypted datasets.</p></li>
<li><p>Applications: FHE is particularly valuable in privacy-preserving data processing, such as performing machine learning algorithms on encrypted medical records, allowing for data analysis without compromising patient confidentiality.</p></li>
<li><p>Historical context: The concept of FHE was first realized by Craig Gentry in 2009<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>, marking a significant advancement in cryptography. Gentry’s construction built upon the principles and challenges addressed by PHE and SWHE, demonstrating that it was possible to perform arbitrary computations on encrypted data without decryption. This breakthrough opened new avenues for secure data processing, rooted in the same mathematical lineage that began with PHE. Gentry’s work was heavily influenced by the concept of ideal lattices and the use of bootstrapping, which allowed for refreshing encrypted data, a concept that is closely related to error correction techniques used in coding theory. FHE also contributed to advancements in multi-party computation and secure function evaluation, highlighting its relationship with other cryptographic fields focused on secure collaborative computing.</p></li>
</ul></li>
</ol>
<div class="no-row-height column-margin column-container"><div id="fn5"><p><sup>5</sup>&nbsp;Gentry, C. (2009). <strong>Fully homomorphic encryption using ideal lattices</strong>. <em>Proceedings of the 41st Annual ACM Symposium on Theory of Computing</em>, 169–178. <a href="https://doi.org/10.1145/1536414.1536440">DOI</a></p></div></div></section>
<section id="how-he-enhances-private-computing" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="how-he-enhances-private-computing">How HE enhances private computing</h3>
<p>HE can be combined with other privacy techniques to keep data secure while still being able to use it. These techniques are independent but can work well together with HE to achieve privacy goals:</p>
<ul>
<li><p><strong>Differential Privacy (DP)</strong>: DP<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> is a method that ensures individual data points in a dataset can’t be identified, even if the results are analyzed multiple times. By adding noise to the output, DP protects people’s privacy while still allowing useful insights to be gained from the data. HE can be combined with DP to keep data encrypted during analysis, while DP adds another layer of privacy. For example, a healthcare company could use HE to compute encrypted patient data and add DP to ensure that the output does not compromise individual identities.</p></li>
<li><p><strong>Secure Multi-Party Computation (SMC)</strong>: SMC<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> allows several parties to jointly compute a result from their inputs without revealing those inputs to each other. HE is often used in SMC to make sure the data stays encrypted throughout the computation. This way, everyone can contribute without giving up their private data. For example, multiple banks could jointly analyze data to detect fraud patterns without sharing individual customer information.</p></li>
<li><p><strong>Zero-Knowledge Proofs (ZKPs)</strong>: ZKPs<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> are a way to prove that a statement is true without revealing any other information beyond the fact that the statement is true. ZKPs can be combined with HE to verify computations on encrypted data without revealing any sensitive information. This is particularly useful in scenarios like blockchain, where privacy and verification are both important. For instance, ZKPs could allow someone to prove they have enough funds for a transaction without revealing their exact account balance.</p></li>
</ul>
<div class="no-row-height column-margin column-container"><div id="fn6"><p><sup>6</sup>&nbsp;Dwork, C., &amp; Roth, A. (2014). <strong>The algorithmic foundations of differential privacy</strong>. <em>Foundations and Trends in Theoretical Computer Science</em>, 9(3–4), 211–407. <a href="https://doi.org/10.1561/0400000042">DOI</a></p></div><div id="fn7"><p><sup>7</sup>&nbsp;Yao, A. C. (1982). <strong>Protocols for secure computations</strong>. <em>23rd annual symposium on foundations of computer science (SFCS 1982)</em> (pp.&nbsp;160-164). IEEE. <a href="https://doi.org/10.1109/SFCS.1982.38">DOI</a></p></div><div id="fn8"><p><sup>8</sup>&nbsp;Goldwasser, S., Micali, S., &amp; Rackoff, C. (1989). <strong>The knowledge complexity of interactive proof systems</strong>. <em>SIAM Journal on computing</em>, 18(1), 186-208. <a href="https://doi.org/10.1137/0218012">DOI</a></p></div></div></section>
<section id="applications-of-he" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="applications-of-he">Applications of HE</h3>
<section id="public-cloud-services" class="level4">
<h4 class="anchored" data-anchor-id="public-cloud-services">Public cloud services</h4>
<p>Imagine a giant digital library that many people share—this is essentially what a public cloud service is. Services like Google Drive, Dropbox, Microsoft Azure, or any Software as a Service (SaaS) application, such as email platforms, social networks, or collaboration tools, are examples where many users store and process their data in the same place. It’s like having your personal locker in a public gym—while you have your private space, you’re still using a shared facility. The more “layers” or services your data interacts with, the greater the privacy risks become, as each layer can potentially expose your data to further vulnerabilities.</p>
<p>The challenge with public clouds is keeping your information private while still being able to use all the helpful features they offer. Think about it like this: you want to ask someone to count your money, but you don’t want them to see how much you have. That’s where HE comes in: it lets the cloud service work with your data without actually seeing what’s in it.</p>
<p>Public cloud services are used for various purposes, including data storage, file sharing, and running applications remotely. The privacy challenge in public cloud services is significant, as many users want the benefits of powerful processing without sacrificing the confidentiality of their data. HE offers a groundbreaking solution, allowing computations to be performed while the data remains encrypted. This means users can get useful insights and results from their data without exposing it to the cloud provider or any unauthorized third party.</p>
<p>HE enables users to make the most of public cloud services without giving up their privacy. For example, organizations can store and process customer information, health records, and financial data without ever exposing sensitive information. This capability makes public cloud services more secure and suitable for a wide range of applications involving confidential data. Additionally, HE can help governments, businesses, and individuals alike to harness the full potential of cloud-based services without the fear of privacy breaches.</p>
<p>Moreover, HE provides a way for SaaS applications like email platforms and social networks to perform useful functions on user data while maintaining privacy. For instance, an email service could filter spam emails or provide automated categorization features without actually accessing the content of your emails. Similarly, a social network could analyze user preferences to deliver targeted content or enhance user experience, all while keeping personal data fully encrypted.</p>
<p>When using SaaS applications, data often passes through multiple “layers” of services, each adding to the potential privacy risks. These layers could involve data storage, processing, and analysis, all of which need to be handled with the utmost care. HE mitigates these risks by ensuring that data is encrypted throughout its entire journey—from storage to computation. This makes public cloud services and SaaS platforms much safer environments for processing sensitive information, as the data remains encrypted at every stage.</p>
<p>Real-world examples:</p>
<ul>
<li><p>Navigation apps: Helps you find your way without revealing where you are. Imagine telling someone, “I’m somewhere in New York” and getting directions without revealing your exact street corner. The privacy benefit is that your location stays secret while still getting accurate directions. HE allows navigation services to process your location data while keeping the exact coordinates hidden, ensuring your privacy while still providing efficient route guidance. This is especially important for users who are concerned about sharing their real-time location with third parties.</p></li>
<li><p>Health monitoring Devices: Your smartwatch or fitness tracker can process your health data securely. It’s like having a doctor analyze your health charts while they’re in a sealed envelope. You get health insights while keeping your personal metrics private. Imagine that a health service aggregates data from thousands of users’ fitness trackers to find patterns in sleep quality. HE allows this analysis while keeping every user’s specific sleep data private, so the service can improve recommendations without compromising privacy. This means that even if the cloud service processes millions of health records, individual users’ data remains secure and confidential.</p></li>
<li><p>Personal finance: Gets insights from your data without exposing the details. Similar to having someone tell you if your spending is normal for your age group without seeing your actual purchases. You learn from your data while keeping it confidential. A budgeting app could use HE to compare a user’s spending habits against aggregate data to provide personalized recommendations, all while keeping individual transactions encrypted and secure. For instance, the app could analyze spending trends, identify areas for improvement, and suggest budgeting strategies—all without ever accessing your raw financial data in a readable form.</p></li>
<li><p>Email filtering: Modern email services often use filters to identify spam, categorize messages, and even detect potential phishing attacks. With HE, these services can perform all of these operations without having to read the content of your emails. This ensures that your private messages remain confidential while still benefiting from advanced filtering and organizational features. Imagine an email provider categorizing your emails into folders such as Promotions, Social, and Primary—all without actually knowing what the emails say.</p></li>
<li><p>Social networks: Social media platforms often use algorithms to suggest content based on user behavior. With HE, these platforms can analyze user interactions, such as likes, comments, and shares, to provide tailored content recommendations, all while keeping user behavior encrypted. For example, if a social network wants to recommend friends or content, it can do so based on encrypted data, ensuring that your activity and preferences are kept private.</p></li>
<li><p>Collaboration tools: SaaS collaboration tools like document editors or project management software can use HE to provide enhanced features while keeping user data private. Imagine multiple users collaborating on a shared document, HE can ensure that the document remains encrypted while allowing authorized users to make edits and comments. This is crucial for businesses that need to ensure confidentiality while leveraging the benefits of cloud-based collaboration.</p></li>
</ul>
<p>HE represents a transformative approach to data privacy, particularly in the context of public cloud services and SaaS applications. However, as the usage of digital services continues to expand, the potential for data misuse also grows, posing significant risks to both individuals and companies. Data can be weaponized for malicious purposes, from targeted disinformation to financial exploitation, and traditional privacy measures, such as DP, may not be sufficient to fully protect sensitive information in these evolving digital landscapes. DP, while effective at masking individual contributions in datasets, often relies on the careful calibration of privacy budgets and noise, which can degrade utility or be insufficient against sophisticated attacks like reconstruction or linkage attacks, where adversaries can leverage external datasets to infer private information. HE, on the other hand, offers a promising solution by enabling computation on encrypted data without ever exposing it, providing a stronger safeguard against these emerging threats.</p>
</section>
<section id="private-cloud-computing" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="private-cloud-computing">Private cloud computing</h4>
<p>Private cloud computing provides organizations with greater control over their data and infrastructure compared to public cloud environments. This model is particularly suitable for handling sensitive information but requires a sophisticated, defense-in-depth approach to maintain data privacy and security throughout its lifecycle.</p>
<p>Private clouds are often employed by organizations that need to comply with stringent regulatory requirements, such as those related to healthcare, finance, or government operations. These regulations, including standards like HIPAA, GDPR, NIS2, and PCI DSS, mandate strict data protection protocols and require demonstrable security controls and audit trails.</p>
<p>Despite the advantages of private clouds, they remain susceptible to various threats across different layers of the technology stack. Infrastructure layer threats include software vulnerabilities in virtualization platforms, hypervisors, or orchestration tools, which can lead to risks such as privilege escalation or remote code execution (RCE). Hardware vulnerabilities, such as side-channel attacks exploiting cache timing, power analysis, or electromagnetic emanations, also pose significant risks. Physical security concerns, such as cold boot attacks and DMA attacks, along with supply chain vulnerabilities in hardware components or firmware, further complicate the security landscape.</p>
<p>Network layer threats include attacks such as ARP poisoning, VLAN hopping, and compromises of software-defined networking (SDN) controllers. Weaknesses in virtual network functions (VNFs) and east-west traffic attacks between workloads within the cloud are also notable vulnerabilities.</p>
<p>Application layer threats involve issues like API security vulnerabilities, container escape risks that allow attackers to move from containers to host systems, weaknesses in securing microservice interactions, and data leakage through application logic flaws.</p>
<p>Human and operational threats are also significant. Configuration drift and misconfigurations can lead to gradual deviation from secure states, while inadequate privilege management and insider threats (both malicious and unintentional) can compromise security. Operational security failures, such as lapses in maintaining secure practices, are also critical factors that must be addressed.</p>
<p>To mitigate these risks, organizations need a comprehensive, multi-layered security strategy that implements defense-in-depth through multiple complementary technologies. HE serves as one critical component within this broader security architecture, particularly for protecting data confidentiality during processing. Various cryptographic and security measures work together as follows:</p>
<ul>
<li><p>In the foundational security layer, hardware security modules (HSMs) are used for key management, providing secure storage and handling of cryptographic keys which are crucial for HE operations. Trusted platform modules (TPMs) ensure boot integrity, establishing a trusted baseline for secure operations, which is essential for protecting the integrity of encrypted data processed using HE. Secure boot and measured boot processes protect the system from boot-level attacks, creating a secure foundation for any HE-related operations. Physical security controls and monitoring provide physical safeguards for cloud hardware, preventing physical attacks that could compromise the hardware used to perform HE computations.</p></li>
<li><p>In the network security layer, microsegmentation with zero-trust principles limits lateral movement within the network, ensuring that even if an attacker gains access, they cannot reach the nodes performing HE computations. Virtual network encryption ensures data confidentiality across virtual networks, which complements HE by protecting data during transit, even before or after HE-based processing. Network access control with 802.1x enforces authentication for devices on the network, preventing unauthorized devices from accessing data that may be encrypted using HE. SDN security, involving the separation of control and data planes, helps mitigate vulnerabilities within SDN environments, providing a secure pathway for the data to be processed using HE without risking exposure.</p></li>
<li><p>For data in transit, Transport Layer Security (TLS) 1.3 with perfect forward secrecy protects data from interception, while IPsec provides network-level encryption, ensuring that data remains secure during transmission before and after HE operations. For data at rest, AES-256 encryption with secure key management protects stored data from unauthorized access, complementing HE by providing strong encryption when data is not actively being processed. Format-preserving encryption is used to protect structured data without altering its format (e.g., credit card numbers remain digit-strings of the same length), which is valuable for system compatibility and data integrity. Homomorphic encryption, by contrast, enables computations to be performed securely on encrypted data without first decrypting it.</p></li>
<li><p>For data in use, HE is combined with Trusted Execution Environments (TEEs)<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> for enhanced data protection during processing. TEEs provide a secure, isolated hardware environment for executing sensitive operations, protecting against unauthorized access by ensuring that data and computations are shielded from other processes on the system. HE further enhances this by keeping the data encrypted even within the TEE, ensuring that even if the secure environment is compromised, the data remains confidential.</p></li>
<li><p>SMC is also employed for collaborative computations without revealing individual inputs. Advanced integrations include using HE with Intel SGX for secure computation spaces, hybrid HE-MPC protocols for efficient distributed computing, and memory encryption with AMD SEV or Intel TDX for enhanced data protection.</p></li>
<li><p>HE can also be integrated with Attribute-Based Encryption (ABE)<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> to allow fine-grained access control, ensuring that data access is granted only to users with specific attributes or roles. Identity-Based Encryption (IBE)<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> simplifies key management by allowing public keys to be derived from unique user identifiers, reducing the complexity of certificate distribution (Boneh, D., &amp; Franklin, M., 2001). ZKPs provide anonymous authentication, allowing users to prove their identity or access rights without revealing any underlying sensitive information. By combining these techniques, HE ensures that data remains encrypted throughout its lifecycle while still allowing flexible and secure access management, simplified key handling, and privacy-preserving authentication.</p></li>
</ul>
<div class="no-row-height column-margin column-container"><div id="fn9"><p><sup>9</sup>&nbsp;McKeen, F., Alexandrovich, I., Berenzon, A., Rozas, C., Shafi, H., Shanbhogue, V., &amp; Savagaonkar, U. R. (2013). <strong>Innovative instructions and software model for isolated execution</strong>. <em>Proceedings of the 2nd International Workshop on Hardware and Architectural Support for Security and Privacy (HASP)</em>. https://doi.org/10.1145/2487726.2488368</p></div><div id="fn10"><p><sup>10</sup>&nbsp;Goyal, V., Pandey, O., Sahai, A., &amp; Waters, B. (2006). <strong>Attribute-based encryption for fine-grained access control of encrypted data</strong>. <em>Proceedings of the 13th ACM Conference on Computer and Communications Security (CCS)</em>, 89-98. <a href="https://doi.org/10.1145/1180405.1180418">DOI</a></p></div><div id="fn11"><p><sup>11</sup>&nbsp;Boneh, D., &amp; Franklin, M. (2001). <strong>Identity-based encryption from the Weil pairing</strong>. <em>SIAM Journal on Computing</em>, 32(3), 586-615. <a href="https://doi.org/10.1137/S0097539701398521">DOI</a></p></div></div><p>This layered approach ensures that HE is not deployed in isolation but rather as part of a comprehensive security architecture where each component strengthens the overall security posture. The combination of these technologies provides defense-in-depth while addressing specific threats at each layer of the infrastructure.</p>
<p>Real-world examples:</p>
<ul>
<li><p>Medical research: HE, when combined with AES-256 encryption and TEEs, allows hospitals to study patient data while maintaining privacy. Within the private cloud, patient data is securely stored using AES-256 encryption and processed within TEEs, while HE allows computations on encrypted data without decryption. For example, doctors can analyze medical images with patient details encrypted and isolated, enabling researchers to identify important patterns without seeing individual patient information. When data needs to be shared across institutions, SMC is used to ensure data privacy, thereby identifying effective treatments and new drug opportunities while ensuring patient privacy.</p></li>
<li><p>Financial services: In the private cloud, financial institutions store customer data encrypted using AES-256 and conduct computations using HE combined with TEEs. TLS ensures data confidentiality when it moves in and out of the private cloud. HE, in combination with TLS for data in transit and TEEs for processing, helps financial institutions process banking information while keeping account details secret. Banks can use HE to assess loan applications by running risk analyses on encrypted financial data within TEEs, enabling automated decision-making without exposing customers’ financial histories. This combination ensures data remains confidential throughout its lifecycle, from transmission to analysis.</p></li>
<li><p>Defense sector: Within a private cloud environment, sensitive defense-related data is encrypted with AES-256 and processed securely using HE and TEEs. For example, a remote-controlled drone can perform target calculations using HE while ensuring that even if intercepted, the encrypted data and computations remain confidential, safeguarding operational integrity. Logistics data can also be analyzed collaboratively among trusted partners using SMPC without revealing the underlying sensitive information, ensuring data privacy and safeguarding national security interests. TLS and IPsec are used to protect data that enters or exits the private cloud, ensuring that no sensitive information is exposed during transmission.</p></li>
</ul>
</section>
<section id="blockchain-technology" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="blockchain-technology">Blockchain technology</h4>
<p>Blockchain technology can be thought of as a digital ledger that everyone can see—like a giant spreadsheet that tracks transactions. The challenge is: how do you keep certain details private on this public ledger? It’s similar to wanting to tell people you bought something without revealing how much you paid for it.</p>
<p>Blockchain technology is known for its transparency and security, which are useful for verifying transactions. However, this transparency also creates a privacy challenge. To address this, HE, ZKPs, and SMC are employed to protect sensitive information while maintaining the integrity and verifiability of blockchain data.</p>
<section id="he-zkps-and-smc" class="level5">
<h5 class="anchored" data-anchor-id="he-zkps-and-smc">HE, ZKPs, and SMC</h5>
<p>HE ensures that sensitive information remains protected throughout the process. In blockchain systems, this is crucial for maintaining privacy without compromising the ability to verify data integrity. For example, HE can be used to perform operations on encrypted transaction details, such as calculating total transaction amounts or processing smart contract conditions, enabling stakeholders to verify outcomes without seeing the underlying sensitive data. In privacy-focused Layer 2 solutions on Ethereum, HE can be applied to compute transaction fees or aggregate user balances in encrypted form, maintaining both privacy and scalability. Similarly, in blockchain-based supply chain systems, HE enables participants to encrypt transaction details before adding them to the blockchain, ensuring that sensitive information (like pricing or quantities) remains hidden while the overall process can still be verified by stakeholders. This privacy-preserving transparency is crucial in competitive environments, allowing stakeholders to verify product provenance without exposing confidential business information.</p>
<p>ZKPs are leveraged in blockchain to enhance privacy by allowing parties to prove that certain statements are true without revealing specific information. In supply chain scenarios, ZKPs can prove that specific procedures were followed or quality standards were met without disclosing proprietary details. This ensures compliance while maintaining confidentiality. In digital identity verification, ZKPs allow individuals to prove attributes of their identity (such as being of legal age) without exposing their full identity or birthdate, ensuring privacy and compliance.</p>
<p>SMC is leveraged to enable collaborative decision-making or data aggregation on the blockchain without exposing individual inputs. This is particularly useful in decentralized finance (DeFi) platforms or voting mechanisms within decentralized governance systems. For instance, in Decentralized Autonomous Organizations (DAOs), SMC allows members to collectively compute outcomes (such as voting results) while keeping individual votes private, ensuring both transparency and privacy in the decision-making process.</p>
<p>Both HE and ZKPs aim to preserve privacy while proving computation correctness. They are often used together to enhance privacy in blockchain systems. For instance, HE can encrypt inputs while ZKPs prove the correctness of computations on these encrypted inputs. zk-SNARKs (Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge) can also be used to prove the correct execution of homomorphic operations, providing efficient and verifiable computations. Hybrid protocols that combine HE and ZKPs create efficient, private smart contracts where the correctness of encrypted computations is guaranteed without revealing sensitive information.</p>
<p>SMC and HE are complementary technologies for performing private computations on blockchain. HE can be integrated within SMC protocols to reduce the number of communication rounds required, leading to more efficient computations. Hybrid protocols that combine FHE and SMC provide improved performance and security in blockchain applications. For example, SMC and HE are used together in threshold cryptography implementations to enable secure collaborative decision-making and private data aggregation, while ensuring sensitive information remains confidential.</p>
</section>
<section id="other-cryptographic-techniques" class="level5 page-columns page-full">
<h5 class="anchored" data-anchor-id="other-cryptographic-techniques">Other cryptographic techniques</h5>
<p>The following cryptographic techniques share a common foundation in supporting privacy-preserving, hidden but verifiable computations on blockchain. These methods are often combined to enhance privacy, security, and efficiency in blockchain systems:</p>
<ul>
<li><p><strong>Commitment schemes and HE</strong>: A commitment scheme<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> is a cryptographic protocol that allows one party to commit to a chosen value while keeping it hidden from others, with the ability to reveal the value later. It ensures both secrecy and the ability to verify the commitment, which is essential for many blockchain applications. Commitment schemes and HE support hidden but verifiable computations on blockchain. Homomorphic commitments allow computations to be performed on committed values without revealing them, which can be combined with HE for verifiable encrypted computations. This combination is particularly useful in confidential transaction protocols, where participants need to commit to transaction values while still allowing certain operations to be verified.</p></li>
<li><p><strong>Threshold cryptography and HE</strong>: Threshold cryptography<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a> is a cryptographic approach in which a secret is divided into multiple parts, and a predefined number (or threshold) of those parts is required to reconstruct the secret. This approach ensures security by distributing control among several parties, reducing the risk of a single point of failure. In blockchain, threshold cryptography can be used for distributed key generation, ensuring that no single entity has full access to sensitive information, thereby enhancing security and resilience in systems like multi-signature wallets or decentralized voting. HE shares common mathematical foundations with threshold cryptography. Threshold Fully Homomorphic Encryption (TFHE)<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a> schemes allow distributed key generation and secure computations among multiple parties without revealing individual contributions. Multi-key HE is another application, enabling secure distributed computations while ensuring privacy. These techniques can also be used for shared decryption of homomorphically processed data, ensuring that no single participant can access the data in its entirety.</p></li>
<li><p><strong>Ring signatures and HE</strong>: A ring signature<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> is a type of digital signature that allows a member of a group to sign a message on behalf of the group, without revealing which specific member signed it. This provides anonymity for the signer while still proving that they are part of the group. HE and ring signatures are used together to support privacy-preserving operations on blockchain. For example, they can be combined to develop privacy-preserving voting schemes where votes are encrypted using HE, while ring signatures provide anonymity. They can also be used in anonymous credential systems where user attributes are encrypted, supporting confidential transactions without revealing individual identities.</p></li>
</ul>
<div class="no-row-height column-margin column-container"><div id="fn12"><p><sup>12</sup>&nbsp;Brassard, G., Chaum, D., &amp; Crépeau, C. (1988). <strong>Minimum disclosure proofs of knowledge</strong>. <em>Journal of Computer and System Sciences</em>, 37(2), 156-189. <a href="https://doi.org/10.1016/0022-0000(88)90005-0">DOI</a></p></div><div id="fn13"><p><sup>13</sup>&nbsp;Desmedt, Y. (1994). <strong>Threshold cryptography</strong>. <em>European Transactions on Telecommunications</em>, 5(4), 449-457. <a href="https://doi.org/10.1002/ett.4460050407">DOI</a></p></div><div id="fn14"><p><sup>14</sup>&nbsp;Asharov, G., Jain, A., López-Alt, A., Tromer, E., Vaikuntanathan, V., &amp; Wichs, D. (2012). <strong>Multiparty computation with low communication, computation and interaction via threshold FHE</strong>. <em>Advances in Cryptology–EUROCRYPT 2012</em> (pp.&nbsp;483-501). Springer, Berlin, Heidelberg. <a href="https://doi.org/10.1007/978-3-642-29011-4_29">DOI</a></p></div><div id="fn15"><p><sup>15</sup>&nbsp;Rivest, R. L., Shamir, A., &amp; Tauman, Y. (2001). <strong>How to leak a secret</strong>. <em>International Conference on the Theory and Application of Cryptology and Information Security</em> (pp.&nbsp;552-565). Springer, Berlin, Heidelberg. <a href="https://doi.org/10.1007/3-540-45682-1_32">DOI</a></p></div></div></section>
<section id="real-world-applications" class="level5">
<h5 class="anchored" data-anchor-id="real-world-applications">Real-world applications</h5>
<p>The integration of advanced cryptographic techniques into blockchain technology enables various real-world applications that enhance privacy, security, and transparency. Below are examples of how these techniques are used in practice:</p>
<ul>
<li><p>Supply chain management (Ethereum-based systems): In blockchain-based supply chain systems, HE can keep transaction details private while allowing stakeholders to verify the authenticity and origin of goods. For example, in a global supply chain where manufacturers, suppliers, and logistics providers contribute information about a product’s journey, HE ensures that while the overall process can be verified, no sensitive information (like supplier pricing or quantities) is exposed to unauthorized parties. ZKPs further enhance privacy by allowing parties to prove they followed specific procedures or met quality standards without disclosing proprietary details. These technologies ensure compliance and transparency while maintaining competitive confidentiality.</p></li>
<li><p>Digital identity verification (Algorand blockchain): HE is used to allow individuals to prove aspects of their identity without revealing unnecessary information. For instance, a person can prove they are of legal drinking age without revealing their birthdate using a blockchain-based identity verification system. ZKPs are also used in this scenario to validate identity attributes securely, ensuring privacy while maintaining compliance with regulations.</p></li>
<li><p>Decentralized marketplace transactions (Ethereum Layer 2 solutions): Buyers and sellers in a decentralized marketplace can use HE to conduct transactions privately, keeping details like transaction amounts or account balances confidential. For example, a user buying digital art can make payments using HE, ensuring that neither the marketplace nor any third parties can access their financial details.</p></li>
<li><p>Real estate transactions via Smart Contracts (Hyperledger Fabric): In a real estate transaction conducted through a smart contract, HE can be used to keep payment amounts and identities confidential while executing securely on the blockchain. This ensures compliance with local regulations while maintaining privacy for both buyers and sellers.</p></li>
<li><p>Luxury goods supply chain (VeChain): A luxury goods manufacturer may use blockchain to track the journey of products from factory to retailer. HE would keep sensitive details like supplier pricing confidential while providing proof of authenticity to consumers. For example, a watch manufacturer might leverage HE to ensure that authenticity data is available to buyers while keeping internal processes private.</p></li>
<li><p>Age verification for digital services (Cardano blockchain): Using HE, a user can prove they are above the legal age to access age-restricted products without revealing their full identity. A blockchain-based gaming platform could use HE to verify users’ ages while protecting personal data from exposure.</p></li>
<li><p>National election voting system (Tezos blockchain): In a national election using blockchain, HE keeps voter identities and preferences confidential while allowing an accurate vote count. Voters can cast their ballots online through a secure blockchain-based voting system, ensuring that individual privacy is maintained while the results remain transparent and trustworthy.</p></li>
<li><p>DAO voting (Ethereum-based DAOs): In DAOs where members vote on proposals, HE allows each vote to remain encrypted while ensuring accuracy in vote counting. This is particularly useful for DAOs managing decentralized funds, where members vote on fund allocation without revealing individual preferences.</p></li>
</ul>
</section>
</section>
<section id="secure-data-operations" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="secure-data-operations">Secure data operations</h4>
<p>Secure data operations involve multiple organizations working together with their data while keeping individual information private. In Federated Learning<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a> (FL) scenarios, where multiple entities (e.g., hospitals, financial institutions) collaborate on training a machine learning model without sharing raw data, HE and DP play crucial roles in preserving privacy throughout the process. Each participant retains control of their data and only shares encrypted model updates or contributions, which are combined to produce a global model.</p>
<div class="no-row-height column-margin column-container"><div id="fn16"><p><sup>16</sup>&nbsp;FL, introduced by McMahan et al.&nbsp;(2017), represents a paradigm shift in machine learning by enabling model training on decentralized data. This approach was developed to address the growing privacy concerns and regulatory requirements around data protection while maintaining the benefits of large-scale machine learning. The key innovation of FL lies in its “bring the code to the data” rather than “bring the data to the code” approach. In the FL framework, instead of collecting raw data from users’ devices, the model itself travels to where the data resides. Local models are trained on individual devices, and only model updates are shared with the central server, never the raw data. The paper defined the federated averaging (FedAvg) algorithm, which remains the foundation for many modern FL systems. The authors demonstrated that their approach could train deep neural networks using unbalanced and non-IID (Independent and Identically Distributed) data distributed across millions of mobile devices. See: McMahan, H. B., Moore, E., Ramage, D., Hampson, S., &amp; y Arcas, B. A. (2017). <strong>Communication-efficient learning of deep networks from decentralized data</strong>. <em>Proceedings of the 20th International Conference on Artificial Intelligence and Statistics (AISTATS)</em>. <a href="https://proceedings.mlr.press/v54/mcmahan17a.html">Download</a></p></div></div><p>DP works in tandem with HE to ensure privacy by adding random noise to the final results. This makes it difficult to determine if an individual’s data is part of the dataset or not. Imagine you are trying to guess the favorite fruit of a group of people, but you cannot be certain about any single person’s choice because a bit of randomness is added to their answers. This randomness helps protect individual privacy while still allowing you to make general conclusions about the group.</p>
<ul>
<li><p>Adding noise: DP adds noise to the final results of computations so that individual contributions are hidden. This noise is carefully controlled to strike a balance between privacy and accuracy.</p></li>
<li><p>Privacy budget: The privacy budget, represented by <span class="math inline">\varepsilon</span>, controls how much noise is added. A smaller <span class="math inline">\varepsilon</span> means more noise and greater privacy, but less accurate results. Conversely, a larger <span class="math inline">\varepsilon</span> means less noise, resulting in more accuracy but reduced privacy.</p></li>
<li><p>Mathematical definition: DP ensures that the results of computations are nearly identical, regardless of whether an individual is included in the dataset. This is achieved through the privacy budget <span class="math inline">\varepsilon</span>, which limits the amount of information that can be inferred about any single data point. The smaller the value of <span class="math inline">\varepsilon</span>, the stronger the privacy protection, as it reduces the likelihood that an individual’s data can be distinguished in the output.</p></li>
</ul>
<p>The integration of HE and DP technologies creates a multi-layered privacy framework that enhances privacy at different stages of the data lifecycle:</p>
<ol type="1">
<li><p>Initial data protection: Each participating organization encrypts its data using HE, ensuring the raw data remains secure even during computations. For instance, in FL, each hospital encrypts patient data so that it never leaves the hospital in a readable form.</p></li>
<li><p>Secure computation: Using HE, model updates are computed directly on encrypted data. For example, in training a machine learning model, HE allows hospitals to calculate model updates without decrypting patient data. All computations are performed while the data is encrypted, ensuring no sensitive information is exposed.</p></li>
<li><p>Privacy-preserving output: After computations, DP adds controlled noise to the model updates to prevent inference attacks. The privacy budget <span class="math inline">\varepsilon</span> is tracked across training iterations to ensure cumulative privacy loss remains acceptable, meaning that the privacy of individual data points is still maintained.</p></li>
</ol>
<section id="privacy-budget-management" class="level5 page-columns page-full">
<h5 class="anchored" data-anchor-id="privacy-budget-management">Privacy budget management</h5>
<p>The privacy budget management becomes more sophisticated when combining HE and DP. Advanced composition theorems help manage privacy loss in repeated operations:</p>
<ul>
<li><p>Basic composition: Every time a query is made on the data, some privacy is lost. Basic composition means that the total privacy loss simply adds up for each query.</p></li>
<li><p>Advanced composition: Privacy loss grows more slowly (with the square root of the number of queries), which helps limit the total loss.</p></li>
<li><p>Moments accountant: This technique provides even tighter privacy control, especially for scenarios like machine learning, where many computations need to be performed. It allows the privacy budget to be managed more efficiently.</p></li>
</ul>
<p>In practice, organizations can achieve strong privacy guarantees while still getting useful results. For example, with differential privacy settings such as <span class="math inline">\varepsilon \approx 1</span>; (with <span class="math inline">\delta \approx 10^{-5}</span> in the more general <span class="math inline">(\varepsilon,\delta)</span> definition), the data enjoys strong privacy protection with only a small chance of leakage, and the resulting analysis typically incurs an error in the range of 1–10%—a level generally acceptable for many real-world applications, though the exact tolerance depends on the task.<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a></p>
<div class="no-row-height column-margin column-container"><div id="fn17"><p><sup>17</sup>&nbsp;The parameter <span class="math inline">\delta</span> is used in the more general notion of <span class="math inline">(\varepsilon,\delta)</span>-differential privacy, sometimes called <em>approximate DP</em>. It allows a very small probability (e.g., <span class="math inline">\delta \approx 10^{-5}</span>) that the privacy guarantee might fail. If <span class="math inline">\delta=0</span>, we recover the pure <span class="math inline">\varepsilon</span>-differential privacy definition given above.</p></div></div></section>
<section id="advanced-protocols" class="level5">
<h5 class="anchored" data-anchor-id="advanced-protocols">Advanced protocols</h5>
<p>The combination of HE and DP also enables advanced protocols, such as:</p>
<ul>
<li><p>Private Set Intersection with DP guarantees: Imagine two organizations wanting to compare customer lists without revealing all their data to each other. Private Set Intersection allows them to find common customers while using DP to ensure no extra information is leaked.</p></li>
<li><p>Secure aggregation: Multiple parties can contribute encrypted data, and the aggregate result can be computed without revealing the individual contributions. DP ensures that even if the aggregate result is shared, the privacy of individual contributors is preserved.</p></li>
<li><p>Privacy-preserving machine learning: This approach allows models to be trained using data from different organizations while ensuring data privacy. HE ensures data is never decrypted, while DP guarantees that the trained model does not reveal any individual’s data.</p></li>
</ul>
<p>When implementing these techniques, several practical considerations must be addressed:</p>
<ul>
<li><p>Performance optimization:</p>
<ul>
<li><p>Batching homomorphic operations: Performing many homomorphic operations together can make them more efficient, helping to manage the increased computational cost of using HE.</p></li>
<li><p>Optimizing noise addition: Adding noise carefully helps maintain data utility while preserving privacy.</p></li>
<li><p>Managing computational overhead: HE and DP both introduce computational complexity. Efficiently managing this overhead is critical to make these privacy-preserving techniques practical.</p></li>
</ul></li>
<li><p>Security parameters:</p>
<ul>
<li><p>Key size selection: Choosing the right key size for HE is important. Larger keys provide stronger security but also increase computational cost.</p></li>
<li><p>Noise parameter tuning: DP requires careful tuning of noise parameters to ensure privacy without losing too much accuracy.</p></li>
<li><p>Privacy budget allocation: Allocating the privacy budget effectively helps balance the level of privacy protection with the need for accurate results.</p></li>
</ul></li>
<li><p>Protocol design:</p>
<ul>
<li><p>Communication efficiency: In FL, communication efficiency is crucial since participants need to exchange encrypted model updates.</p></li>
<li><p>Error handling: Noise and ciphertext expansion can introduce errors, which need to be managed to ensure accurate results.</p></li>
<li><p>Protocol composition: Combining different privacy-preserving techniques requires careful protocol design to maintain privacy guarantees throughout complex workflows.</p></li>
</ul></li>
</ul>
<p>These technical foundations enable organizations to implement robust privacy-preserving data operations while maintaining precise control over privacy guarantees and computational efficiency. The framework provides mathematical certainty about privacy protection while enabling valuable data analysis and collaboration.</p>
</section>
<section id="real-world-applications-1" class="level5">
<h5 class="anchored" data-anchor-id="real-world-applications-1">Real-world applications</h5>
<ul>
<li><p>Joint medical research: Multiple hospitals can use HE and DP to collaborate on research involving sensitive patient data, such as detecting trends in rare diseases. Each hospital encrypts its patient records, and encrypted datasets are analyzed together to identify emerging health issues without compromising patient confidentiality. After computation, DP ensures that individual patient contributions are hidden by adding noise to the model updates, ensuring privacy. For example, HE can be used to detect early indicators of a rare genetic disorder by combining encrypted datasets from various hospitals, while DP prevents any single patient’s data from being identified in the final results.</p></li>
<li><p>Corporate surveys: HE can be used to perform privacy-preserving surveys across companies in a specific industry to compare salary ranges or employee satisfaction without sharing individual responses. Each company’s data is encrypted before submission, and the combined analysis reveals industry trends while keeping each company’s data private. DP is used to add noise to the aggregated survey results, ensuring that individual responses cannot be inferred, even if someone tries to analyze the outputs in detail.</p></li>
<li><p>Financial fraud detection consortium: Banks can collaborate to detect fraud patterns by sharing encrypted transaction records. HE allows the encrypted data to be analyzed collectively to identify unusual patterns across multiple institutions. DP is applied to the final aggregated fraud detection results to ensure that no single bank’s customer data can be inferred from the analysis. For instance, encrypted datasets can be used to spot potential fraud schemes involving cross-bank transactions without compromising any bank’s customer data.</p></li>
<li><p>Government resource auctions: Governments can use HE in auctions for spectrum licenses or natural resources. Participants submit their bids in an encrypted form, ensuring that their bidding strategy is kept secret. DP adds an additional layer of privacy by ensuring that even the aggregated bidding data cannot reveal individual bidding strategies. Only the winning bid is revealed at the end, preserving fairness and confidentiality throughout the auction process.</p></li>
<li><p>Collaborative pharmaceutical research: Pharmaceutical companies can collaborate to analyze clinical trial data securely. HE allows them to combine and analyze encrypted datasets from multiple trials, enhancing the ability to identify effective treatments faster. DP adds noise to the outputs, ensuring that the results cannot be traced back to any individual patient in the clinical trials. This helps companies work together on drug development without exposing sensitive patient data.</p></li>
<li><p>Cross-border health data analysis: During public health crises, different countries’ health agencies can use HE to securely share and analyze encrypted health data. For example, during a pandemic, agencies can combine encrypted data on infection rates, hospital capacity, and resources needed. DP ensures that the final combined results maintain privacy, so that individual contributions from specific regions cannot be identified, ensuring coordinated responses while maintaining privacy across borders.</p></li>
<li><p>Collaborative risk assessment for insurance: Insurance companies can share encrypted claims data to develop better risk models that help predict and price insurance products. HE allows insurers to perform calculations on encrypted claims data, and DP adds noise to the resulting models, preventing any individual customer’s claims data from being exposed. For instance, multiple insurers can securely collaborate to build risk prediction models for natural disasters while keeping individual customer claims data confidential.</p></li>
</ul>
</section>
</section>
<section id="private-information-retrieval" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="private-information-retrieval">Private Information Retrieval</h4>
<p>Private Information Retrieval (PIR) is a cryptographic technique that allows a client to retrieve data from a large database held by a server without revealing which specific piece of data is being requested. More formally, PIR ensures that the query sent by the client does not leak any information to the server about the data being retrieved, while still enabling the server to provide the correct response.</p>
<p>PIR is especially useful in situations where privacy is crucial, such as when accessing large public databases or confidential corporate data. It allows users to perform queries without revealing their interests or compromising their privacy. This ensures that sensitive information remains confidential, even when interacting with third-party databases, thereby enhancing both security and user trust.</p>
<p>HE has had a profound impact on the evolution of PIR, particularly by enabling more efficient and practical implementations of single-server PIR schemes. HE allows computation on encrypted data without revealing the underlying plaintext, which means a server can process queries directly on encrypted requests, ensuring that the data and the query both remain confidential. This approach significantly improves the efficiency and security of PIR, as it removes the need for multiple non-colluding servers and allows for privacy-preserving data retrieval with a single server setup.</p>
<p>The integration of HE into PIR protocols leverages its ability to perform arithmetic operations on encrypted data, enabling the server to respond to client queries without ever decrypting them. This not only enhances the privacy guarantees but also makes PIR more scalable and practical in real-world applications. By using HE, single-server PIR implementations can efficiently compute responses to encrypted queries, minimizing computational overhead while maintaining strong privacy protections. In practice, tools like Microsoft’s SEAL library incorporate HE, specifically Ring Learning With Errors (Ring-LWE), to implement these capabilities.</p>
<p>PIR implementations generally follow two main approaches. The first is the Chor-Goldreich-Kushilevitz (CGK)<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> scheme for information-theoretic PIR, which provides unconditional security by distributing the database across multiple non-colluding servers. The second approach uses HE and lattice-based methods for computational PIR, which rely on cryptographic assumptions and typically operate with a single server. These lattice-based approaches leverage mathematical structures called lattices to create secure encryption schemes that allow efficient query processing while maintaining privacy.</p>
<div class="no-row-height column-margin column-container"><div id="fn18"><p><sup>18</sup>&nbsp;The Chor-Goldreich-Kushilevitz (CGK) scheme is an information-theoretic approach to Private Information Retrieval (PIR). It was proposed by researchers Benny Chor, Oded Goldreich, Eyal Kushilevitz, and Madhu Sudan. The CGK scheme ensures that a client can retrieve data from a database without revealing any information about which data is being requested. This method achieves unconditional privacy, meaning the privacy guarantee does not depend on computational assumptions but rather on the architecture of the system. In the CGK scheme, the database is replicated across multiple non-colluding servers. The client sends specially crafted queries to each server, ensuring that no single server learns which data is being retrieved. As long as the servers do not collude with each other, the client’s privacy is preserved. The approach offers perfect privacy, but it requires the assumption that multiple servers are involved and that they do not share information about their interactions with the client. The CGK scheme is significant in scenarios where high privacy guarantees are required, but it comes with the practical limitation of needing multiple non-colluding servers, which may not always be feasible in real-world applications. See: Chor, B., Goldreich, O., Kushilevitz, E., &amp; Sudan, M. (1998). <strong>Private information retrieval</strong>. <em>Journal of the ACM (JACM)</em>, 45(6), 965-981. <a href="https://doi.org/10.1145/293347.293350">DOI</a>.</p></div></div><p>The use of HE has fundamentally transformed single-server PIR, making it a more viable and efficient solution for privacy-preserving data retrieval. This combination of theoretical approaches and practical implementations has made PIR increasingly applicable across a wide range of privacy-sensitive scenarios, including its use in Private Set Intersection (PSI). The significance of HE cannot be overstated, as it not only strengthens privacy guarantees in PIR but also paves the way for other advanced cryptographic constructions, ultimately broadening the scope and utility of secure data retrieval solutions.</p>
<p>One notable example of PIR in action is its integration with Private Set Intersection (PSI)<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>. PSI allows two or more parties to find common elements in their datasets without revealing any additional information beyond the intersection itself. For instance, two companies may wish to identify common customers without sharing their entire customer lists. By leveraging PIR, each party can retrieve information about the intersection privately, ensuring that no non-intersecting data is exposed. This approach is particularly valuable in scenarios where maintaining the confidentiality of the datasets is crucial, such as in healthcare collaborations or financial partnerships.</p>
<div class="no-row-height column-margin column-container"><div id="fn19"><p><sup>19</sup>&nbsp;Freedman, M. J., Nissim, K., &amp; Pinkas, B. (2004). <strong>Efficient private matching and set intersection</strong>. <em>International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT)</em>, 3027, 1-19. <a href="https://doi.org/10.1007/978-3-540-24676-3_1">DOI</a>. This reference covers foundational work on PSI, introducing efficient protocols for private set intersection and private matching.</p></div></div><p>Real-world examples:</p>
<ul>
<li><p>Patent database retrieval: A client can request a specific record from a large patent database without revealing which one they need. The client sends an encrypted index of the record, and the server processes this to return the encrypted result. For example, researchers can use PIR to access specific patents in the US patent database for a project without revealing which patents they are interested in. This ensures that sensitive intellectual property research remains confidential.</p></li>
<li><p>Medical information retrieval: PIR allows a patient to retrieve a specific medical record from a hospital database without the hospital knowing which record was requested. For example, a patient undergoing treatment for a sensitive condition can use PIR to retrieve specific medical records without revealing their interest to the hospital staff, thereby ensuring full confidentiality. This approach is especially beneficial for patients dealing with stigmatized conditions, allowing them to maintain privacy while managing their health.</p></li>
<li><p>Corporate data retrieval: Employees of a company can retrieve records from a confidential database without revealing which record they are looking for. For instance, an employee working on a confidential project could use PIR to access specific internal documents without revealing the nature of their query to the IT team, ensuring that confidential research remains secure. This is particularly important for organizations in competitive industries, where safeguarding project details and proprietary research is essential.</p></li>
<li><p>Academic research collaboration: PIR enables multiple research institutions to collaboratively access sensitive datasets while maintaining the confidentiality of each request. For example, researchers studying sensitive health data across different universities can use PIR to collaborate on a large-scale study while maintaining privacy regarding their specific research interests.</p></li>
<li><p>Customer support information retrieval: Customer service representatives can use PIR to access specific customer records without revealing which record is being accessed to unauthorized personnel. For instance, a representative could retrieve a customer’s previous support history without the support platform’s backend knowing which customer record was accessed. This helps maintain the privacy of sensitive customer information.</p></li>
<li><p>E-commerce product information: PIR allows buyers to access specific product details from a large e-commerce catalog without revealing which product they are interested in. For instance, a user researching a high-value item can retrieve product information without revealing their interest, thereby preventing targeted marketing or price manipulation by the platform.</p></li>
<li><p>Government records access: PIR enables citizens to access certain public records without the government knowing which specific record is being accessed. For example, a journalist researching a sensitive topic can use PIR to access specific government documents without revealing their focus, ensuring freedom of information while maintaining confidentiality.</p></li>
<li><p>Intellectual property research: Legal teams or corporations can search through a database of patents or trademarks without revealing the specific intellectual property they are researching. For instance, during early stages of product development, a company can use PIR to verify patent details without competitors learning about their research interests, thus maintaining strategic confidentiality.</p></li>
<li><p>Human resources record access: HR personnel can access specific employee records without revealing which record they are interested in to other departments or unauthorized personnel. For example, during an internal audit, an HR manager might need to review sensitive records without exposing which employees are being audited, ensuring privacy and avoiding unnecessary speculation.</p></li>
<li><p>Legal document retrieval: Law firms often need to access specific legal documents from a shared database without disclosing which document they are searching for, especially during cases involving multiple parties. For instance, during a merger or acquisition, legal teams can use PIR to access critical contract details without tipping off competing firms about their focus, keeping negotiations confidential.</p></li>
<li><p>Supply chain data access: PIR allows manufacturers to access specific supply chain information from a shared logistics database without revealing their focus to other stakeholders. For example, a car manufacturer may verify part availability without revealing to suppliers which model they are currently prioritizing, thereby maintaining competitive confidentiality.</p></li>
<li><p>Market analysis for financial institutions: Financial analysts may need to retrieve specific market data from a large dataset without revealing which data points they are interested in. By using PIR, analysts can query the database and obtain encrypted results without disclosing their market focus. For example, an investment firm researching emerging markets can access key economic indicators without revealing their specific interests, thereby maintaining a competitive edge.</p></li>
</ul>
</section>
</section>
<section id="beyond-he" class="level3">
<h3 class="anchored" data-anchor-id="beyond-he">Beyond HE</h3>
<p>HE is a powerful tool in cryptography that has the potential to revolutionize data privacy. It allows computations to be carried out on encrypted data without requiring access to the original plaintext. This capability has significant implications for secure data processing, enabling cloud-based services to perform calculations on sensitive information while preserving privacy. However, despite its transformative possibilities, HE comes with several limitations and challenges that must be addressed before it can be widely adopted in practical applications.</p>
<p>Below, we outline some of the challenges and constraints associated with HE, providing a deeper understanding of its current limitations and the efforts needed to overcome them.</p>
<section id="challenges" class="level4">
<h4 class="anchored" data-anchor-id="challenges">Challenges</h4>
<ol type="1">
<li><p>Encrypted output: While HE allows for arbitrary computations on encrypted data, the outcome of these computations is still encrypted. This means that the result is only useful to someone with the secret key to decrypt it. For example, if a cloud server performs a complex computation on encrypted health records, the resulting encrypted output cannot be interpreted without the corresponding decryption key. This presents a challenge for practical implementations, as it requires data owners to perform decryption locally to understand the results. In contrast, other techniques like obfuscation and functional encryption enable certain types of encrypted computations where the output is directly accessible in plaintext. These techniques can be more practical in situations where immediate interpretation of results is required. Another drawback of the encrypted output is the lack of flexibility for collaboration. In many use cases, organizations need to share the results of computations with multiple stakeholders who may not have access to the decryption key. This means that HE, by default, limits the ease of sharing processed information unless additional mechanisms for key distribution are implemented. As a result, using HE often necessitates careful planning around how decryption keys are managed and shared, which can introduce additional security concerns. Managing key distribution securely while ensuring accessibility is an ongoing area of research in the field of cryptography.</p></li>
<li><p>Single key requirement: To perform computations on encrypted data, all inputs must be encrypted using the same key. This constraint limits scenarios where data from multiple sources, encrypted with different keys, needs to be jointly processed. For instance, in a scenario where multiple healthcare providers wish to collaborate on a dataset of encrypted patient records, each provider’s data must be encrypted with the same key for joint analysis to be possible. This presents a significant barrier to collaboration, as coordinating the use of a single encryption key across multiple entities introduces security and logistical challenges. Addressing this limitation often requires the use of advanced key management techniques or trusted intermediaries, which can complicate the overall system architecture. Techniques like SMC can sometimes be used alongside HE to facilitate joint computations without sharing a common key, but these solutions tend to increase computational overhead and complexity. Moreover, the need for a single key also raises concerns about key compromise—if the key is exposed, all encrypted data becomes vulnerable, making key security a critical aspect of using HE in real-world applications. Researchers are actively exploring methods to allow computations on data encrypted with different keys, such as through key homomorphism or the use of proxy re-encryption. These approaches aim to enable interoperability between datasets encrypted with different keys, thereby enhancing the practicality of HE for collaborative applications. However, these methods are still in their experimental stages and are not yet widely adopted in mainstream cryptographic systems.</p></li>
<li><p>No integrity guarantees: HE allows for computations on encrypted data, but it does not provide a mechanism to verify that the computations were performed correctly. In other words, there is no inherent way to confirm if the resulting ciphertext is genuinely the outcome of the intended computation or if it is simply a new encryption of an unrelated value. This lack of integrity verification is a significant limitation, particularly in scenarios where the correctness of the computation is critical, such as financial transactions or medical data analysis. Without integrity guarantees, there is a risk that a malicious server could manipulate the computation process, resulting in incorrect outputs without detection. For instance, if a cloud provider intentionally or unintentionally alters the computation on encrypted financial records, the resulting encrypted output could be incorrect, leading to potential financial losses for the data owner. To address this issue, additional cryptographic tools such as ZKPs can be used in combination with HE to provide assurance that computations were performed correctly. ZKPs allow one party to prove to another that a computation was executed as expected without revealing any information about the input data. By integrating ZKPs with HE, it is possible to create a system where the server can provide verifiable proof that it performed the computation correctly. However, adding ZKPs to the process increases computational complexity and may impact performance, making it important to balance the need for integrity with the computational resources available. Another approach to ensuring the integrity of computations is the use of blockchain technology. By recording the steps of the computation on a blockchain, it is possible to create a transparent and tamper-resistant log that can be audited by all parties involved. This method, while promising, also introduces additional overhead and requires careful consideration of scalability, especially when dealing with large volumes of data.</p></li>
</ol>
</section>
<section id="future-directions" class="level4">
<h4 class="anchored" data-anchor-id="future-directions">Future directions</h4>
<p>In addition to the limitations outlined above, HE faces several other challenges that need to be addressed to make it more practical for widespread use. These challenges include:</p>
<ol type="1">
<li><p>Performance overheads: HE is computationally intensive compared to traditional encryption methods. Performing even basic operations on encrypted data can require significantly more processing power and time. FHE, which supports arbitrary computations, is particularly demanding and often impractical for real-time applications due to its high computational costs. Researchers are working on optimizing FHE schemes to reduce these performance overheads, but significant progress is still needed before they can be used in everyday applications. Advances such as bootstrapping optimizations and hardware acceleration are being explored to mitigate these challenges.</p></li>
<li><p>Large ciphertext sizes: Encrypted data under HE schemes tends to be much larger than the original plaintext data. This increase in data size, known as ciphertext expansion, can lead to storage and bandwidth issues, particularly when dealing with large datasets. For example, encrypting a simple medical record using FHE can result in a ciphertext that is several orders of magnitude larger than the original record. This makes storage and transmission of encrypted data more challenging, especially in environments with limited resources. Researchers are investigating techniques like compression schemes and more efficient ciphertext representations to reduce the overhead associated with HE.</p></li>
<li><p>Complexity of implementation: Implementing HE is complex and requires a deep understanding of advanced mathematics and cryptographic principles. This complexity makes it difficult for developers to integrate HE into their applications without specialized knowledge. To address this barrier, researchers and developers are working on creating libraries and tools that simplify the use of HE, making it more accessible to non-experts. However, there is still a long way to go before these tools are as user-friendly as traditional encryption libraries. Efforts like Microsoft SEAL, PALISADE, and other open-source libraries are helping bridge this gap, but more work is needed to make HE adoption mainstream.</p></li>
<li><p>Lack of standardization: Another challenge with HE is the lack of standardization across different implementations. Currently, there are multiple HE schemes, each with its unique properties, trade-offs, and performance characteristics. This fragmentation makes it difficult for developers and organizations to choose the right scheme for their needs and complicates interoperability between systems using different HE protocols. Ongoing efforts by organizations such as the HomomorphicEncryption.org community aim to create standardized benchmarks and guidelines to help users navigate the complexities of HE and choose the most suitable options for their use cases.</p></li>
<li><p>Key management and distribution: The effective management of encryption keys is a critical factor in ensuring the security of HE systems. As discussed earlier, HE often requires a single key to encrypt all data inputs, making key distribution a complex challenge, particularly in collaborative environments. If the key is compromised, all encrypted data becomes vulnerable. Key rotation mechanisms, secure key storage solutions, and the development of multi-key HE are all areas of active research to address these key management challenges. Proxy re-encryption and distributed key generation are also being explored as potential solutions to facilitate secure key sharing across different entities without compromising security.</p></li>
<li><p>Scalability issues: HE can be difficult to scale, especially for applications requiring large-scale data processing, such as big data analytics or machine learning. The computational overhead and increased data sizes make scaling HE to handle vast amounts of information a considerable challenge. Researchers are exploring the use of hybrid cryptographic solutions, where HE is combined with other privacy-preserving techniques like DP and SMC, to achieve a balance between scalability and privacy. These hybrid approaches can potentially make HE more viable for large-scale, real-time applications by distributing the computational burden and reducing latency.</p></li>
</ol>
</section>
</section>
</section>
<section id="foundations-of-he" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="foundations-of-he">Foundations of HE</h2>
<p>Having explored the high-level benefits and use cases of HE, from cloud-based analytics to privacy-preserving computations, we now turn to the mathematical underpinnings that make these capabilities possible. In the sections ahead, we’ll look at the abstract algebra concepts that allow encrypted values to behave almost like ordinary data, so that addition, multiplication, and even more complex operations can be carried out securely.</p>
<p>We’ll begin by examining homomorphisms, the structural <em>translations</em> that keep arithmetic consistent between plaintext and ciphertext. Next, we’ll see how groups, rings, and fields fit into HE, and why functional completeness—the ability to both add and multiply encrypted data—is a cornerstone of fully homomorphic schemes. Finally, we’ll dissect the main building blocks of a typical HE setup (KeyGen, Enc, Dec, and Eval) and learn how noise management, parameter selection, and other technical considerations come together to deliver robust security without sacrificing too much performance. By grounding ourselves in these foundational concepts, we’ll gain a clearer sense of how HE works, equipping us to better understand why it is so transformative for secure data processing.</p>
<section id="homomorphisms" class="level3">
<h3 class="anchored" data-anchor-id="homomorphisms">Homomorphisms</h3>
<p>Homomorphisms are an important concept in abstract algebra, referring to a function between two algebraic structures that preserves the operations of those structures. Simply put, if we have two sets, each with their own operations, a homomorphism ensures that operations performed on elements of the first set correspond directly to the operations on their mapped elements in the second set.</p>
<p>Let’s break this down with a simple analogy. Imagine we have two different languages, but both languages describe similar actions. A homomorphism is like a translation between these languages that ensures the meaning of sentences is preserved. If you take an action in the first language, the translation will represent the same action in the second language. The structure remains consistent.</p>
<p>Consider two sets of numbers, <span class="math inline">A</span> and <span class="math inline">B</span>, where <span class="math inline">B</span> is derived from <span class="math inline">A</span> using a homomorphism function. If we take two numbers, <span class="math inline">3</span> and <span class="math inline">5</span>, from <span class="math inline">A</span> and add them to get <span class="math inline">8</span>, the homomorphism ensures that their images in <span class="math inline">B</span>, <span class="math inline">6</span> and <span class="math inline">10</span>, also add up to give the corresponding result, which is <span class="math inline">16</span>.</p>
<p>In formal terms, let <span class="math inline">A</span> be represented by elements <span class="math inline">a_1, a_2 \in A</span>, and <span class="math inline">B</span> by their corresponding images under the homomorphism <span class="math inline">f: A \to B</span>. If <span class="math inline">a_1 = 3</span> and <span class="math inline">a_2 = 5</span>, then:</p>
<p><span class="math display">
a_1 + a_2 = 8
</span></p>
<p>Applying the homomorphism <span class="math inline">f</span>:</p>
<p><span class="math display">
f(a_1) = 6, \quad f(a_2) = 10
</span></p>
<p>Thus:</p>
<p><span class="math display">
f(a_1 + a_2) = f(a_1) + f(a_2) = 6 + 10 = 16
</span></p>
<p>This demonstrates how the homomorphism preserves the operation between the sets.</p>
</section>
<section id="he-scheme" class="level3">
<h3 class="anchored" data-anchor-id="he-scheme">HE scheme</h3>
<p>An encryption scheme is called <strong>homomorphic</strong> over an operation <span class="math inline">\star</span> if it supports the following property:</p>
<p><span class="math display">
Enc(m_1) \star Enc(m_2) = Enc(m_1 \star m_2), \quad \forall m_1, m_2 \in M
</span></p>
<p>where <span class="math inline">Enc</span> is the encryption algorithm, and <span class="math inline">M</span> is the set of all possible messages. This property means that performing the operation on encrypted data yields the same result as performing the operation on the plaintexts and then encrypting the outcome.</p>
<p>Let’s make this more concrete with a simple example. Suppose we have two numbers, <span class="math inline">m_1 = 5</span> and <span class="math inline">m_2 = 3</span>, and we want to add them, that is <span class="math inline">\star</span> represents addition. Normally, we would calculate <span class="math inline">5 + 3 = 8</span>. In a HE scheme, instead of adding <span class="math inline">5</span> and <span class="math inline">3</span> directly, we first encrypt them:</p>
<p><span class="math display">
Enc(5), \quad Enc(3)
</span></p>
<p>If the encryption scheme is homomorphic over addition, we can add these encrypted values directly:</p>
<p><span class="math display">
Enc(5) + Enc(3) = Enc(8)
</span></p>
<p>After computing on the encrypted values, we can decrypt the result to get the sum:</p>
<p><span class="math display">
Dec(Enc(8)) = 8
</span></p>
</section>
<section id="functional-completeness" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="functional-completeness">Functional completeness</h3>
<p>Imagine you have a secret message inside a locked box, and you want someone else to be able to perform some calculations on it without unlocking the box. HE allows this kind of magic. But how much can they really do with the box still locked?</p>
<p>Functional completeness is a fancy way of saying that if we can perform just two basic kinds of calculations on our locked message, then we can actually compute <em>anything</em>. These two basic calculations are <strong>addition</strong> and <strong>multiplication</strong>.</p>
<p>Think of these as building blocks, like Lego pieces. With just addition and multiplication, you can build any mathematical function you want. It’s a bit like how you only need a few types of Lego pieces to build a spaceship, a car, or even a whole castle. Addition and multiplication are enough to recreate every possible calculation.</p>
<p>In fact, even in the world of computers and logic, every complicated decision or process can be broken down into combinations of simpler pieces. For example, <strong>XOR</strong> (which acts like addition without carrying over numbers) and <strong>AND</strong> (which acts like multiplication) are the Lego pieces of digital logic. If an encryption system allows you to perform these two operations, you can calculate any kind of logical operation on encrypted data—without ever seeing the original secret message.</p>
<p>It is also worth noting that <strong>NAND</strong> or <strong>NOR</strong> gates alone can form a complete basis for Boolean logic. This means that, just like addition and multiplication, NAND or NOR are also sufficient to represent any Boolean function. This is an interesting parallel to the completeness of addition and multiplication in HE.</p>
<p>This is why addition and multiplication are so powerful. They are enough to make the encryption scheme fully homomorphic, meaning it can perform <em>any</em> kind of computation on encrypted data, keeping the secrets locked up but still allowing useful work to be done. In simple terms, if you can add and multiply, you can do it all!</p>
<section id="formal-definition" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="formal-definition">Formal definition</h4>
<p>To formally understand functional completeness in HE, it’s important to start with the algebraic foundations. So, let’s come back to the definition of homomorphism as a structure-preserving map between two algebraic structures, such as groups, rings, or fields. This means that the operations defined in one structure are preserved under the mapping to the other structure. In the context of HE, the homomorphism property allows operations to be carried out on encrypted data that mirror operations on the plaintext.</p>
<p><strong>Group</strong> is a set equipped with an operation that satisfies closure, associativity, has an identity element, and where every element has an inverse. When we extend these properties to include additional operations like multiplication, we get rings and fields, which have more complex properties. In a <strong>ring</strong>, both addition and multiplication are defined, but not every element necessarily has a multiplicative inverse. In a <strong>field</strong>, every non-zero element has a multiplicative inverse, making it a richer structure.</p>
<p>In HE, we work with these algebraic structures because they provide the foundation for well-defined operations on encrypted data. The key operations, namely addition and multiplication, are defined over these structures in a way that ensures they behave predictably and securely. When we say that an encryption scheme is homomorphic, we mean that it allows addition and multiplication to be performed on encrypted values, and the result, when decrypted, matches what would have been obtained if the operations were performed directly on the plaintext values.</p>
<p>Functional completeness, in this context, means that an encryption scheme can support arbitrary computations on encrypted data as long as it allows both addition and multiplication. With these two operations, we can construct polynomial functions of any form, and polynomial functions are sufficient to represent any arithmetic circuit. This is directly analogous to Boolean logic, where simple gates such as NAND or NOR are functionally complete because they can be combined to express any Boolean function.</p>
<p>In practice, digital computation takes place in finite rings and fields (e.g., <span class="math inline">\mathbb{Z}_q</span>, GF(2)<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>), where closure and bounded representation are guaranteed. This modular arithmetic setting is exactly why modern homomorphic encryption schemes are built over polynomial rings with coefficients reduced modulo <span class="math inline">q</span>. By contrast, in continuous domains such as the real numbers, approximation theory, most notably the Stone–Weierstrass theorem<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a>, shows that polynomials can approximate arbitrary continuous functions to any degree of accuracy. The discrete and continuous cases differ in detail, but both reinforce the universality of addition and multiplication as building blocks of computation.</p>
<div class="no-row-height column-margin column-container"><div id="fn20"><p><sup>20</sup>&nbsp;GF(2), or Galois Field of order 2, is a finite field consisting of just two elements: usually represented as 0 and 1. See: van Lint, J. H., &amp; Wilson, R. M. (2001). <strong>A Course in Combinatorics</strong> (2nd ed.). Cambridge University Press. <a href="https://doi.org/10.1017/CBO9780511987045">DOI</a></p></div><div id="fn21"><p><sup>21</sup>&nbsp;Rudin, W. (1976). <strong>Principles of Mathematical Analysis</strong> (3rd ed.). McGraw-Hill. ISBN: 978-0070856134</p></div></div><p>To connect this to earlier discussion, consider Boolean circuits: these are models of computation where gates such as XOR and AND serve as the basic primitives. XOR and AND form a functionally complete set for Boolean functions, meaning any logical operation can be expressed in terms of them. This should not be confused with Turing completeness, which requires unbounded memory and control flow. Similarly, in arithmetic circuits, addition and multiplication suffice to construct any polynomial, which in turn can represent arbitrarily complex arithmetic processes. In the context of homomorphic encryption, this completeness ensures that by chaining homomorphic additions and multiplications, we can evaluate arbitrary functions on encrypted data while preserving privacy.</p>
<p>In HE, an encryption scheme is said to be <strong>fully homomorphic</strong> if it supports both addition and multiplication on encrypted data, without needing to decrypt it. This property allows for the evaluation of any arithmetic circuit or Boolean circuit on encrypted data, effectively enabling arbitrary computation while preserving the confidentiality of the original data.</p>
<p>For instance, in the context of Boolean logic, XOR can be represented by addition (without carry), and AND can be represented by multiplication. These two gates are sufficient to build any Boolean function, making them functionally complete. Therefore, an encryption scheme that supports homomorphic addition and multiplication can evaluate any Boolean function, making it a FHE scheme.</p>
</section>
<section id="relevance-in-he" class="level4">
<h4 class="anchored" data-anchor-id="relevance-in-he">Relevance in HE</h4>
<p>The concept of functional completeness is crucial because it determines the power and flexibility of a HE scheme. If an encryption scheme can only support addition or only multiplication, it is called <strong>PHE</strong>. Such schemes can perform useful but limited computations, like adding encrypted numbers together or multiplying them by a constant. However, they cannot handle more complex functions that require a combination of both operations.</p>
<p>Examples of partially HE schemes include <strong>RSA</strong>, which is <strong>multiplicatively homomorphic</strong>, and <strong>Paillier</strong>, which is <strong>additively homomorphic</strong>. These schemes allow for specific types of computations on encrypted data but lack the flexibility of fully HE.</p>
<p>A <strong>FHE</strong> scheme, on the other hand, allows for arbitrary computations on encrypted data. This means that any function, no matter how complex, can be evaluated while the data remains encrypted.</p>
</section>
</section>
<section id="symmetric-vs.-asymmetric-he" class="level3">
<h3 class="anchored" data-anchor-id="symmetric-vs.-asymmetric-he">Symmetric vs.&nbsp;asymmetric HE</h3>
<p>HE schemes can be broadly categorized into <strong>symmetric</strong> and <strong>asymmetric</strong> types, each with unique characteristics and use cases. Symmetric HE uses the same key for both encryption and decryption, while asymmetric HE uses different keys for encryption and decryption.</p>
<section id="symmetric-he" class="level4">
<h4 class="anchored" data-anchor-id="symmetric-he">Symmetric HE</h4>
<p>In symmetric HE, the same secret key is used for both encryption and decryption.&nbsp;This approach is often simpler to implement and is computationally efficient compared to asymmetric schemes.&nbsp;Imagine you and your friend have the same combination lock. You can lock up a message, and your friend can unlock it using the same combination. In symmetric HE, the same secret key is used to lock (encrypt) and unlock (decrypt) the data, even when performing computations.</p>
<p>Symmetric HE schemes are generally faster and require less computational power than asymmetric ones. This is because symmetric algorithms tend to have simpler key structures, leading to more efficient operations.&nbsp;The key size in symmetric HE schemes can be smaller while maintaining an equivalent level of security compared to asymmetric systems.</p>
<p>One of the primary challenges of symmetric HE is key management. If multiple users need access to the encrypted data, the secret key must be shared securely, which can be challenging, especially in distributed environments.&nbsp;In multi-user scenarios, symmetric encryption poses a security risk since all parties must share the same key. If any user mishandles the key, the entire system’s security is compromised.</p>
<p>Symmetric HE is most suitable for use cases where there is a trusted environment, such as a single user encrypting their own data for secure local processing or a tightly controlled group where the key can be securely shared.</p>
</section>
<section id="asymmetric-he" class="level4">
<h4 class="anchored" data-anchor-id="asymmetric-he">Asymmetric HE</h4>
<p>Asymmetric HE schemes utilize a pair of keys: a <strong>public key</strong> for encryption and a <strong>private key</strong> for decryption. The public key can be shared openly, allowing anyone to encrypt data, but only the holder of the corresponding private key can decrypt it.&nbsp;Imagine you have a special mailbox with a slot that anyone can drop letters into (public key) but only you have the key to open the mailbox and read the letters (private key). Asymmetric HE works similarly, allowing anyone to encrypt data, but only the intended recipient can decrypt it.</p>
<p>Asymmetric HE schemes are generally more computationally intensive than symmetric ones. The key structures and encryption/decryption algorithms tend to be more complex, leading to slower performance.&nbsp;To achieve a similar level of security, asymmetric keys need to be larger compared to symmetric keys, which can increase storage and processing requirements.</p>
<p>Asymmetric HE is ideal for scenarios involving multiple users, such as cloud computing, where data needs to be encrypted by many users but only decrypted by a trusted party. The use of a public key enables easy data sharing without compromising the security of the private key.&nbsp;Since the public key is openly distributed, any number of users can encrypt data, making asymmetric HE more scalable for environments involving many participants.</p>
</section>
</section>
<section id="key-components-of-an-he-scheme" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="key-components-of-an-he-scheme">Key components of an HE scheme</h3>
<p>An HE scheme is fundamentally characterized by four essential operations: <span class="math inline">KeyGen</span>, <span class="math inline">Enc</span>, <span class="math inline">Dec</span>, and <span class="math inline">Eval</span>. These components work together to enable secure computation on encrypted data while maintaining the critical property of homomorphism. Let’s explore each component in detail and understand their mathematical foundations, practical implications, and the subtle nuances involved.</p>
<p>The four core components that make HE functional are discussed in detail below:</p>
<ul>
<li><p>The <span class="math inline">KeyGen</span> algorithm is the foundation of any HE scheme’s security. It generates the cryptographic keys necessary for the system’s operation.</p>
<p>Imagine that <span class="math inline">KeyGen</span> is like creating a secure lock and key for a treasure chest. If the lock is too simple, it might be easy for a thief to pick it, compromising the security of the chest. On the other hand, if the lock is extremely complex, it might take a very long time to make and might even be difficult for the rightful owner to use efficiently. In HE, <span class="math inline">KeyGen</span> works in a similar way: it needs to create a key that is strong enough to keep attackers out but also practical enough for users to operate. The security parameter <span class="math inline">\lambda</span> is like deciding how sophisticated the lock should be, higher values make it harder for unauthorized access but require more effort and resources to manage.</p>
<ul>
<li><p>For symmetric HE: <span class="math inline">k \leftarrow KeyGen(1^\lambda)</span>, where <span class="math inline">\lambda</span> is the security parameter, and <span class="math inline">k</span> is the secret key.</p></li>
<li><p>For asymmetric HE: <span class="math inline">(pk, sk) \leftarrow KeyGen(1^\lambda)</span>, where <span class="math inline">pk</span> is the public key and <span class="math inline">sk</span> is the secret key. The security parameter <span class="math inline">\lambda</span> determines the computational hardness of breaking the encryption scheme. Larger values of <span class="math inline">\lambda</span> provide stronger security but increase computational overhead. The key generation process typically involves:</p>
<ul>
<li><p>Generation of random numbers: Random numbers are generated from a specified distribution, such as uniform, Gaussian, or discrete Gaussian distributions. For example, uniform distributions ensure equal likelihood across a range, while Gaussian distributions are used to introduce controlled randomness with a specific mean and standard deviation. Discrete Gaussian distributions, commonly foundational in HE, particularly in lattice-based cryptography, add noise with precision suitable for cryptographic operations. The randomness is crucial for ensuring that every generated key is unique and unpredictable.</p></li>
<li><p>Mathematical operations: Complex mathematical operations are used based on the scheme’s underlying hardness assumptions. For example, mathematical frameworks in HE, such as Ring-LWE (Learning With Errors) and NTRU (Nth degree Truncated Polynomial Ring) are foundational in HE. These frameworks define problems that are computationally infeasible to solve without specific secret information (such as the private or secret key generated during the <span class="math inline">KeyGen</span> phase), ensuring the security of the encryption scheme. These assumptions make it computationally infeasible for an attacker to derive the private key from the public key or ciphertexts, as they are based on the hardness of specific mathematical problems (e.g., Ring-LWE or NTRU). These problems require secret information, such as the private or secret key generated during the <span class="math inline">KeyGen</span> phase, to be solvable within a practical timeframe.</p></li>
<li><p>Parameter generation: Generation of additional parameters is often required for homomorphic evaluation, such as relinearization keys in some schemes. These parameters help to maintain efficiency and support specific operations like multiplication without a significant increase in ciphertext size. Relinearization keys simplify the increased complexity that occurs after a ciphertext multiplication by “recompressing” the resulting ciphertext into a manageable size and form, ensuring efficient further computations. Without these keys, ciphertexts could grow exponentially, making further evaluations impractical.</p></li>
</ul></li>
</ul>
<p>The robustness of the <span class="math inline">KeyGen</span> function directly impacts the overall security of the HE scheme. It must ensure that the generated keys meet the desired security standards while balancing the computational resources required for efficient operation.</p></li>
<li><p>The <span class="math inline">Enc</span> encryption function transforms plaintext messages into ciphertexts. In HE schemes, this process must preserve the algebraic structure that enables homomorphic operations:</p>
<ul>
<li><p>For symmetric HE: <span class="math inline">c \leftarrow Enc(k, m)</span>, where <span class="math inline">m</span> is the plaintext message, <span class="math inline">k</span> is the secret key, and <span class="math inline">c</span> is the resulting ciphertext.</p></li>
<li><p>For asymmetric HE: <span class="math inline">c \leftarrow Enc(pk, m)</span>, where <span class="math inline">pk</span> is the public key.</p></li>
</ul>
<p>Key characteristics of the encryption process include:</p>
<ul>
<li><p>Addition of random noise: The encryption process introduces random noise into the plaintext to ensure semantic security, making it computationally difficult for an adversary to distinguish between different ciphertexts. While this noise is critical for maintaining security, it must be carefully controlled to avoid excessive growth that can disrupt subsequent computations. Effective noise management ensures that the ciphertext remains usable for homomorphic operations without compromising security.</p></li>
<li><p>Message embedding: The message is embedded into a structured mathematical framework, such as polynomial rings<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a> or lattice-based constructions. This embedding serves two purposes: first, to secure the message against unauthorized access, and second, to enable efficient computations on encrypted data. By embedding the message in a way that retains the necessary algebraic properties, the encryption scheme supports operations like addition and multiplication directly on ciphertexts.</p></li>
</ul>
<p>The encryption step is not just about securing the data but also ensuring that the encrypted data can still participate in meaningful computations. This dual requirement makes HE distinct from conventional encryption methods.</p></li>
</ul>
<div class="no-row-height column-margin column-container"><div id="fn22"><p><sup>22</sup>&nbsp;A <em>polynomial ring</em> is an algebraic structure where the elements are polynomials, and it is closed under addition and multiplication. This means that adding or multiplying two polynomials within the ring always results in another polynomial within the same ring, making it an ideal framework for cryptographic operations like those leveraged in HE.</p></div></div><ul>
<li><p>The <span class="math inline">Dec</span> decryption function recovers the original plaintext from the ciphertext:</p>
<ul>
<li><p>For symmetric HE: <span class="math inline">m \leftarrow Dec(k, c)</span>.</p></li>
<li><p>For asymmetric HE: <span class="math inline">m \leftarrow Dec(sk, c)</span>.</p></li>
</ul>
<p>Critical aspects of the decryption process include:</p>
<ul>
<li><p>Noise removal: Decryption involves removing the noise added during encryption. This is achieved by leveraging the secret key or decryption algorithm to isolate the original message from the noisy ciphertext. Noise levels must remain below a threshold defined by the scheme’s parameters; otherwise, the decryption process may fail, yielding incorrect results. Techniques like modulus alignment<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a> or parameter scaling<a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a> are often used to ensure the noise is adequately suppressed during decryption.</p></li>
<li><p>Extraction from mathematical structure: The message is extracted from its embedded mathematical structure. This involves interpreting the ciphertext within the mathematical framework it was transformed into during encryption (e.g., polynomial rings or lattice structures). Decryption uses the secret key to reverse this transformation by applying the inverse operations in the specified algebraic domain. This process isolates the plaintext while ensuring that noise and other artifacts are accounted for, reconstructing the original message accurately.</p></li>
<li><p>Error handling: Error handling is crucial for situations where noise growth has exceeded acceptable bounds. When the noise level is too high, the decryption process may fail, indicating that the homomorphic operations performed exceeded the scheme’s limitations.</p></li>
<li><p>Integrity verification: Decryption must ensure that the recovered message is the exact original plaintext without any alterations. This process involves verifying the correctness of the decryption by checking the consistency of the output with the encryption parameters and the intended operations performed during evaluation. Integrity verification is essential to detect and prevent errors introduced during encryption, evaluation, or decryption. This may include confirming that noise levels remained within permissible thresholds and that no tampering or corruption of ciphertext occurred throughout the process.</p></li>
</ul>
<p>The computational efficiency and correctness of the decryption process are vital for the practical usability of an HE scheme. It must accurately recover the plaintext without compromising security.</p></li>
</ul>
<div class="no-row-height column-margin column-container"><div id="fn23"><p><sup>23</sup>&nbsp;The <em>modulus</em> serves as the upper limit for the arithmetic space within which operations are performed. When ciphertexts undergo operations like addition or multiplication, their noise increases, and the resulting values may exceed the modulus. Modulus alignment scales the ciphertext back to a compatible modulus, ensuring that it remains within the arithmetic boundaries required by the HE scheme and enabling accurate decryption.</p></div><div id="fn24"><p><sup>24</sup>&nbsp;<em>Parameter scaling</em> involves adjusting specific parameters, such as scaling factors or precision levels. For example, plaintexts are often scaled (multiplied) by a large constant before encryption to ensure sufficient precision during operations. This scaling factor helps maintain accuracy when performing computations on ciphertexts. However, if not properly adjusted, it can lead to noise accumulation or overflow errors.</p></div></div><ul>
<li><p>The <span class="math inline">Eval</span> evaluation function is the distinguishing feature of HE, enabling computation on encrypted data. For a function <span class="math inline">f</span> and ciphertexts <span class="math inline">c_1, c_2, \dots, c_n</span>:</p>
<p><span class="math display">
c_{result} \leftarrow Eval(eval\_key, f, c_1, \dots, c_n)
</span></p>
<p>The <span class="math inline">Eval</span> function must satisfy the homomorphic property:</p>
<p><span class="math display">
Dec(sk, Eval(eval\_key, f, c_1, \dots, c_n)) = f(Dec(sk, c_1), \dots, Dec(sk, c_n))
</span></p>
<p>In simple terms, the equation says that if you evaluate a function on encrypted data, then decrypt the result, you will get the same outcome as if you had evaluated the function directly on the unencrypted data. Terms explanation:</p>
<ul>
<li><p><span class="math inline">Eval(eval\_key, f, c_1, \dots, c_n)</span> represents applying the function <span class="math inline">f</span> to the encrypted values (ciphertexts) <span class="math inline">c_1, c_2, \dots, c_n</span> using an evaluation key.</p></li>
<li><p><span class="math inline">Dec(sk, Eval(...))</span> means that you decrypt the output of this evaluated ciphertext using the secret key <span class="math inline">sk</span>.</p></li>
<li><p><span class="math inline">f(Dec(sk, c_1), \dots, Dec(sk, c_n))</span> represents applying the function <span class="math inline">f</span> to the original plaintext values that were encrypted.</p></li>
</ul>
<p>Key considerations for the evaluation function include:</p>
<ol type="1">
<li><p>Correctness: The evaluation must preserve the relationship between the function applied to plaintexts and the function applied to ciphertexts (here, <span class="math inline">\boxplus</span> and <span class="math inline">\boxdot</span> represent homomorphic addition and multiplication operations):</p>
<ul>
<li><p>For addition: <span class="math inline">Dec(c_1 \boxplus c_2) = Dec(c_1) + Dec(c_2)</span>.</p></li>
<li><p>For multiplication: <span class="math inline">Dec(c_1 \boxdot c_2) = Dec(c_1) \times Dec(c_2)</span>.</p></li>
</ul></li>
<li><p>Noise management: Each homomorphic operation increases the noise level in the ciphertext due to the mathematical transformations applied during evaluation. Noise control is essential to ensure that computations remain accurate and ciphertexts decrypt correctly. Techniques like modulus switching and bootstrapping are employed to manage noise. Modulus switching reduces noise by scaling down ciphertexts to a smaller modulus, aligning them with parameters such as the scaling factor, which determines how plaintexts are encoded into ciphertexts. Bootstrapping, on the other hand, resets the noise entirely by re-encrypting the ciphertext and refreshing its parameters, such as the modulus. These approaches ensure that noise levels remain within tolerable limits, enabling accurate decryption and supporting further computations. In particular:</p>
<ul>
<li><p>Addition operations: During addition, the noise levels from the input ciphertexts combine, leading to a linear increase in noise. Modulus switching can be used here to prevent the combined noise from exceeding tolerable limits, ensuring that further operations can still be performed without requiring bootstrapping.</p></li>
<li><p>Multiplication operations: Multiplication causes a more significant challenge due to exponential noise growth. This is because the interaction of ciphertext terms amplifies the noise and can quickly surpass the allowable threshold. Bootstrapping is particularly crucial in these cases to reset noise levels after one or more multiplications, enabling further computations without risking decryption failure.</p></li>
</ul></li>
<li><p>Ciphertext format preservation: The output ciphertext must maintain a consistent format to support further homomorphic computations without interruptions. Ensuring that the ciphertext remains in a format compatible with the scheme’s parameters prevents issues in subsequent operations, including decryption at the end of the computation process. To achieve this:</p></li>
</ol>
<ul>
<li><p>To support further operations, the ciphertext’s structure must remain aligned with the homomorphic scheme’s requirements. Techniques like modulus switching or parameter adjustments during evaluation help preserve this format, enabling seamless execution of complex computations.</p></li>
<li><p>Proper size management is also crucial to maintain efficiency. Modulus switching not only helps align the ciphertext’s format but also prevents excessive size growth. Without such controls, ciphertext expansion can render the scheme impractical for real-world applications.</p></li>
</ul>
<ol start="4" type="1">
<li><p>Performance considerations: Efficient evaluation requires careful attention to several performance-related factors. These considerations ensure the scheme remains practical for real-world applications while balancing computational overhead and security.</p>
<ul>
<li><p>Circuit depth optimization: In leveled HE schemes, the number of operations is limited by the depth of the computational circuit. Reducing circuit depth minimizes noise growth and improves efficiency. Techniques such as modulus switching (introduced earlier) and parameter optimization are often used to manage this depth effectively, ensuring operations stay within the allowed limits.</p></li>
<li><p>Memory management: Homomorphic operations often result in ciphertext expansion, where the size of ciphertexts increases with each operation. This can lead to significant memory demands, especially when working with large datasets or deep circuits. Efficient memory management strategies, such as controlling ciphertext growth through size management techniques (e.g., modulus alignment), are crucial to maintaining performance.</p></li>
<li><p>Computational complexity: Different homomorphic operations have varying computational costs. Addition is computationally inexpensive and introduces manageable noise, while multiplication is more resource-intensive and causes exponential noise growth. Techniques like bootstrapping, already seen, play a key role in managing this complexity by resetting noise levels and enabling further computations.</p></li>
</ul></li>
<li><p>Special evaluation keys: They play a crucial role in extending the functionality of HE schemes by enabling specific operations and improving efficiency during evaluation. These keys are generated during the <span class="math inline">KeyGen</span> phase and are used as follows:</p>
<ul>
<li><p>Relinearization keys: After multiplication, the resulting ciphertext may have increased complexity. Relinearization keys are used to simplify the ciphertext, making it more manageable for subsequent operations.</p></li>
<li><p>Rotation keys: These keys enable operations that involve rotating encrypted vectors, which are essential in applications like matrix multiplication or encrypted machine learning. They facilitate secure transformations within encrypted data while preserving homomorphic properties.</p></li>
<li><p>Bootstrapping keys: In FHE schemes, bootstrapping keys are indispensable for managing noise. They refresh noisy ciphertexts by re-encrypting them, resetting noise levels, and allowing unlimited operations without risking decryption failure.</p></li>
</ul></li>
</ol>
<p>The evaluation function is what sets HE apart from traditional encryption schemes. It allows encrypted data to be processed without compromising security, making it highly suitable for scenarios where data privacy is critical. In practice, there may be many different computations required, which means multiple <span class="math inline">Eval</span> operations might be needed. Each <span class="math inline">Eval</span> operation allows a specific computation to be performed on the encrypted data, such as addition, multiplication, or other custom functions, without revealing the underlying data. Additionally, <span class="math inline">Eval</span> operations can be composed, meaning that the result of one evaluation can be used as input for another.</p></li>
</ul>
<section id="security-and-functionality-properties" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="security-and-functionality-properties">Security and functionality properties</h4>
<p>The interaction between these components must satisfy several security and functionality properties:</p>
<ul>
<li><p>Semantic security: The encryption process (<span class="math inline">Enc</span>) ensures that ciphertexts reveal no information about the plaintexts, even if intercepted by an adversary. This is achieved through the addition of random noise during <span class="math inline">Enc</span>, which obfuscates the relationship between the plaintext and ciphertext. The security of semantic encryption relies on hardness assumptions such as Ring-LWE or NTRU, ensuring that decryption without the secret key is computationally infeasible.</p></li>
<li><p>Compactness: In the evaluation process (<span class="math inline">Eval</span>), the size of ciphertexts should remain independent of the complexity of the function <span class="math inline">f</span>. Techniques like modulus switching and relinearization, introduced during evaluation, ensure compactness by controlling ciphertext growth and preserving efficiency. Without these techniques, ciphertexts could grow exponentially, rendering the scheme impractical.</p></li>
<li><p>Circuit privacy: To preserve the confidentiality of the computation, the evaluated ciphertext must not reveal information about the function <span class="math inline">f</span> applied during <span class="math inline">Eval</span>. Bootstrapping and parameter adjustments obscure the internal operations, ensuring that proprietary algorithms or sensitive computations remain private.</p></li>
<li><p>Noise growth bounds: Every homomorphic operation increases noise in ciphertexts. Noise management techniques, such as modulus switching and bootstrapping, introduced in <span class="math inline">Eval</span>, provide clear bounds on noise growth. These bounds define the maximum circuit depth that can be evaluated before decryption becomes unreliable. Effective noise control is vital for ensuring that computations on ciphertexts can be completed successfully.</p></li>
<li><p>Efficiency: The efficiency of HE schemes depends on balancing computational overhead, noise management, and security. Operations like addition, which introduce linear noise, are computationally inexpensive. However, multiplication, which introduces exponential noise, requires careful management through relinearization and bootstrapping. The choice of parameters during <span class="math inline">KeyGen</span>, such as key length and modulus size<a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a>, directly impacts the trade-offs between efficiency and security.</p></li>
</ul>
<div class="no-row-height column-margin column-container"><div id="fn25"><p><sup>25</sup>&nbsp;In HE schemes, modulus size and key length are essential cryptographic parameters and FHE and SWHE schemes rely heavily on them. <em>Modulus size</em>, which refers to the number size used in modular arithmetic, impacts both security and computational overhead—larger sizes increase security but require more processing power. <em>Key length</em>, typically measured in bits, determines the strength of encryption; longer keys offer higher security by increasing the complexity of brute-force attacks. These parameters are carefully selected to balance security, performance, and the computational depth of operations, especially in FHE schemes where extensive computations on encrypted data are possible.</p></div></div><p>Understanding these components and their properties is crucial for leveraging HE effectively in theory and practice. These considerations highlight the interplay between the core HE operations and their implications:</p>
<ul>
<li><p>Implementing HE schemes correctly: Each operation, from key generation (<span class="math inline">KeyGen</span>) to evaluation (<span class="math inline">Eval</span>), requires careful implementation to maintain the scheme’s homomorphic properties. For instance, noise management techniques like modulus switching and bootstrapping must be integrated seamlessly to ensure the scheme’s reliability.</p></li>
<li><p>Choosing appropriate parameters: Selecting suitable parameters—such as key length, modulus size, and noise bounds—is vital for balancing security and efficiency. These parameters, determined during the <span class="math inline">KeyGen</span> phase, dictate the computational depth, noise tolerance, and performance of the scheme.</p></li>
<li><p>Optimizing performance: Real-world applications demand efficiency. Optimizing the encryption (<span class="math inline">Enc</span>), evaluation (<span class="math inline">Eval</span>), and decryption (<span class="math inline">Dec</span>) processes ensures the scheme remains practical. Techniques like relinearization keys and circuit depth optimization are indispensable for achieving computational feasibility.</p></li>
<li><p>Ensuring security guarantees: Security guarantees like semantic security, circuit privacy, and integrity verification must hold throughout the computation. This requires consistent adherence to the principles of noise management and compactness during every stage of the HE workflow.</p></li>
<li><p>Designing efficient protocols: HE enables secure protocols by leveraging its unique properties. Applications like encrypted database queries or privacy-preserving machine learning benefit from advanced evaluation capabilities, such as rotation keys for vector manipulations or bootstrapping keys for resetting noise.</p></li>
</ul>
</section>
</section>
</section>
<section id="homomorphism-on-the-rsa" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="homomorphism-on-the-rsa">Homomorphism on the RSA</h2>
<p>To understand how HE schemes work, we will explore the RSA algorithm. First, we must review some essential mathematical concepts behind encryption schemes.</p>
<section id="number-theory" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="number-theory">Number theory</h3>
<section id="primes-and-factorization" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="primes-and-factorization">Primes and factorization</h4>
<p>The journey into number theory starts with the basic building blocks of integers and their relationships, such as divisibility and the idea of prime numbers.</p>
<blockquote class="blockquote">
<p><strong>Definition (<em>Set of integers</em>)</strong>: The set of integers is denoted as <span class="math inline">\mathbb{Z} = {..., -2, -1, 0, 1, 2, ...}</span>.</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>Definition (<em>Divisibility</em>)</strong>: An integer <span class="math inline">a</span> is said to divide an integer <span class="math inline">b</span> if there exists an integer <span class="math inline">c</span> such that <span class="math inline">b = a \cdot c</span>. In this case, we write <span class="math inline">a \mid b</span>.</p>
</blockquote>
<p>For example, <span class="math inline">6 \mid 18</span> holds because <span class="math inline">18 = 6 \cdot 3</span>. If <span class="math inline">a \nmid b</span>, then <span class="math inline">a</span> does not divide <span class="math inline">b</span>.</p>
<blockquote class="blockquote">
<p><strong>Theorem&nbsp;(<em>Division Algorithm</em>)</strong>: For any integers <span class="math inline">a</span> and <span class="math inline">b &gt; 0</span>, there exist unique integers <span class="math inline">q</span> (quotient) and <span class="math inline">r</span> (remainder) such that: <span class="math display">
a = q \cdot b + r, \quad 0 \leq r &lt; b
</span></p>
</blockquote>
<p>For example, dividing <span class="math inline">17</span> by <span class="math inline">5</span> gives <span class="math inline">q = 3</span> and <span class="math inline">r = 2</span>, as <span class="math inline">17 = 3 \cdot 5 + 2</span>.</p>
<p>Prime numbers are the building blocks of integers:</p>
<blockquote class="blockquote">
<p><strong>Definition (<em>Integer primality</em>)</strong>: A number <span class="math inline">p &gt; 1</span> is prime if its only divisors are <span class="math inline">1</span> and <span class="math inline">p</span>.</p>
</blockquote>
<p>For instance, <span class="math inline">7</span> is prime, while <span class="math inline">12</span> is composite because <span class="math inline">12 = 2 \cdot 6</span>.</p>
<blockquote class="blockquote">
<p><strong>Theorem (<em>Fundamental Theorem of Arithmetic</em>)</strong>: Every integer <span class="math inline">n &gt; 1</span> can be written as a product of prime powers, and this factorization is unique up to the order of the factors: <span class="math display">
n = p_1^{e_1} \cdot p_2^{e_2} \cdots p_k^{e_k}
</span> where <span class="math inline">p_i</span> are distinct primes, <span class="math inline">i</span> and <span class="math inline">e_i</span> are positive integers, and <span class="math inline">k</span> is the number of distinct prime factors of <span class="math inline">n</span>.</p>
</blockquote>
<p>For example, <span class="math inline">84 = 2^2 \cdot 3 \cdot 7</span> demonstrates this principle.</p>
<div class="page-columns page-full"><blockquote class="blockquote">
<p><strong>Remark</strong>: It is straightforward to compute the product of two large prime numbers <span class="math inline">p</span> and <span class="math inline">q</span>. However, the reverse operation, determining the original prime factors from their product <span class="math inline">n = p \cdot q</span>, is computationally difficult. This difficulty arises from the lack of efficient algorithms for factorizing large integers. The best-known algorithms, such as the General Number Field Sieve (GNFS)<a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a>, have exponential time complexity for large inputs. This asymmetry makes factoring infeasible within a reasonable timeframe as the bit length of <span class="math inline">p</span> and <span class="math inline">q</span> increases. Moreover, the factors <span class="math inline">p</span> and <span class="math inline">q</span> are typically chosen to be large primes of similar bit length to avoid simple heuristics or optimizations. This problem is so significant that it has its own name, the Integer Factorization Problem (denoted $ [n] $), and it underpins the security of many public-key cryptosystems, including RSA, ensuring that decrypting or compromising encrypted data without the private key remains practically impossible.</p>
</blockquote><div class="no-row-height column-margin column-container"><div id="fn26"><p><sup>26</sup>&nbsp;Lenstra, A. K., &amp; Lenstra, H. W. (1993). <strong>The development of the number field sieve</strong> (Vol. 1554). <em>Springer-Verlag</em>. <a href="https://doi.org/10.1007/BFb0091534">DOI</a></p></div></div></div>
</section>
<section id="greatest-common-divisor" class="level4">
<h4 class="anchored" data-anchor-id="greatest-common-divisor">Greatest common divisor</h4>
<p>To explore relationships between numbers, we often need their greatest common divisor, e.g.&nbsp;to simplify a fraction or to synchronize cycles.</p>
<blockquote class="blockquote">
<p><strong>Definition (<em>Greatest common divisor</em>, <em>GCD</em>)</strong>: The greatest common divisor of two integers <span class="math inline">a</span> and <span class="math inline">b</span>, denoted <span class="math inline">\gcd(a, b)</span>, is the largest integer dividing both <span class="math inline">a</span> and <span class="math inline">b</span>.</p>
</blockquote>
<p>For example, <span class="math inline">\gcd(12, 18) = 6</span>.</p>
<blockquote class="blockquote">
<p><strong>Definition (<em>Relatively primality of integers</em>)</strong>: Two integers are relatively prime if their GCD is <span class="math inline">1</span>.</p>
</blockquote>
<p>Finding the GCD is efficient with the Euclidean algorithm:</p>
<blockquote class="blockquote">
<p><strong>Theorem (<em>Euclidean Algorithm</em>)</strong>: The GCD of two integers <span class="math inline">a</span> and <span class="math inline">b</span>, where at least one is nonzero, can be computed using the recursive relation: <span class="math display">
\gcd(a, b) = \gcd(b, a \pmod{b}).
</span></p>
</blockquote>
<p>This recursive formula stems from the property of divisors: <span class="math display">
\gcd(a, b) = \gcd(b, a - q \cdot b)
</span></p>
<p>where <span class="math inline">q</span> is the quotient when <span class="math inline">a</span> is divided by <span class="math inline">b</span>. Since <span class="math inline">a - q \cdot b = a \pmod{b}</span>, the recursion simplifies to: <span class="math display">
\gcd(a, b) = \gcd(b, r)
</span> where <span class="math inline">r = a \pmod{b}</span>.</p>
<p>For example, consider the integers <span class="math inline">385</span> and <span class="math inline">364</span>. Using the Euclidean Algorithm: <span class="math display">
\begin{aligned}
\gcd(385, 364) &amp;= \gcd(364, 385 \pmod{364}) = \gcd(364, 21), \\
\gcd(364, 21) &amp;= \gcd(21, 364 \pmod{21}) = \gcd(21, 7), \\
\gcd(21, 7) &amp;= \gcd(7, 21 \pmod{7}) = \gcd(7, 0) = 7.
\end{aligned}
</span></p>
<p>Thus, <span class="math inline">\gcd(385, 364) = 7</span>.</p>
<p>The Euclidean Algorithm can be applied to any integers, positive or negative, as long as at least one of the integers is nonzero. The process uses the relationship <span class="math inline">\gcd(a, b) = \gcd(b, a \pmod{b})</span>, where the modulus operation <span class="math inline">a \pmod{b}</span> always returns a remainder <span class="math inline">r</span> satisfying <span class="math inline">0 \leq r &lt; |b|</span>. This means the algorithm effectively reduces to positive remainders during the recursion, even if <span class="math inline">a</span> or <span class="math inline">b</span> starts as a negative number.</p>
<p>Example with negative integers, <span class="math inline">\gcd(-48, 18)</span>: <span class="math display">
\begin{aligned}
\gcd(-48, 18) &amp;= \gcd(18, -48 \pmod{18}) = \gcd(18, 12), \\
\gcd(18, 12) &amp;= \gcd(12, 18 \pmod{12}) = \gcd(12, 6), \\
\gcd(12, 6) &amp;= \gcd(6, 12 \pmod{6}) = \gcd(6, 0) = 6.
\end{aligned}
</span></p>
<p>The sign of the integers does not affect the result, as <span class="math inline">\gcd(-a, b) = \gcd(a, b)</span>.</p>
<p>The GCD is not only useful for determining divisibility but also plays a key role in finding linear combinations of integers. This is formalized in Bézout’s Identity:</p>
<blockquote class="blockquote">
<p><strong>Theorem (<em>Bézout’s Identity</em>)</strong>: For any integers <span class="math inline">a</span> and <span class="math inline">b</span>, there exist integers <span class="math inline">x</span> and <span class="math inline">y</span> such that: <span class="math display">
\gcd(a, b) = ax + by.
</span> The integers <span class="math inline">x</span> and <span class="math inline">y</span> are called Bézout coefficients.</p>
</blockquote>
<p>These coefficients are not unique; for any integer <span class="math inline">k</span>, another pair <span class="math inline">(x', y')</span> can be generated as: <span class="math display">
\begin{aligned}
x' &amp;= x + k \cdot \frac{b}{\gcd(a, b)}, \\
y' &amp;= y - k \cdot \frac{a}{\gcd(a, b)}.
\end{aligned}
</span></p>
<p>The <strong>Extended Euclidean Algorithm</strong> builds upon the Euclidean Algorithm to compute the Bézout coefficients <span class="math inline">x</span> and <span class="math inline">y</span>. It works by tracing back the remainders obtained during the GCD computation:</p>
<blockquote class="blockquote">
<p><strong>Algorithm (<em>Extended Euclidean Algorithm</em>)</strong>:</p>
<ol type="1">
<li><p>Input integers <span class="math inline">a</span> and <span class="math inline">b</span>.</p></li>
<li><p>Initialize <span class="math inline">r_0</span>, <span class="math inline">r_1</span>, <span class="math inline">s_0</span>, <span class="math inline">s_1</span>, <span class="math inline">t_0</span>, <span class="math inline">t_1</span>, <span class="math inline">i</span>:</p>
<ol type="1">
<li><span class="math inline">r_0 = a</span>, <span class="math inline">r_1 = b</span></li>
<li><span class="math inline">s_0 = 1</span>, <span class="math inline">s_1 = 0</span></li>
<li><span class="math inline">t_0 = 0</span>, <span class="math inline">t_1 = 1</span></li>
<li><span class="math inline">i = 1</span>.</li>
</ol></li>
<li><p>While <span class="math inline">r_i \neq 0</span>:</p>
<ol type="1">
<li>Compute quotient <span class="math inline">q = r_{i-1} \div r_i</span></li>
<li><span class="math inline">r_{i+1} = r_{i-1} - q \times r_i</span></li>
<li><span class="math inline">s_{i+1} = s_{i-1} - q \times s_i</span></li>
<li><span class="math inline">t_{i+1} = t_{i-1} - q \times t_i</span></li>
<li><span class="math inline">i = i + 1</span>.</li>
</ol></li>
<li><p>Return <span class="math inline">GCD</span>, <span class="math inline">x</span>, and <span class="math inline">y</span> where <span class="math inline">ax + by = \gcd(a,b)</span>:</p>
<ol type="1">
<li><span class="math inline">GCD = r_{i-1}</span></li>
<li><span class="math inline">(x,y) = (s_{i-1}, t_{i-1})</span>.</li>
</ol></li>
</ol>
</blockquote>
<p>Below it is shown how the Extended Euclidean Algorithm works step by step with <span class="math inline">a = 48</span> and <span class="math inline">b = 18</span>:</p>
<ol type="1">
<li><p>Initialize:</p>
<ul>
<li><span class="math inline">r_0 = 48</span>, <span class="math inline">r_1 = 18</span></li>
<li><span class="math inline">s_0 = 1</span>, <span class="math inline">s_1 = 0</span></li>
<li><span class="math inline">t_0 = 0</span>, <span class="math inline">t_1 = 1</span></li>
<li><span class="math inline">i = 1</span>.</li>
</ul></li>
<li><p>First iteration (<span class="math inline">i = 1</span>):</p>
<ul>
<li><span class="math inline">q = r_0 \div r_1 = 48 \div 18 = 2</span> (quotient)</li>
<li><span class="math inline">r_2 = r_0 - q \times r_1 = 48 - 2 \times 18 = 12</span></li>
<li><span class="math inline">s_2 = s_0 - q \times s_1 = 1 - 2 \times 0 = 1</span></li>
<li><span class="math inline">t_2 = t_0 - q \times t_1 = 0 - 2 \times 1 = -2</span>.</li>
</ul></li>
<li><p>Second iteration (<span class="math inline">i = 2</span>):</p>
<ul>
<li><span class="math inline">q = r_1 \div r_2 = 18 \div 12 = 1</span></li>
<li><span class="math inline">r_3 = r_1 - q \times r_2 = 18 - 1 \times 12 = 6</span></li>
<li><span class="math inline">s_3 = s_1 - q \times s_2 = 0 - 1 \times 1 = -1</span></li>
<li><span class="math inline">t_3 = t_1 - q \times t_2 = 1 - 1 \times (-2) = 3</span>.</li>
</ul></li>
<li><p>Third iteration (<span class="math inline">i = 3</span>):</p>
<ul>
<li><span class="math inline">q = r_2 \div r_3 = 12 \div 6 = 2</span></li>
<li><span class="math inline">r_4 = r_2 - q \times r_3 = 12 - 2 \times 6 = 0</span></li>
<li><span class="math inline">s_4 = s_2 - q \times s_3 = 1 - 2 \times (-1) = 3</span></li>
<li><span class="math inline">t_4 = t_2 - q \times t_3 = -2 - 2 \times 3 = -8</span>.</li>
</ul></li>
<li><p>Since <span class="math inline">r_4 = 0</span>, we stop and return:</p>
<ul>
<li><span class="math inline">GCD = r_3 = 6</span></li>
<li><span class="math inline">x = s_3 = -1</span></li>
<li><span class="math inline">y = t_3 = 3</span>.</li>
</ul></li>
</ol>
<p>Therefore:</p>
<ul>
<li><span class="math inline">\gcd(48,18) = 6</span>.</li>
<li>The coefficients are <span class="math inline">x = -1</span> and <span class="math inline">y = 3</span>.</li>
<li>We can verify: <span class="math inline">48 \times (-1) + 18 \times 3 = -48 + 54 = 6</span>.</li>
</ul>
<p>So the equation <span class="math inline">ax + by = \gcd(a,b)</span> is satisfied: <span class="math inline">48(-1) + 18(3) = 6</span>.</p>
<p>This identity is critical in RSA for computing modular inverses, which rely on finding such coefficients.</p>
</section>
</section>
<section id="modular-arithmetic" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="modular-arithmetic">Modular arithmetic</h3>
<p>Modular arithmetic is the backbone of cryptographic systems like RSA, enabling secure and efficient encryption, decryption, and key exchange. By confining computations to equivalence classes, modular arithmetic limits operations to a manageable finite set of remainders <span class="math inline">\{0, 1, \dots, n-1\}</span>. This reduction simplifies calculations with large numbers, allowing consistent and efficient arithmetic even when working with very large exponents or products, as is typical in cryptography. For example, modular exponentiation uses this confinement to ensure that intermediate computations remain bounded and practical, avoiding the inefficiencies of dealing with massive numbers directly.</p>
<section id="congruence" class="level4">
<h4 class="anchored" data-anchor-id="congruence">Congruence</h4>
<blockquote class="blockquote">
<p><strong>Definition (<em>Congruence</em>)</strong>: For integers <span class="math inline">a</span>, <span class="math inline">b</span>, and <span class="math inline">n</span> with <span class="math inline">n &gt; 0</span>, <span class="math inline">a</span> is congruent to <span class="math inline">b</span> modulo <span class="math inline">n</span>, written <span class="math inline">a \equiv b \pmod{n}</span>, if <span class="math inline">n \mid (a - b)</span>.</p>
</blockquote>
<p>For example, <span class="math inline">23 \equiv 8 \pmod{5}</span> because <span class="math inline">5 \mid (23 - 8)</span>.</p>
<p>This congruence partitions integers into <strong>congruence classes</strong> modulo <span class="math inline">n</span>, grouping numbers that share the same remainder when divided by <span class="math inline">n</span>. These equivalence classes reduce infinitely many integers to a manageable finite set.</p>
<blockquote class="blockquote">
<p><strong>Theorem (<em>Equivalence relation</em>)</strong>: Congruence modulo <span class="math inline">n</span> satisfies the three fundamental properties of an equivalence relation:</p>
<ol type="1">
<li><p>Reflexivity: <span class="math inline">a \equiv a \pmod{n}</span>, since <span class="math inline">n \mid (a - a) = 0</span>.</p></li>
<li><p>Symmetry: If <span class="math inline">a \equiv b \pmod{n}</span>, then <span class="math inline">b \equiv a \pmod{n}</span>, because <span class="math inline">n \mid (a - b)</span> implies <span class="math inline">n \mid (b - a)</span>.</p></li>
<li><p>Transitivity: If <span class="math inline">a \equiv b \pmod{n}</span> and <span class="math inline">b \equiv c \pmod{n}</span>, then <span class="math inline">a \equiv c \pmod{n}</span>, as <span class="math inline">n \mid (a - b)</span> and <span class="math inline">n \mid (b - c)</span> imply <span class="math inline">n \mid (a - c)</span>.</p></li>
</ol>
</blockquote>
<p>These properties ensure that modular arithmetic forms a consistent framework for mathematical operations.</p>
<blockquote class="blockquote">
<p><strong>Theorem (<em>Congruence and remainders</em>)</strong>: From the Division Algorithm, we have <span class="math inline">r = a \pmod{b}</span>, meaning <span class="math inline">a \equiv b \pmod{n}</span> if and only if <span class="math inline">a</span> and <span class="math inline">b</span> share the same remainder when divided by <span class="math inline">n</span>. Moreover, both <span class="math inline">a</span> and <span class="math inline">b</span> are congruent to that common remainder: <span class="math display">
a \equiv b \pmod{n} \implies a \pmod{n} = b \pmod{n}.
</span></p>
</blockquote>
<p>This relationship provides a computational foundation for modular arithmetic.</p>
<p>Every integer modulo <span class="math inline">n</span> can be uniquely represented by a remainder within a specific range. This principle is foundational to modular arithmetic, as it ensures that each congruence class has a single canonical representative. The following theorem formalizes this idea:</p>
<blockquote class="blockquote">
<p><strong>Theorem (<em>Unique representation</em>)</strong>: For <span class="math inline">n \geq 2</span>, every integer is congruent modulo <span class="math inline">n</span> to exactly one element of the set <span class="math inline">\{0, 1, 2, \dots, n-1\}</span>.</p>
</blockquote>
<p>The notion of congruence naturally leads to the concept of a congruence class, which groups integers that share the same remainder when divided by <span class="math inline">n</span>. These classes partition the set of integers into distinct subsets, each representing one equivalence class under congruence modulo <span class="math inline">n</span>.</p>
<blockquote class="blockquote">
<p><strong>Definition (<em>Congruence class</em>)</strong>: A congruence class modulo <span class="math inline">n</span>, denoted <span class="math inline">[a]_n</span>, is the set of integers equivalent to <span class="math inline">a \pmod{n}</span>: <span class="math display">
[a]_n = \{a + kn \mid k \in \mathbb{Z}\}.
</span></p>
</blockquote>
<p>These classes partition <span class="math inline">\mathbb{Z}</span> into <span class="math inline">n</span> disjoint subsets, which together form the set <span class="math inline">\mathbb{Z}_n</span>, the set of equivalence classes modulo <span class="math inline">n</span>. Each subset corresponds to a unique remainder in <span class="math inline">\{0, 1, \dots, n-1\}</span>.</p>
<p>For example, modulo <span class="math inline">3</span>, the congruence classes are:</p>
<ul>
<li><span class="math inline">[0]_3 = \{..., -3, 0, 3, 6, ...\}</span>,</li>
<li><span class="math inline">[1]_3 = \{..., -2, 1, 4, 7, ...\}</span>,</li>
<li><span class="math inline">[2]_3 = \{..., -1, 2, 5, 8, ...\}</span>.</li>
</ul>
<p>Thus, <span class="math inline">\mathbb{Z}_3 = \{[0]_3, [1]_3, [2]_3\}</span>, representing all possible congruence classes modulo <span class="math inline">3</span>.</p>
<p>The concept of a congruence class provides a structured way to organize integers under modulo <span class="math inline">n</span>. Each congruence class contains infinitely many integers that share the same modular properties. To simplify working with these classes, it is common to choose specific representatives for computations. The following definitions introduce the two most commonly used representatives:</p>
<blockquote class="blockquote">
<p><strong>Definition (<em>Least positive representative</em>)</strong>: The least positive representative of a congruence class modulo <span class="math inline">n</span> is the smallest nonnegative integer in the class, given by <span class="math inline">a \pmod{n}</span>.</p>
</blockquote>
<p>For example, consider modulo <span class="math inline">5</span>:</p>
<ul>
<li>For <span class="math inline">[7]_5</span>, the least positive representative is <span class="math inline">7 \pmod{5} = 2</span>.</li>
<li>For <span class="math inline">[-11]_5</span>, the least positive representative is <span class="math inline">-11 \pmod{5} = 4</span>.</li>
</ul>
<blockquote class="blockquote">
<p><strong>Definition (<em>Least magnitude representative</em>)</strong>: The least magnitude representative of a congruence class modulo <span class="math inline">n</span> minimizes <span class="math inline">|r|</span>, where <span class="math inline">-n/2 &lt; r \leq n/2</span>.</p>
</blockquote>
<p>Again, for modulo <span class="math inline">5</span>:</p>
<ul>
<li>For <span class="math inline">[7]_5</span>, the least magnitude representative is <span class="math inline">2</span>, as <span class="math inline">-5/2 &lt; 2 \leq 5/2</span>.</li>
<li>For <span class="math inline">[-11]_5</span>, the least magnitude representative is <span class="math inline">-1</span>, as <span class="math inline">-5/2 &lt; -1 \leq 5/2</span>.</li>
</ul>
<p>These representatives are key to simplifying modular arithmetic calculations and ensuring consistent results.</p>
</section>
<section id="addition-and-multiplication" class="level4">
<h4 class="anchored" data-anchor-id="addition-and-multiplication">Addition and multiplication</h4>
<p>In modular arithmetic, fundamental operations like addition and multiplication follow specific rules that maintain consistency within the modular system. These rules are formalized in the following theorem:</p>
<blockquote class="blockquote">
<p><strong>Theorem (Modular addition and multiplication)</strong>: For integers <span class="math inline">a</span> and <span class="math inline">b</span>: <span class="math display">
\begin{aligned}
(a + b) \pmod{n} &amp;= ((a \pmod{n}) + (b \pmod{n})) \pmod{n}, \\
(a \cdot b) \pmod{n} &amp;= ((a \pmod{n}) \cdot (b \pmod{n})) \pmod{n}.
\end{aligned}
</span></p>
</blockquote>
<p>When comparing <span class="math inline">\mathbb{Z}</span> (integers) and <span class="math inline">\mathbb{Z}_n</span> (integers modulo n), we find both similarities and key differences in their algebraic properties:</p>
<ol type="1">
<li><p><strong>Similarities</strong>:</p>
<ul>
<li>Both have well-defined addition and multiplication operations.</li>
<li>Zero has no multiplicative inverse in both systems.</li>
<li><span class="math inline">1</span> (and <span class="math inline">-1</span> in <span class="math inline">\mathbb{Z}</span> or its equivalent <span class="math inline">n-1</span> in <span class="math inline">\mathbb{Z}_n</span>) always has a multiplicative inverse.</li>
</ul></li>
<li><p><strong>Differences</strong>:</p>
<ul>
<li>In <span class="math inline">\mathbb{Z}</span>, only <span class="math inline">±1</span> have multiplicative inverses.</li>
<li>In <span class="math inline">\mathbb{Z}_n</span>, any element <span class="math inline">a</span> where <span class="math inline">\gcd(a,n)=1</span> has a multiplicative inverse.</li>
<li><span class="math inline">\mathbb{Z}</span> is infinite, while <span class="math inline">\mathbb{Z}_n</span> has exactly <span class="math inline">n</span> elements.</li>
<li>All operations in <span class="math inline">\mathbb{Z}_n</span> are bounded by <span class="math inline">n</span>, while operations in <span class="math inline">\mathbb{Z}</span> can grow indefinitely.</li>
</ul></li>
</ol>
<p>This distinction in multiplicative inverses makes <span class="math inline">\mathbb{Z}_n</span> particularly useful in applications like cryptography, where invertible elements are crucial for encryption and decryption operations.</p>
</section>
<section id="modular-exponentiation" class="level4">
<h4 class="anchored" data-anchor-id="modular-exponentiation">Modular exponentiation</h4>
<p>Modular exponentiation is a key operation in cryptography, enabling efficient computation of powers modulo a number. This operation is central to cryptographic systems like RSA, where large exponentiations are common.</p>
<blockquote class="blockquote">
<p><strong>Definition (<em>Modular exponentiation</em>)</strong>: Modular exponentiation computes <span class="math inline">a^b \pmod{n}</span>, where <span class="math inline">a</span> is the base, <span class="math inline">b</span> is the exponent, and <span class="math inline">n</span> is the modulus.</p>
</blockquote>
<p>Direct computation is impractical for large <span class="math inline">b</span>, so efficient algorithms like <strong>square-and-multiply</strong> are used:</p>
<blockquote class="blockquote">
<p><strong>Algorithm (<em>Right-to-left square-and-multiply algorithm</em>)</strong>:</p>
<ol type="1">
<li><p>Input integers <span class="math inline">a</span>, <span class="math inline">b</span>, and <span class="math inline">n</span> where <span class="math inline">a</span> is the base, <span class="math inline">b</span> is the exponent, and <span class="math inline">n</span> is the modulus.</p></li>
<li><p>Convert <span class="math inline">b</span> to its binary representation:</p></li>
<li><p>Input integer <span class="math inline">b</span>.</p></li>
<li><p>Initialize <span class="math inline">binary\_representation = []</span>.</p></li>
<li><p>While <span class="math inline">b &gt; 0</span>: 1. Append <span class="math inline">b \\pmod{2}</span> to <span class="math inline">binary\_representation</span> 2. Update <span class="math inline">b = b // 2</span>.</p></li>
<li><p>Initialize <span class="math inline">reversed\_representation = []</span>.</p></li>
<li><p>For each bit in <span class="math inline">binary\_representation</span>, starting from the last element, append the bit to <span class="math inline">reversed\_representation</span>.</p></li>
<li><p>Initialize <span class="math inline">result = 1</span>.</p></li>
<li><p>For each bit <span class="math inline">m</span> in <span class="math inline">reversed\_representation</span>:</p>
<ol type="1">
<li><span class="math inline">result = (result \cdot result) \pmod{n}</span>.</li>
<li>If <span class="math inline">m == 1</span>, then <span class="math inline">result = (result \cdot a) \pmod{n}</span>.</li>
</ol></li>
<li><p>Return <span class="math inline">result</span>, which is <span class="math inline">a^b \pmod{n}</span>.</p></li>
</ol>
</blockquote>
<p>The alternative lef-to-right approach is obtained omitting steps 2.4 and 2.5, then computing step 4 on <span class="math inline">binary\_representation</span>.</p>
<p>Let’s compute <span class="math inline">3^{13} \pmod{7}</span>:</p>
<ol type="1">
<li><p>Input integers <span class="math inline">a = 3</span>, <span class="math inline">b = 13</span>, and <span class="math inline">n = 7</span>.</p></li>
<li><p>Initialize <span class="math inline">binary\_representation = []</span>.</p></li>
<li><p>While <span class="math inline">b &gt; 0</span>:</p>
<ol type="1">
<li>Append <span class="math inline">13 \pmod{2} = 1</span>, <span class="math inline">binary\_representation = [1]</span>.</li>
<li>Update <span class="math inline">b = 13 // 2 = 6</span>.</li>
<li>Append <span class="math inline">6 \pmod{2} = 0</span>, <span class="math inline">binary\_representation = [1, 0]</span>.</li>
<li>Update <span class="math inline">b = 6 // 2 = 3</span>.</li>
<li>Append <span class="math inline">3 \pmod{2} = 1</span>, <span class="math inline">binary\_representation = [1, 0, 1]</span>.</li>
<li>Update <span class="math inline">b = 3 // 2 = 1</span>.</li>
<li>Append <span class="math inline">1 \pmod{2} = 1</span>, <span class="math inline">binary\_representation = [1, 0, 1, 1]</span>.</li>
<li>Update <span class="math inline">b = 1 // 2 = 0</span>.</li>
</ol></li>
<li><p><span class="math inline">reversed\_representation = [1, 1, 0, 1]</span>.</p></li>
<li><p>Initialize <span class="math inline">result = 1</span>.</p></li>
<li><p>First iteration (<span class="math inline">m = 1</span>):</p>
<ol type="1">
<li><span class="math inline">result = (result \cdot result) \pmod{7} = (1 \cdot 1) \pmod{7} = 1</span>.</li>
<li><span class="math inline">result = (result \cdot a) \pmod{7} = (1 \cdot 3) \pmod{7} = 3</span>.</li>
</ol></li>
<li><p>Second iteration (<span class="math inline">m = 1</span>):</p>
<ol type="1">
<li><span class="math inline">result = (result \cdot result) \pmod{7} = (3 \cdot 3) \pmod{7} = 2</span>.</li>
<li><span class="math inline">result = (result \cdot a) \pmod{7} = (2 \cdot 3) \pmod{7} = 6</span>.</li>
</ol></li>
<li><p>Third iteration (<span class="math inline">m = 0</span>):</p>
<ol type="1">
<li><span class="math inline">result = (result \cdot result) \pmod{7} = (6 \cdot 6) \pmod{7} = 1</span>.</li>
<li>No multiplication since <span class="math inline">m = 0</span>.</li>
</ol></li>
<li><p>Fourth iteration (<span class="math inline">m = 1</span>):</p>
<ol type="1">
<li><span class="math inline">result = (result \cdot result) \pmod{7} = (1 \cdot 1) \pmod{7} = 1</span>.</li>
<li><span class="math inline">result = (result \cdot a) \pmod{7} = (1 \cdot 3) \pmod{7} = 3</span>.</li>
</ol></li>
</ol>
<p>We get <span class="math inline">result = 3</span>, so <span class="math inline">3^{13} \pmod{7} = 3</span>.</p>
</section>
<section id="modular-inverse" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="modular-inverse">Modular inverse</h4>
<p>The modular inverse is a fundamental concept in number theory and cryptography. It is essential for solving modular equations, whose solution is determined within a given modulus <span class="math inline">n</span>, meaning the values satisfy the equation in terms of congruence relations.</p>
<blockquote class="blockquote">
<p><strong>Definition (<em>Modular inverse</em>)</strong>: The modular inverse of an integer <span class="math inline">a</span> modulo <span class="math inline">n</span>, denoted as <span class="math inline">a^{-1} \pmod{n}</span>, is an integer <span class="math inline">x</span> such that: <span class="math display">
a^{-1} \pmod{n} = a \cdot x \equiv 1 \pmod{n}.
</span></p>
</blockquote>
<p>The modular inverse relies on several fundamental principles in number theory, including conditions for existence, efficient computation methods, and connections to primality tests. Below we will outline these key theorems, algorithms, and applications.</p>
<blockquote class="blockquote">
<p><strong>Theorem (<em>Existence of modular inverse</em>)</strong>: An integer <span class="math inline">a</span> has a modular inverse modulo <span class="math inline">n</span> if and only if <span class="math inline">\gcd(a, n) = 1</span>. If the modular inverse exists, it is unique modulo <span class="math inline">n</span>.</p>
</blockquote>
<p>A proof sketch can be given leveraging the Bézout’s Identity, because if <span class="math inline">\gcd(a, n) = 1</span>, then there exist integers <span class="math inline">x</span> and <span class="math inline">y</span> such that: <span class="math display">
ax + ny = 1.
</span></p>
<p>Taking this equation modulo <span class="math inline">n</span>, we get: <span class="math display">
ax \equiv 1 \pmod{n}
</span></p>
<p>proving that <span class="math inline">x</span> is the modular inverse of <span class="math inline">a</span> modulo <span class="math inline">n</span>. The uniqueness follows from the properties of congruence classes.</p>
<p>The modular inverse can be computed using the Extended Euclidean Algorithm. This algorithm builds on the general method of finding GCD while also determining the coefficients that satisfy Bézout’s Identity. Here, it is specialized to calculate the modular inverse by assuming <span class="math inline">\gcd(a, n) = 1</span>. The steps are given in the following algorithm:</p>
<blockquote class="blockquote">
<p><strong>Algorithm (<em>Modular inverse via Extended Euclidean Algorithm</em>)</strong>:</p>
<ol type="1">
<li><p>Input integers <span class="math inline">a</span> and <span class="math inline">n</span>, where <span class="math inline">\gcd(a, n) = 1</span>.</p></li>
<li><p>Initialize:</p>
<ol type="1">
<li><span class="math inline">r_0 = n</span>, <span class="math inline">r_1 = a</span> (remainder terms)</li>
<li>Coefficients for <span class="math inline">n</span>: <span class="math inline">s_0 = 1</span>, <span class="math inline">s_1 = 0</span> (coefficients for <span class="math inline">n</span>)</li>
<li>Coefficients for <span class="math inline">a</span>: <span class="math inline">t_0 = 0</span>, <span class="math inline">t_1 = 1</span> (coefficients for <span class="math inline">a</span>).</li>
</ol></li>
<li><p>While <span class="math inline">r_1 \neq 0</span>:</p>
<ol type="1">
<li><span class="math inline">q = \lfloor r_0 / r_1 \rfloor</span> (quotient)</li>
<li><span class="math inline">r_2 = r_0 - q \cdot r_1</span></li>
<li><span class="math inline">s_2 = s_0 - q \cdot s_1</span></li>
<li><span class="math inline">t_2 = t_0 - q \cdot t_1</span></li>
<li><span class="math inline">r_0 = r_1</span>, <span class="math inline">r_1 = r_2</span>, <span class="math inline">s_0 = s_1</span>, <span class="math inline">s_1 = s_2</span>, <span class="math inline">t_0 = t_1</span>, <span class="math inline">t_1 = t_2</span>.</li>
</ol></li>
<li><p>Return <span class="math inline">a^{-1} \pmod{n}</span>: <span class="math inline">a^{-1} \pmod{n} = t_0 \pmod{n}</span>.</p></li>
</ol>
</blockquote>
<p>Or defining a function EEA for the Extended Euclidean Algorithm as <span class="math inline">\text{EEA}: (a, b) \to (\gcd(a, b), x, y)</span>, where <span class="math inline">x</span> is the Bézout coefficient for <span class="math inline">a</span>:</p>
<blockquote class="blockquote">
<p><strong>Algorithm (<em>Modular inverse via Extended Euclidean Algorithm</em>)</strong>:</p>
<ol type="1">
<li><p>Input integers <span class="math inline">a</span> and <span class="math inline">n</span>, where <span class="math inline">\gcd(a, n) = 1</span>.</p></li>
<li><p>Call <span class="math inline">\text{EEA}: (a, n) \to (\gcd(a, n), x, y)</span>.</p></li>
<li><p>If <span class="math inline">\gcd(a, n) \neq 1</span> then return “No modular inverse exists”.</p></li>
<li><p>Return <span class="math inline">a^{-1} \pmod{n}</span>: <span class="math inline">a^{-1} \pmod{n} = x \pmod{n}</span>.</p></li>
</ol>
</blockquote>
<p>Fermat’s Little Theorem enables efficient computation of modular inverses and serves as a basis for primality testing:</p>
<blockquote class="blockquote">
<p><strong>Theorem (<em>Fermat’s Little Theorem</em>)</strong>: If <span class="math inline">p</span> is a prime number and <span class="math inline">a</span> is an integer such that <span class="math inline">p \nmid a</span>, then: <span class="math display">
a^{p-1} \equiv 1 \pmod{p}.
</span></p>
</blockquote>
<p>To find the modular inverse, we rewrite <span class="math inline">a^{p-1}</span> as: <span class="math display">
a^{p-1} = a \cdot a^{p-2}
</span></p>
<p>Substituting this into Fermat’s Little Theorem gives: <span class="math display">
a \cdot a^{p-2} \equiv 1 \pmod{p}
</span></p>
<p>By definition, the modular inverse <span class="math inline">a^{-1}</span> satisfies: <span class="math display">
a \cdot a^{-1} \equiv 1 \pmod{p}
</span></p>
<p>Comparing this with the result above, we conclude that <span class="math inline">a^{p-2}</span> must be the modular inverse of <span class="math inline">a</span> modulo <span class="math inline">p</span>; <span class="math display">
a^{-1} \equiv a^{p-2} \pmod{p}.
</span></p>
<p>This theorem provides a more efficient way to compute modular inverses when <span class="math inline">n</span> is prime compared to the Extended Euclidean Algorithm.</p>
<blockquote class="blockquote">
<p><strong>Remark</strong>: By Fermat’s Little Theorem, for any integer <span class="math inline">a</span> with <span class="math inline">\gcd(a,p)=1</span>, we have <span class="math display">
a^{p-1} \equiv 1 \pmod{p}.
</span> The smallest positive exponent <span class="math inline">k</span> such that <span class="math inline">a^k \equiv 1 \pmod{p}</span> is called the <em>order</em> of <span class="math inline">a</span> modulo <span class="math inline">p</span>. This order always divides <span class="math inline">p-1</span>, but it may be strictly smaller.</p>
</blockquote>
<p>By Fermat’s Little Theorem, for any integer <span class="math inline">a</span> such that <span class="math inline">p \nmid a</span>: <span class="math display">
a^{p-1} \equiv 1 \pmod{p}.
</span></p>
<p>Assume, for contradiction, that there exists a smaller positive integer <span class="math inline">k &lt; p-1</span> such that: <span class="math display">
a^k \equiv 1 \pmod{p}.
</span></p>
<p>If <span class="math inline">a^k \equiv 1 \pmod{p}</span>, then we can write <span class="math inline">p-1</span> using the Division Algorithm: <span class="math display">
p-1 = q \cdot k + r,
</span></p>
<p>where <span class="math inline">q</span> and <span class="math inline">r</span> are integers, and <span class="math inline">0 \leq r &lt; k</span>.</p>
<p>Substituting into <span class="math inline">a^{p-1}</span>, this simplifies to: <span class="math display">
a^{p-1} = a^{q \cdot k + r} = (a^k)^q \cdot a^r.
</span></p>
<p>Since <span class="math inline">a^k \equiv 1 \pmod{p}</span>, we get: <span class="math display">
(a^k)^q \equiv 1^q \equiv 1 \pmod{p}.
</span></p>
<p>Thus: <span class="math display">
a^{p-1} \equiv a^r \pmod{p}.
</span></p>
<p>By Fermat’s Little Theorem, <span class="math inline">a^{p-1} \equiv 1 \pmod{p}</span>, so: <span class="math display">
a^r \equiv 1 \pmod{p}.
</span></p>
<p>However, <span class="math inline">r &lt; k</span>, contradicting the assumption that <span class="math inline">k</span> is the smallest positive integer such that <span class="math inline">a^k \equiv 1 \pmod{p}</span>. Hence, no such smaller <span class="math inline">k &lt; p-1</span> exists, and <span class="math inline">p-1</span> must be the smallest exponent satisfying <span class="math inline">a^{p-1} \equiv 1 \pmod{p}</span>.</p>
<p>Equivalently, if <span class="math inline">a^{p-1} \not\equiv 1 \pmod{p}</span> for some <span class="math inline">a</span> with <span class="math inline">\gcd(a, p) = 1</span>, then <span class="math inline">p</span> is composite. However, the converse of Fermat’s Little Theorem is not true: if <span class="math inline">a^{n-1} \equiv 1 \pmod{n}</span> for all <span class="math inline">a</span> with <span class="math inline">\gcd(a, n) = 1</span>, then <span class="math inline">n</span> is not necessarily a prime. In other words, Fermat’s Little Theorem is effective for disproving primality (when the congruence fails), it is insufficient for proving it.</p>
<p>Numbers that satisfy Fermat’s Little Theorem are defined as <strong>Carmichael numbers</strong>:</p>
<ol type="1">
<li>561: <span class="math inline">561 = 3 \cdot 11 \cdot 17</span>.</li>
<li>1105: <span class="math inline">1105 = 5 \cdot 13 \cdot 17</span>.</li>
<li>1729: <span class="math inline">1729 = 7 \cdot 13 \cdot 19</span>.</li>
<li>2465: <span class="math inline">2465 = 5 \cdot 17 \cdot 29</span>.</li>
<li>2821: <span class="math inline">2821 = 7 \cdot 13 \cdot 31</span>.</li>
</ol>
<p>In 1994, it was proven by Alford, Granville, and Pomerance<a href="#fn27" class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a> that there are infinitely many Carmichael numbers. However, they become increasingly sparse as numbers grow larger.</p>
<div class="no-row-height column-margin column-container"><div id="fn27"><p><sup>27</sup>&nbsp;Alford, W. R., Granville, A., &amp; Pomerance, C. (1994). <strong>There are infinitely many Carmichael numbers</strong>. <em>Annals of Mathematics</em>, 139(3), 703–722. <a href="https://doi.org/10.2307/2118576">DOI</a></p></div></div><p>Defining the function <span class="math inline">\text{Square-and-multiply}: (a, b, n) \to a^b \pmod{n}</span>, we can apply the following test for primality to <span class="math inline">n</span>, choosing as many <span class="math inline">a</span> as possible, where <span class="math inline">1 &lt; a &lt; n</span>:</p>
<blockquote class="blockquote">
<p><strong>Algorithm (<em>Fermat primality test</em>)</strong>:</p>
<ol type="1">
<li><p>Input integers <span class="math inline">n</span> and <span class="math inline">a</span>.</p></li>
<li><p>Call <span class="math inline">\text{Square-and-multiply}: (a, n-1, n) \to a^{n-1} \pmod{n}</span>.</p></li>
<li><p>If <span class="math inline">a^{n-1} \not\equiv 1 \pmod{n}</span> then “<span class="math inline">n</span> is composite” else “<span class="math inline">n</span> is likely prime”.</p></li>
</ol>
</blockquote>
<p>As an alternative to Fermat primality test, there is a brute-force approach for determining whether a number <span class="math inline">n</span> is prime by dividing <span class="math inline">n</span> by smaller prime numbers up to <span class="math inline">\sqrt{n}</span>:</p>
<blockquote class="blockquote">
<p><strong>Algorithm (<em>Trial division primality test</em>)</strong>:</p>
<ol type="1">
<li><p>Input integer <span class="math inline">n &gt; 1</span>.</p></li>
<li><p>If <span class="math inline">n = 2</span>, return “<span class="math inline">n</span> is prime”.</p></li>
<li><p>If <span class="math inline">n \pmod{2} = 0</span>, return “<span class="math inline">n</span> is composite”.</p></li>
<li><p>For <span class="math inline">d</span> where <span class="math inline">d = 2k + 1</span> and <span class="math inline">1 \leq k \leq \lfloor \sqrt{n}/2 \rfloor</span>:</p>
<ol type="1">
<li>If <span class="math inline">n \pmod{d} = 0</span> then return “<span class="math inline">n</span> is composite”.</li>
</ol></li>
<li><p>Return “<span class="math inline">n</span> is prime”.</p></li>
</ol>
</blockquote>
<p>The test involves at most <span class="math inline">\sqrt{n}</span> divisions, making it computationally expensive for large <span class="math inline">n</span>, having a time complexity of <span class="math inline">\mathcal{O}(\sqrt{n})</span>, assuming that a single modulo operation is <span class="math inline">\mathcal{O}(1)</span>. The algorithm becomes more efficient when using a precomputed list of primes up to <span class="math inline">\sqrt{n}</span>, skipping unnecessary checks for non-prime divisors.</p>
<p>For very large <span class="math inline">n</span>, the size of <span class="math inline">n</span> impacts the complexity of each modulo operation. If <span class="math inline">n</span> has <span class="math inline">b</span> bits, then the modulo operation takes <span class="math inline">\mathcal{O}(b^2)</span> time using simple arithmetic or <span class="math inline">\mathcal{O}(b \log b)</span> with optimized algorithms. In such cases, the overall complexity becomes <span class="math inline">\mathcal{O}(\sqrt{n} \cdot \text{modulo complexity})</span>.</p>
<p>A more refined algorithm is the Miller-Rabin primality test<a href="#fn28" class="footnote-ref" id="fnref28" role="doc-noteref"><sup>28</sup></a>, which is much faster and more robust than trial division and the basic Fermat test.</p>
<div class="no-row-height column-margin column-container"><div id="fn28"><p><sup>28</sup>&nbsp;Miller, G. L. (1976). <strong>Riemann’s hypothesis and tests for primality</strong>. <em>Journal of Computer and System Sciences</em>, 13(3), 300–317. <a href="https://doi.org/10.1016/S0022-0000(76)80043-8">DOI</a>. Rabin, M. O. (1980). <strong>Probabilistic algorithm for testing primality</strong>. <em>Journal of Number Theory</em>, 12(1), 128–138. <a href="https://doi.org/10.1016/0022-314X(80)90084-0">DOI</a></p></div></div></section>
<section id="eulers-theorem" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="eulers-theorem">Euler’s theorem</h4>
<p>Euler’s theorem is a fundamental result in number theory that generalizes Fermat’s little theorem. It provides a condition for modular exponentiation when the base and modulus are coprime.</p>
<div class="page-columns page-full"><blockquote class="blockquote">
<p><strong>Definition (<em>Euler totient function</em>)</strong>: Let <span class="math inline">n</span> be a positive integer, the Euler totient function, denoted as <span class="math inline">\phi(n)</span>, counts the number of positive integers less than <span class="math inline">n</span> that are relatively prime to <span class="math inline">n</span><a href="#fn29" class="footnote-ref" id="fnref29" role="doc-noteref"><sup>29</sup></a>: <span class="math display">
\phi(n) = \lvert \{ a \in \mathbb{Z} : 1 \leq a &lt; n, \gcd(a, n) = 1 \}\rvert
</span></p>
</blockquote><div class="no-row-height column-margin column-container"><div id="fn29"><p><sup>29</sup>&nbsp;The symbol <span class="math inline">\#</span> denotes the <strong>cardinality</strong> (size) of a set, which represents the number of elements in that set. It is commonly used in combinatorics and number theory. An alternative notation for the cardinality of a set <span class="math inline">S</span> is <span class="math inline">|S|</span>, which is more prevalent in set theory.</p></div></div></div>
<p>Properties of the Euler totient function:</p>
<ol type="1">
<li><p>If <span class="math inline">p</span> is a prime number, then: <span class="math display">
\phi(p) = p - 1.
</span></p></li>
<li><p>If <span class="math inline">n</span> has the prime factorization <span class="math inline">n = p_1^{e_1} p_2^{e_2} \dots p_k^{e_k}</span>, then <span class="math inline">\phi(n)</span> is given by: <span class="math display">
\phi(n) = n \prod_{i=1}^{k} \left(1 - \frac{1}{p_i} \right).
</span></p></li>
<li><p>The totient function is <strong>multiplicative</strong>, meaning that if <span class="math inline">m</span> and <span class="math inline">n</span> are coprime, then: <span class="math display">
\phi(mn) = \phi(m) \phi(n).
</span></p></li>
</ol>
<blockquote class="blockquote">
<p><strong>Theorem (<em>Euler</em>)</strong>: Let <span class="math inline">a</span> and <span class="math inline">n</span> be coprime integers (i.e., <span class="math inline">\gcd(a, n) = 1</span>). Then: <span class="math display">
a^{\phi(n)} \equiv 1 \pmod{n}.
</span></p>
</blockquote>
<p>This theorem generalizes Fermat’s little theorem, which is a special case when <span class="math inline">n</span> is prime, where <span class="math inline">\phi(p) = p - 1</span> and thus: <span class="math display">
a^{p-1} \equiv 1 \pmod{p}.
</span></p>
<p>Euler’s theorem is widely used in cryptographic algorithms, particularly in the RSA encryption scheme, where it is employed to compute modular inverses efficiently. The theorem allows us to find the modular inverse of <span class="math inline">a</span> modulo <span class="math inline">n</span> when <span class="math inline">\gcd(a, n) = 1</span>, using: <span class="math display">
a^{-1} \equiv a^{\phi(n) - 1} \pmod{n}.
</span></p>
<p>For example, to compute <span class="math inline">3^{\phi(25)} \pmod{25}</span>:</p>
<ul>
<li><p>First, calculate <span class="math inline">\phi(25)</span>: <span class="math display">
\phi(25) = 25 \left( 1 - \frac{1}{5} \right) = 25 \times \frac{4}{5} = 20.
</span></p></li>
<li><p>Then, <span class="math display">
3^{20} \equiv 1 \pmod{25}.
</span></p></li>
</ul>
<p>Thus, using Euler’s theorem, we can directly conclude that any power of 3 raised to 20 will be congruent to 1 modulo 25.</p>
</section>
<section id="carmichaels-theorem" class="level4">
<h4 class="anchored" data-anchor-id="carmichaels-theorem">Carmichael’s theorem</h4>
<p>Carmichael’s theorem refines Euler’s theorem by defining the smallest exponent that guarantees modular exponentiation behaves predictably for all coprime bases. This exponent is given by the <strong>Carmichael function</strong>, denoted as <span class="math inline">\lambda(n)</span>.</p>
<blockquote class="blockquote">
<p><strong>Theorem (<em>Carmichael</em>)</strong>: For a positive integer <span class="math inline">n</span>, the Carmichael function <span class="math inline">\lambda(n)</span> is defined as the <em>exponent</em> of the multiplicative group <span class="math inline">\mathbb{Z}_n^*</span>. Equivalently, <span class="math inline">\lambda(n)</span> is the smallest positive integer such that <span class="math display">
a^{\lambda(n)} \equiv 1 \pmod{n}
</span> for every <span class="math inline">a \in \mathbb{Z}_n^*</span>.</p>
</blockquote>
<p>This function provides a stricter condition than Euler’s theorem and guarantees that for any integer <span class="math inline">a</span> coprime to <span class="math inline">n</span>, the smallest exponent <span class="math inline">e</span> for which <span class="math inline">a^e \equiv 1 \pmod{n}</span> is always a divisor of <span class="math inline">\lambda(n)</span>. In other words, the values of <span class="math inline">e</span> that satisfy this condition must be factors of <span class="math inline">\lambda(n)</span>. By definition, <span class="math inline">\lambda(n)</span> is also always a divisor of <span class="math inline">\phi(n)</span>: <span class="math display">
\lambda(n) \mid \phi(n).
</span></p>
<p>To compute <span class="math inline">\lambda(n)</span>, we use the least common multiple (lcm) function, which determines the smallest positive integer that is divisible by a given set of numbers.</p>
<blockquote class="blockquote">
<p><strong>Definition (<em>least common multiple)</em></strong>: The lcm of two integers <span class="math inline">a</span> and <span class="math inline">b</span>, denoted as <span class="math inline">\operatorname{lcm}(a, b)</span>, is the smallest positive integer that is a multiple of both <span class="math inline">a</span> and <span class="math inline">b</span>: <span class="math display">
\operatorname{lcm}(a, b) = \frac{|a \cdot b|}{\gcd(a, b)},
</span> where <span class="math inline">\gcd(a, b)</span> is the greatest common divisor of <span class="math inline">a</span> and <span class="math inline">b</span>.</p>
</blockquote>
<p>This concept extends naturally to multiple integers, allowing for an efficient computation of <span class="math inline">\lambda(n)</span> when <span class="math inline">n</span> has multiple prime factors.</p>
<p>Example: consider <span class="math inline">n = 18</span>, which has the prime factorization <span class="math inline">n = 2 \times 3^2</span> and we compute:<br>
<span class="math display">
\lambda(2) = 1, \quad \lambda(3^2) = \phi(3^2) = 3.
</span></p>
<p>Since <span class="math inline">n</span> consists of relatively prime factors, we use the least common multiple: <span class="math display">
\lambda(18) = \operatorname{lcm}(\lambda(2), \lambda(3^2)) = \operatorname{lcm}(1, 3) = 3.
</span> This tells us that for any integer <span class="math inline">a</span> coprime to 18, the smallest exponent satisfying <span class="math inline">a^e \equiv 1 \pmod{18}</span> must be a multiple of 3.</p>
<p>To compute <span class="math inline">\lambda(n)</span> efficiently for any integer <span class="math inline">n</span>, we apply the following structured approach, which relies on prime power properties and the least common multiple:</p>
<ol type="1">
<li><p>If <span class="math inline">n</span> is a power of a single prime, <span class="math inline">p^e</span>, we compute <span class="math inline">\lambda(n)</span> as follows:</p>
<ul>
<li>When <span class="math inline">p</span> is an <strong>odd prime</strong> or <span class="math inline">e \leq 2</span>, <span class="math inline">\lambda(p^e)</span> is simply <span class="math inline">\phi(p^e)</span>, the Euler totient function.</li>
<li>When <span class="math inline">p = 2</span> and <span class="math inline">e \geq 3</span>, the exponent is halved:<br>
<span class="math display">
\lambda(p^e) = \frac{1}{2} \phi(p^e).
</span> This accounts for the behavior of powers of 2 in modular arithmetic, ensuring that exponentiation remains consistent with Carmichael’s theorem.</li>
</ul></li>
<li><p>If <span class="math inline">n</span> is a product of multiple <strong>pairwise relatively prime numbers</strong> <span class="math inline">n_1, n_2, ..., n_r</span>, the Carmichael function is computed using the least common multiple: <span class="math display">
\lambda(n) = \operatorname{lcm}(\lambda(n_1), ..., \lambda(n_r)).
</span> This ensures that <span class="math inline">\lambda(n)</span> is compatible with each individual modulus, making it the smallest exponent that satisfies <span class="math inline">a^{\lambda(n)} \equiv 1 \pmod{n}</span> for all coprime bases <span class="math inline">a</span>.</p></li>
<li><p>If <span class="math inline">n</span> is given in its <strong>prime factorized form</strong>: <span class="math display">
n = p_1^{e_1} p_2^{e_2} \dots p_r^{e_r},
</span> then <span class="math inline">\lambda(n)</span> is computed as: <span class="math display">
\lambda(n) = \operatorname{lcm}(\lambda(p_1^{e_1}), ..., \lambda(p_r^{e_r})).
</span> This approach ensures that we first compute <span class="math inline">\lambda</span> for each prime power individually (using the prime power rule) and then combine the results using the least common multiple.</p></li>
</ol>
<p>By following these structured steps, we can efficiently compute <span class="math inline">\lambda(n)</span> for any integer <span class="math inline">n</span>, making it a practical function for number theory and cryptographic applications.</p>
<p>Now, let’s introduce numbers that pass Fermat’s primality test despite being composite:</p>
<blockquote class="blockquote">
<p><strong>Definition (<em>Carmichael number</em>)</strong>: a Carmichael number is a composite number <span class="math inline">n</span> that satisfies: <span class="math display">
a^{n-1} \equiv 1 \pmod{n},
</span> for all <span class="math inline">a</span> coprime to <span class="math inline">n</span>.</p>
</blockquote>
<p>A number is Carmichael if and only if <span class="math inline">\lambda(n)</span> divides <span class="math inline">n - 1</span>. For example, consider: <span class="math display">
\lambda(1105) = \operatorname{lcm}(\lambda(5), \lambda(13), \lambda(17)) = \operatorname{lcm}(4, 12, 16) = 48.
</span> Since <span class="math inline">48</span> divides <span class="math inline">1105 - 1 = 1104</span>, this confirms that 1105 is a Carmichael number.</p>
<p>Carmichael numbers are important in cryptography because they can deceive certain primality tests, making them crucial in designing secure encryption algorithms.</p>
</section>
<section id="generators" class="level4">
<h4 class="anchored" data-anchor-id="generators">Generators</h4>
<p>A <strong>generator</strong> is a number that, when multiplied by itself multiple times (using modular arithmetic), cycles through many or all possible values before repeating. This cycle length is called the <strong>multiplicative order</strong> of the number. In simple terms, it tells us how long it takes for the number to “reset” back to 1 when repeatedly multiplied by itself modulo <span class="math inline">n</span>.</p>
<p>For example, if we take 3 and multiply it repeatedly modulo 7:<br>
<span class="math display">
3^1 \equiv 3 \pmod{7}, \quad 3^2 \equiv 9 \equiv 2 \pmod{7}, \quad 3^3 \equiv 6 \pmod{7}, \quad 3^4 \equiv 4 \pmod{7}, \quad 3^5 \equiv 5 \pmod{7}, \quad 3^6 \equiv 1 \pmod{7}.
</span><br>
Here, the number 3 cycles through all possible values before repeating, making it a generator modulo 7.</p>
<p>This concept is useful in cryptography because some security systems rely on the fact that <strong>finding how many times you need to multiply a number to get back to 1 (the order) is hard to figure out</strong>. This is used in encryption methods like <strong>Diffie-Hellman key exchange</strong>, which helps people securely share secret keys over public networks.</p>
<p>More formally:</p>
<blockquote class="blockquote">
<p><strong>Definition (<em>Multiplicative order</em>)</strong>: given a positive integer <span class="math inline">n</span> and an element <span class="math inline">a \in \mathbb{Z}_n^*</span>, the multiplicative order of <span class="math inline">a</span>, denoted as <span class="math inline">\operatorname{ord}_n(a)</span>, is the smallest integer <span class="math inline">e &gt; 1</span> such that: <span class="math display">
a^e \equiv 1 \pmod{n}.
</span></p>
</blockquote>
<p>Properties of the multiplicative order:</p>
<ol type="1">
<li>The order of <span class="math inline">a</span> always divides <span class="math inline">\phi(n)</span>, a consequence of Euler’s theorem.</li>
<li>For any integer <span class="math inline">i</span>, <span class="math inline">a^i \equiv 1 \pmod{n}</span> if and only if <span class="math inline">\operatorname{ord}_n(a) \mid i</span>.</li>
</ol>
<blockquote class="blockquote">
<p><strong>Definition (<em>Generator</em>)</strong>: an element <span class="math inline">g \in \mathbb{Z}_n^*</span> is called a generator (or a primitive root) of <span class="math inline">\mathbb{Z}_n^*</span> if its order is maximal, meaning: <span class="math display">
\operatorname{ord}_n(g) = \phi(n).
</span></p>
</blockquote>
<p>This implies that <span class="math inline">g</span> can produce all elements of <span class="math inline">\mathbb{Z}_n^*</span> through exponentiation.</p>
<p>A generator <span class="math inline">a</span> of <span class="math inline">\mathbb{Z}_n^*</span> remains a generator under exponentiation if and only if the exponent <span class="math inline">i</span> is chosen correctly, as stated in the following theorem.</p>
<blockquote class="blockquote">
<p><strong>Theorem (<em>Generator preservation</em>)</strong>: if <span class="math inline">a</span> is a generator of <span class="math inline">\mathbb{Z}_n^*</span>, then for any integer <span class="math inline">i</span>, the element <span class="math inline">b \equiv a^i \pmod{n}</span> is also a generator of <span class="math inline">\mathbb{Z}_n^*</span> if and only if: <span class="math display">
\gcd(i, \phi(n)) = 1.
</span></p>
</blockquote>
<p>This property is essential in cryptographic protocols such as Diffie-Hellman key exchange, where security relies on the fact that, while it is easy to compute exponentiation modulo <span class="math inline">n</span>, finding the original exponent <span class="math inline">i</span> given only the result <span class="math inline">a^i \pmod{n}</span> (a problem known as the <strong>discrete logarithm problem</strong>) is computationally difficult.</p>
<p>To illustrate the concept of a generator, consider <span class="math inline">\mathbb{Z}_{10}^*</span>, which consists of the elements: <span class="math display">
\mathbb{Z}_{10}^* = \{1, 3, 7, 9\}.
</span> The totient function gives <span class="math inline">\phi(10) = 4</span>, so a generator <span class="math inline">g</span> must satisfy <span class="math inline">\operatorname{ord}_{10}(g) = 4</span>.</p>
<p>Checking powers of 3 modulo 10: <span class="math display">
3^1 \equiv 3 \pmod{10}, \quad 3^2 \equiv 9 \pmod{10}, \quad 3^3 \equiv 7 \pmod{10}, \quad 3^4 \equiv 1 \pmod{10}.
</span> Since the order of 3 is 4, it is a generator of <span class="math inline">\mathbb{Z}_{10}^*</span>.</p>
</section>
<section id="chinese-remainder-theorem" class="level4">
<h4 class="anchored" data-anchor-id="chinese-remainder-theorem">Chinese Remainder Theorem</h4>
<p>The <strong>Chinese Remainder Theorem (CRT)</strong> is a fundamental result in number theory that provides a way to solve systems of simultaneous congruences when the moduli are pairwise relatively prime.</p>
<blockquote class="blockquote">
<p><strong>Theorem (<em>Chinese Remainder</em>)</strong>: let <span class="math inline">n_1, n_2, \dots, n_k</span> be pairwise relatively prime positive integers, then for any given integers <span class="math inline">r_1, r_2, \dots, r_k</span>, the system of congruences: <span class="math display">
x \equiv r_i \pmod{n_i}, \quad \text{for } i = 1, \dots, k,
</span> has a unique solution modulo <span class="math inline">n = n_1 n_2 \cdots n_k</span>.</p>
</blockquote>
<p>The solution is given by: <span class="math display">
x \equiv \sum_{i=1}^{k} r_i \cdot c_i \cdot m_i \pmod{n},
</span> where <span class="math inline">m_i = \frac{n}{n_i}</span> and <span class="math inline">c_i</span> is the modular inverse of <span class="math inline">m_i</span> modulo <span class="math inline">n_i</span>, satisfying <span class="math inline">c_i m_i \equiv 1 \pmod{n_i}</span>.</p>
<p>Solving systems with CRT algorithm:</p>
<ol type="1">
<li>Compute <span class="math inline">n = n_1 n_2 \cdots n_k</span>.</li>
<li>For each <span class="math inline">i</span>, compute <span class="math inline">m_i = n / n_i</span>.</li>
<li>Compute the modular inverse <span class="math inline">c_i \equiv m_i^{-1} \pmod{n_i}</span>.</li>
<li>Compute <span class="math inline">x = \sum_{i=1}^{k} r_i \cdot c_i \cdot m_i</span> and reduce modulo <span class="math inline">n</span>.</li>
</ol>
<p>For example, solve the system: <span class="math display">
x \equiv 4 \pmod{9}, \quad x \equiv 7 \pmod{13}, \quad x \equiv 2 \pmod{17}.
</span></p>
<p>Since 9, 13, and 17 are pairwise relatively prime, we compute: - <span class="math inline">n = 9 \times 13 \times 17 = 1989</span>. - <span class="math inline">m_1 = 1989/9 = 221</span>, <span class="math inline">m_2 = 1989/13 = 153</span>, <span class="math inline">m_3 = 1989/17 = 117</span>. - Compute the modular inverses: - <span class="math inline">c_1 = 221^{-1} \equiv 4 \pmod{9}</span>. - <span class="math inline">c_2 = 153^{-1} \equiv 12 \pmod{13}</span>. - <span class="math inline">c_3 = 117^{-1} \equiv 10 \pmod{17}</span>. - Compute <span class="math inline">x</span>: <span class="math display">
  x \equiv (4 \times 4 \times 221 + 7 \times 12 \times 153 + 2 \times 10 \times 117) \pmod{1989}.
  </span> Evaluating, we find <span class="math inline">x \equiv 8776 \equiv 418 \pmod{1989}</span>.</p>
<p>Thus, the unique solution modulo 1989 is <span class="math inline">x \equiv 418 \pmod{1989}</span>.</p>
<p>This demonstrates the power of the CRT in reconstructing values from modular congruences.</p>
</section>
<section id="quadratic-residues" class="level4">
<h4 class="anchored" data-anchor-id="quadratic-residues">Quadratic residues</h4>
<blockquote class="blockquote">
<p><strong>Definition (<em>Quadratic residue</em>)</strong>: a number <span class="math inline">a \in \mathbb{Z}_n^*</span> is a quadratic residue modulo <span class="math inline">n</span> if there exists an integer <span class="math inline">x</span> such that: <span class="math display">
a \equiv x^2 \pmod{n}.
</span> Otherwise, <span class="math inline">a</span> is called a <strong>quadratic non-residue</strong> modulo <span class="math inline">n</span>.</p>
</blockquote>
<p>This theorem allows us to efficiently determine whether a number is a quadratic residue:</p>
<blockquote class="blockquote">
<p><strong>Theorem(<em>Euler’s criterion</em>)</strong>: Let <span class="math inline">p</span> be an odd prime and <span class="math inline">a \in \mathbb{Z}_p^*</span>. Then:</p>
<ul>
<li>If <span class="math inline">a</span> is a quadratic residue modulo <span class="math inline">p</span>: <span class="math display">
a^{(p-1)/2} \equiv 1 \pmod{p}.
</span></li>
<li>If <span class="math inline">a</span> is a quadratic non-residue modulo <span class="math inline">p</span>: <span class="math display">
a^{(p-1)/2} \equiv -1 \pmod{p}.
</span></li>
</ul>
</blockquote>
<blockquote class="blockquote">
<p><strong>Definition (<em>Legendre symbol</em>)</strong>: the <strong>Legendre symbol</strong> is a function that determines whether an integer <span class="math inline">a</span> is a quadratic residue modulo an odd prime <span class="math inline">p</span>; it is defined as: <span class="math display">
\left( \frac{a}{p} \right) = \begin{cases}
0, &amp; \text{if } p \mid a, \\
1, &amp; \text{if } a \text{ is a quadratic residue modulo } p, \\
-1, &amp; \text{if } a \text{ is a quadratic non-residue modulo } p.
\end{cases}
</span></p>
</blockquote>
<p>Using Euler’s criterion, we compute: <span class="math display">
\left( \frac{a}{p} \right) \equiv a^{(p-1)/2} \pmod{p}.
</span></p>
<p>Then, we can state:</p>
<blockquote class="blockquote">
<p><strong>Theorem (<em>Properties of the Legendre symbol</em>)</strong>: let <span class="math inline">p</span> be an odd prime and <span class="math inline">a, b</span> be integers, the Legendre symbol satisfies the following properties:</p>
<ol type="1">
<li><span class="math inline">\left( \frac{a}{p} \right) \equiv a^{(p-1)/2} \pmod{p}</span> (Euler’s criterion).</li>
<li>If <span class="math inline">a \equiv b \pmod{p}</span>, then <span class="math inline">\left( \frac{a}{p} \right) = \left( \frac{b}{p} \right)</span>.</li>
<li><span class="math inline">\left( \frac{a \cdot b}{p} \right) = \left( \frac{a}{p} \right) \times \left( \frac{b}{p} \right)</span> (Multiplicative property) .</li>
<li><span class="math inline">\left( \frac{2}{p} \right) = (-1)^{(p^2-1)/8}</span>.</li>
<li>If <span class="math inline">p</span> and <span class="math inline">q</span> are odd primes (Law of quadratic reciprocity) :
<ul>
<li>If <span class="math inline">p \equiv 1 \pmod{4}</span> or <span class="math inline">q \equiv 1 \pmod{4}</span>, then <span class="math inline">\left( \frac{p}{q} \right) = \left( \frac{q}{p} \right)</span>.</li>
<li>If <span class="math inline">p \equiv q \equiv 3 \pmod{4}</span>, then <span class="math inline">\left( \frac{p}{q} \right) = -\left( \frac{q}{p} \right)</span>.</li>
</ul></li>
</ol>
</blockquote>
<p>As an example, for <span class="math inline">p = 19</span>, determine whether <span class="math inline">a = 11</span> is a quadratic residue: <span class="math display">
11^{(19-1)/2} = 11^9 \equiv -1 \pmod{19}.
</span> Since the result is -1, <span class="math inline">11</span> is a quadratic non-residue modulo 19.</p>
<p>The <strong>Jacobi symbol</strong> generalizes the Legendre symbol for odd composite moduli:</p>
<blockquote class="blockquote">
<p><strong>Definition (<em>Jacobi symbol</em>)</strong>: <span class="math display">
\left( \frac{a}{n} \right) = \prod_{i=1}^{r} \left( \frac{a}{p_i} \right)^{e_i},
</span> where <span class="math inline">n = p_1^{e_1} p_2^{e_2} \dots p_r^{e_r}</span> is the prime factorization of <span class="math inline">n</span>.</p>
</blockquote>
<p>The Jacobi symbol shares properties with the Legendre symbol but does not definitively indicate whether <span class="math inline">a</span> is a quadratic residue modulo <span class="math inline">n</span>.</p>
<p>If <span class="math inline">n</span> is an odd composite integer, determining whether <span class="math inline">a</span> with <span class="math inline">\left( \frac{a}{n} \right) = 1</span> is a quadratic residue modulo <span class="math inline">n</span> is called the <strong>Quadratic Residuosity Problem (QR)</strong>. This problem is computationally difficult without knowing the factorization of <span class="math inline">n</span>, linking it to cryptographic security.</p>
<p>The QP is central to probabilistic encryption schemes such as the Goldwasser-Micali cryptosystem, where the difficulty of distinguishing quadratic residues from non-residues provides semantic security. It is also relevant in zero-knowledge proofs and commitment schemes, where proving knowledge of a square root modulo <span class="math inline">n</span> can be done without revealing the value itself. By leveraging the hardness of the QR problem, cryptographic systems can achieve stronger security guarantees, making it an essential tool in modern cryptography.</p>
</section>
<section id="higher-order-residues" class="level4">
<h4 class="anchored" data-anchor-id="higher-order-residues">Higher-order residues</h4>
<blockquote class="blockquote">
<p><strong>Definition (<em>rth residue modulo</em>)</strong>: an integer <span class="math inline">a \in \mathbb{Z}_n^*</span> is called an <strong>rth residue modulo</strong> <span class="math inline">n</span> if there exists an integer <span class="math inline">x \in \mathbb{Z}_n^*</span> such that: <span class="math display">
a \equiv x^r \pmod{n}.
</span> If no such <span class="math inline">x</span> exists, then <span class="math inline">a</span> is called an <strong>rth non-residue</strong> modulo <span class="math inline">n</span>.</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>Lemma (<em>Structure of higher-order residues</em>)</strong>: 1. The set of rth residues modulo <span class="math inline">n</span> that are relatively prime to <span class="math inline">n</span> forms a subgroup of <span class="math inline">\mathbb{Z}_n^*</span>. 2. Each rth residue modulo <span class="math inline">n</span> has the same number of rth roots.</p>
</blockquote>
<p>Determining whether an element is an rth residue modulo <span class="math inline">n</span> is known as the <strong>Higher Residuosity Problem (HRP)</strong>. When <span class="math inline">n</span> is composite and its factorization is unknown, this problem is computationally difficult, making it useful in cryptographic settings. A special case of the HRP occurs when <span class="math inline">r</span> is replaced by <span class="math inline">n</span> and <span class="math inline">n</span> is replaced by <span class="math inline">n^2</span>, where <span class="math inline">n = pq</span> is a product of two distinct odd primes. This version is called the <strong>Composite Residuosity Problem (CRP)</strong> and is used in cryptographic protocols such as Paillier encryption.</p>
<blockquote class="blockquote">
<p><strong>Lemma (<em>Residue completeness condition</em>)</strong>: if <span class="math inline">\gcd(r, \phi(n)) = 1</span>, then every integer in <span class="math inline">\mathbb{Z}_n^*</span> is an rth residue modulo <span class="math inline">n</span>.</p>
</blockquote>
</section>
<section id="residue-classes" class="level4">
<h4 class="anchored" data-anchor-id="residue-classes">Residue classes</h4>
<blockquote class="blockquote">
<p><strong>Definition (<em>Residue class</em>)</strong>: For fixed integers <span class="math inline">r, n, y</span> with <span class="math inline">y \in \mathbb{Z}_n^*</span>, an element <span class="math inline">w \in \mathbb{Z}_n^*</span> is said to belong to a residue class if it can be expressed as: <span class="math display">
w \equiv y^m \cdot u^r \pmod{n},
</span> for some integer <span class="math inline">m</span> and some <span class="math inline">u \in \mathbb{Z}_n^*</span>. The residue class of <span class="math inline">w</span> is denoted as: <span class="math display">
RC[m] = \{ w \in \mathbb{Z}_n^* : w \equiv y^m u^r \pmod{n} \text{ for some } u \in \mathbb{Z}_n^* \}.
</span></p>
</blockquote>
<p>In particular, <span class="math inline">RC[0]</span> represents the set of rth residues modulo <span class="math inline">n</span>.</p>
<blockquote class="blockquote">
<p><strong>Lemma (<em>Addition and inversion in residue classes</em>)</strong>: 1. If <span class="math inline">w_1 \in RC[m_1]</span> and <span class="math inline">w_2 \in RC[m_2]</span>, then <span class="math inline">w_1 \cdot w_2 \in RC[m_1 + m_2]</span>. 2. If <span class="math inline">w \in RC[m]</span>, then <span class="math inline">w^{-1} \in RC[-m]</span>.</p>
</blockquote>
<p>The problem of determining the residue class of a given <span class="math inline">w</span> is conjectured to be computationally difficult and is known as the <strong>Residue Class Problem (RCP)</strong>. A special case arises when <span class="math inline">n</span> is composite, known as the <strong>Composite Residuosity Class Problem (CRP)</strong>, forming the basis of secure cryptographic schemes.</p>
<p>A fundamental question in this context is determining the number of distinct rth roots a given residue has. This is particularly important in cryptographic applications, where knowing the structure of these roots can influence security guarantees. The following theorem establishes a precise condition under which an rth residue has exactly r distinct roots:</p>
<blockquote class="blockquote">
<p><strong>Theorem (<em>Uniqueness and count of rth roots</em>)</strong>: Let <span class="math inline">y \in \mathbb{Z}_n^*</span> be an rth residue modulo <span class="math inline">n</span>. If <span class="math inline">r \mid \phi(n)</span> and <span class="math inline">\gcd(r, \phi(n)/r) = 1</span>, then <span class="math inline">y</span> has exactly <span class="math inline">r</span> distinct rth roots.</p>
</blockquote>
<p>Residue classes provide a structured way to categorize elements of <span class="math inline">\mathbb{Z}_n^*</span> based on their power relationships, enabling cryptographic operations such as <strong>trapdoor functions</strong>, which allow for efficient decryption while keeping encryption computationally difficult, and <strong>homomorphic encryption</strong> schemes, which enable computations on encrypted data without needing decryption. These concepts are foundational in privacy-preserving cryptographic protocols, such as the <strong>Paillier cryptosystem</strong>, which relies on the Composite Residuosity Problem for encryption, <strong>RSA-based voting schemes</strong>, which utilize quadratic residues for secure tallying, and <strong>homomorphic encryption frameworks</strong> like <strong>ElGamal encryption</strong>, which allow operations on encrypted data without decryption. These methods are crucial in secure voting systems, digital signatures, and confidential data processing.</p>
</section>
<section id="random-number-generators" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="random-number-generators">Random number generators</h4>
<p>In cryptographic applications, particularly homomorphic encryption, random numbers are essential for security. A function <span class="math inline">\text{RANDINT}(a, b)</span> is defined to return a uniformly selected integer from the range <span class="math inline">[a, b]</span>. Ensuring unpredictability in random numbers is a fundamental challenge in cryptographic design.</p>
<p>Random number generators (RNGs) are categorized into:</p>
<ul>
<li><p><strong>True Random Number Generators (TRNGs)</strong>: Based on physical processes such as thermal noise or electronic circuit randomness, offering high security against prediction.</p></li>
<li><p><strong>Deterministic Random Number Generators (DRNGs)</strong>: Algorithmic methods that produce sequences from an initial seed, commonly used in cryptographic protocols.</p></li>
</ul>
<p>A DRNGs is fast and efficient but can be predictable if its starting value (seed) is not chosen securely. In contrast, a TRNG relies on physical processes to generate randomness, making it more secure but often slower and requiring specialized hardware. To balance speed and security, many systems use a hybrid approach, where a TRNG provides an initial high-quality seed, and a DRNG expands it to generate more random values efficiently.</p>
<p>When generating a cryptographic key, it’s important to use a secure random number generator (RNG) to ensure unpredictability. A common approach is to use a <strong>Cryptographically Secure Pseudorandom Number Generator (CSPRNG)</strong>, which expands a small amount of highly unpredictable data (called a <strong>seed</strong>) into a long sequence of random values.</p>
<p>A <strong>high-entropy seed</strong> means the initial data used to start the generator is difficult to guess, coming from unpredictable sources like hardware noise, mouse movements, or system timings.</p>
<p>One well-known approach is the <strong>Fortuna</strong><a href="#fn30" class="footnote-ref" id="fnref30" role="doc-noteref"><sup>30</sup></a> algorithm, a security-focused random number generator that works as follows:</p>
<div class="no-row-height column-margin column-container"><div id="fn30"><p><sup>30</sup>&nbsp;Fortuna is a CSPRNG designed by cryptographers Bruce Schneier and Niels Ferguson, introduced in their 2003 book Practical Cryptography. It is named after the Roman goddess of chance, Fortuna. Fortuna is designed to be a secure PRNG that can also accept random inputs from analog sources, enhancing its security. It has been adopted in systems like FreeBSD’s /dev/random since version 11 and in Apple’s operating systems since early 2020. See <em>Schneier on Security</em> <a href="https://www.schneier.com/academic/fortuna/">blog post</a>.</p></div></div><ol type="1">
<li><p>Collect random data from multiple sources, such as user input timings, network activity, or hardware randomness.</p></li>
<li><p>Mix the collected data using a cryptographic hash function to update an internal state securely.</p></li>
<li><p>Generate random values using a block cipher (e.g., AES in counter mode) to ensure strong randomness.</p></li>
<li><p>Periodically refresh the seed to prevent attackers from predicting future random outputs.</p></li>
</ol>
<p>This method ensures that even if part of the system state is exposed, the generated numbers remain secure and unpredictable.</p>
<p>For cryptographic security, DRNGs should satisfy:</p>
<ol type="1">
<li><p>Uniform distribution: ensuring statistical randomness.</p></li>
<li><p>Independence: ensuring no correlation between outputs.</p></li>
<li><p>Unpredictability: preventing attackers from inferring future values.</p></li>
</ol>
<p>Secure choices for transition functions include cryptographic hash functions and block ciphers, ensuring resistance to attacks. Well-known cryptographic DRNGs include also:</p>
<ul>
<li><p><strong>Yarrow</strong><a href="#fn31" class="footnote-ref" id="fnref31" role="doc-noteref"><sup>31</sup></a>: used in macOS for secure randomness.</p></li>
<li><p><strong>NIST SP 800-90A DRBG</strong><a href="#fn32" class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a>: a standardized family of deterministic random bit generators.</p></li>
</ul>
<div class="no-row-height column-margin column-container"><div id="fn31"><p><sup>31</sup>&nbsp;Kelsey, J., Schneier, B., &amp; Ferguson, N. (1999). <strong>Yarrow-160: Notes on the design and analysis of the Yarrow cryptographic pseudorandom number generator</strong>. <em>Selected Areas in Cryptography</em>, 13–33. <a href="https://doi.org/10.1007/3-540-46513-8_2">DOI</a>.</p></div><div id="fn32"><p><sup>32</sup>&nbsp;Barker, E., &amp; Kelsey, J. (2015). <strong>Recommendation for Random Number Generation Using Deterministic Random Bit Generators</strong>. *SP 800-90A Rev.&nbsp;1. National Institute of Standards and Technology. <a href="https://doi.org/10.6028/NIST.SP.800-90Ar1">DOI</a></p></div></div><p>These RNGs play a crucial role in encryption schemes, key generation, digital signatures, and secure multiparty computation.</p>
</section>
</section>
<section id="group-theory" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="group-theory">Group theory</h3>
<p>Cryptography frequently leverages <strong>groups</strong>, which are sets endowed with an operation that behaves in a mathematically predictable way. This predictability makes them ideal for building secure protocols, ranging from Diffie–Hellman key exchange to advanced homomorphic encryption. In this chapter, we outline core definitions and theorems that underpin these constructions.</p>
<section id="basics" class="level4">
<h4 class="anchored" data-anchor-id="basics">Basics</h4>
<blockquote class="blockquote">
<p><strong>Definition (<em>Group</em>)</strong>: A group <span class="math inline">(G, \star)</span> is a set <span class="math inline">G</span> equipped with a binary operation <span class="math inline">\star</span> satisfying four key properties:</p>
<ol type="1">
<li><p><strong>Closure</strong>: For any <span class="math inline">a, b \in G</span>, the result of <span class="math inline">a \star b</span> is still in <span class="math inline">G</span>.</p></li>
<li><p><strong>Associativity</strong>: For any <span class="math inline">a, b, c \in G</span>, <span class="math inline">(a \star b) \star c = a \star (b \star c)</span>.</p></li>
<li><p><strong>Identity element</strong>: There exists an element <span class="math inline">e \in G</span> such that <span class="math inline">e \star a = a \star e = a</span> for all <span class="math inline">a \in G</span>.</p></li>
<li><p><strong>Inverse element</strong>: Each <span class="math inline">a \in G</span> has an element <span class="math inline">a^{-1}</span> satisfying <span class="math inline">a \star a^{-1} = a^{-1} \star a = e</span>.</p></li>
</ol>
</blockquote>
<p>A classic example is the set of integers <span class="math inline">\mathbb{Z}</span> under addition <span class="math inline">(+)</span>:</p>
<ul>
<li><p><span class="math inline">0</span> is the identity (adding zero changes nothing).</p></li>
<li><p>Every integer <span class="math inline">n</span> has an inverse <span class="math inline">-n</span>.</p></li>
</ul>
<p>In <strong>multiplicative</strong> notation, common in cryptography, a group might be a set of <em>invertible</em> numbers modulo <span class="math inline">n</span>. For instance, <span class="math inline">\mathbb{Z}_p^*</span> (integers <span class="math inline">\{1,2,\dots,p-1\}</span> under multiplication <span class="math inline">\pmod{p}</span>) forms a group if <span class="math inline">p</span> is prime.</p>
<p>Groups let us <em>move around</em> elements predictably. For a cryptosystem, that often means repeatedly applying an operation, e.g., exponentiation mod <span class="math inline">p</span>, without leaving the safety of the group.</p>
</section>
<section id="multiplicative-vs.-additive-notation" class="level4">
<h4 class="anchored" data-anchor-id="multiplicative-vs.-additive-notation">Multiplicative vs.&nbsp;additive notation</h4>
<p>Groups used in cryptography often come in two flavors:</p>
<ul>
<li><p><strong>Multiplicative groups</strong>, denoted <span class="math inline">(G, \times)</span>. We write the identity as <span class="math inline">1</span> and the inverse of <span class="math inline">g</span> as <span class="math inline">g^{-1}</span>. An example is <span class="math inline">\mathbb{Z}_p^*</span>, the nonzero integers mod <span class="math inline">p</span>.</p></li>
<li><p><strong>Additive groups</strong>, denoted <span class="math inline">(G, +)</span>. We write the identity as <span class="math inline">0</span> and the inverse of <span class="math inline">a</span> as <span class="math inline">-a</span>. An example is <span class="math inline">(\mathbb{Z}, +)</span> or <span class="math inline">(\mathbb{Z}_n, +)</span>.</p></li>
</ul>
<p>Both notations obey the same fundamental group axioms. Cryptographic schemes switch between them depending on context; for instance, elliptic‐curve cryptography usually adopts additive notation, while classical <span class="math inline">\mathbb{Z}_p^*</span> cryptography uses multiplicative.</p>
</section>
<section id="order-of-a-group-and-order-of-an-element" class="level4">
<h4 class="anchored" data-anchor-id="order-of-a-group-and-order-of-an-element">Order of a group and order of an element</h4>
<blockquote class="blockquote">
<p><strong>Definition (<em>Order of a group</em>)</strong>: The order of a group <span class="math inline">|G|</span> (or <span class="math inline">\operatorname{ord}(G)</span>) is the number of elements in <span class="math inline">G</span> when <span class="math inline">G</span> is finite. In cryptographic contexts, we often choose large prime‐order groups to avoid certain attacks.</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>Definition (<em>Order of an element</em>)</strong>: The order of an element <span class="math inline">g \in G</span> is the smallest positive integer <span class="math inline">k</span> such that <span class="math display">
g^k = e \quad \text{(multiplicative)},
</span> or <span class="math display">
k \cdot g = 0 \quad \text{(additive)},
</span> where <span class="math inline">e</span> is the identity. If no finite <span class="math inline">k</span> satisfies this, we say the element has infinite order (common in some infinite groups, but for cryptography we focus on finite ones).</p>
</blockquote>
<p>The order of an element determines how it behaves under repeated application of the group operation. In the multiplicative group <span class="math inline">\mathbb{Z}_p^*</span>, where <span class="math inline">p</span> is prime, any element <span class="math inline">g</span> raised to successive powers, that is <span class="math inline">g^1, g^2, g^3, \dots</span>, will eventually cycle back to <span class="math inline">1</span>. The smallest positive integer <span class="math inline">k</span> such that <span class="math inline">g^k \equiv 1 \pmod{p}</span> is called the order of <span class="math inline">g</span>. This cyclic property implies that the powers of <span class="math inline">g</span> form a repeating pattern, which plays a central role in modular arithmetic.</p>
<p>Cryptographic schemes like Diffie–Hellman rely on this structure. They use a generator <span class="math inline">g</span> and compute <span class="math inline">g^a \pmod{p}</span> for some secret exponent <span class="math inline">a</span>. While computing <span class="math inline">g^a</span> is easy, recovering <span class="math inline">a</span> from <span class="math inline">g^a</span> is computationally hard. This problem, finding the exponent given the base and the result, is known as the <strong>discrete logarithm problem</strong>, and it underpins the security of many cryptographic protocols.</p>
</section>
<section id="homomorphisms-1" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="homomorphisms-1">Homomorphisms</h4>
<blockquote class="blockquote">
<p><strong>Definition (<em>Group homomorphism</em>)</strong>: A <strong>group homomorphism</strong> from one group <span class="math inline">\bigl(G,\star\bigr)</span> to another <span class="math inline">\bigl(H,\circ\bigr)</span> is a map<br>
<span class="math display">
f : G \,\to\, H
</span> that <strong>preserves</strong> the group operation.</p>
</blockquote>
<p>Formally, for all <span class="math inline">x,y \in G</span>, <span class="math display">
   f\bigl(x \star y\bigr) \;=\; f(x)\,\circ\,f(y).
</span></p>
<p>This means that applying the operation in <span class="math inline">G</span> and then mapping the result is the same as first mapping the inputs and then applying the operation in <span class="math inline">H</span>.</p>
<p>If the homomorphism <span class="math inline">f</span> is also bijective (i.e., both injective and surjective), then <span class="math inline">f</span> is called an isomorphism, and we say that <span class="math inline">G</span> and <span class="math inline">H</span> are isomorphic as groups.</p>
<p>Below are some examples that highlight different ways homomorphisms appear:</p>
<ol type="1">
<li>Reduction mod <span class="math inline">n</span>:</li>
</ol>
<ul>
<li>Groups: <span class="math inline">\bigl(\mathbb{Z}, +\bigr)</span> and <span class="math inline">\bigl(\mathbb{Z}_n, +\bigr)</span></li>
<li>Map: <span class="math inline">f(x) = x \bmod n</span>.</li>
</ul>
<p>Check homomorphism:</p>
<ol type="1">
<li>In <span class="math inline">\mathbb{Z}</span>, the operation is integer addition <span class="math inline">(+)</span>.<br>
</li>
<li>In <span class="math inline">\mathbb{Z}_n</span>, the operation is addition modulo <span class="math inline">n</span>.<br>
</li>
<li>For any <span class="math inline">x,y \in \mathbb{Z}</span>, <span class="math display">
f(x + y) = (x + y)\bmod n \quad\text{and}\quad
f(x)\;+\;f(y) = (x\bmod n)\;+\;(y\bmod n).
    </span> Since <span class="math inline">(x + y)\bmod n = (x\bmod n) + (y\bmod n)\bmod n,</span> the two sides match in <span class="math inline">\mathbb{Z}_n</span>.</li>
</ol>
<p>Hence <span class="math inline">f</span> respects addition and is a group homomorphism. This is an extremely common map in modular arithmetic.</p>
<ol start="2" type="1">
<li>Exponential map <span class="math inline">\exp</span>:</li>
</ol>
<ul>
<li>Groups: <span class="math inline">\bigl(\mathbb{R}, +\bigr)</span> and <span class="math inline">\bigl(\mathbb{R}_{&gt;0}, \times\bigr)</span>.<br>
</li>
<li>Map: <span class="math inline">f(x) = e^x</span>.</li>
</ul>
<p>Check homomorphism:</p>
<ol type="1">
<li><span class="math inline">\mathbb{R}</span> under “<span class="math inline">+</span>” is an additive group; <span class="math inline">\mathbb{R}_{&gt;0}</span> under “<span class="math inline">\times</span>” is multiplicative.<br>
</li>
<li>For real numbers <span class="math inline">x,y</span>, <span class="math display">
f(x + y) = e^{\,x + y} = e^x \cdot e^y = f(x)\;\times\; f(y).
    </span></li>
</ol>
<p>Hence <span class="math inline">\exp</span> is a homomorphism from an additive group to a multiplicative group. While <span class="math inline">\exp</span> is <em>not</em> typically used directly as a <em>cryptographic</em> function (because <span class="math inline">\mathbb{R}</span> is infinite‐precision), the idea of mapping addition to multiplication is the same principle that shows up in exponentiation mod <span class="math inline">p</span>.</p>
<ol start="3" type="1">
<li>Encryption as a homomorphism:</li>
</ol>
<p>Suppose we have a cryptosystem <span class="math inline">\Pi = (P,C,K,E,D)</span> where:</p>
<ul>
<li><span class="math inline">P</span>: plaintext space (a group with operation <span class="math inline">\star</span>).<br>
</li>
<li><span class="math inline">C</span>: ciphertext space (a group with operation <span class="math inline">\odot</span>).<br>
</li>
<li><span class="math inline">K</span>: key space, from which we draw a key <span class="math inline">k</span>.<br>
</li>
<li><span class="math inline">E_k</span>: encryption function.<br>
</li>
<li><span class="math inline">D_k</span>: decryption function.</li>
</ul>
<p>If <span class="math inline">\Pi</span> is additively homomorphic, then for any plaintexts <span class="math inline">m_1,m_2\in P</span>, <span class="math display">
    D_k\bigl(E_k(m_1)\,\odot\,E_k(m_2)\bigr)
    \;=\;
    m_1 \;\star\; m_2.
  </span> Such a map <span class="math inline">E_k</span> is effectively a group homomorphism (up to decryption). Concretely:</p>
<ol type="1">
<li>Additively homomorphic: <span class="math inline">\star</span> = “<span class="math inline">+</span>” in plaintext, <span class="math inline">\odot</span> = some “<span class="math inline">\oplus</span>” or “<span class="math inline">+</span> mod N” in ciphertext. Paillier encryption is a classic example that supports <span class="math inline">E(m_1 + m_2)\equiv E(m_1)\cdot E(m_2)</span>.<br>
</li>
<li>Multiplicatively homomorphic: <span class="math inline">\star</span> = “<span class="math inline">\times</span>” in plaintext, <span class="math inline">\odot</span> = “<span class="math inline">\times</span>” mod <span class="math inline">n</span> in ciphertext. RSA in its raw mathematical form is multiplicatively homomorphic over <span class="math inline">\mathbb{Z}_n^*</span>. However, in practice secure padding schemes (e.g., OAEP or PKCS#1 v1.5) are always used, and these break the homomorphic property. Therefore, deployed RSA does not support homomorphic operations.</li>
</ol>
<p>Real cryptosystems often require additional mechanisms (like <em>padding</em> in RSA<a href="#fn33" class="footnote-ref" id="fnref33" role="doc-noteref"><sup>33</sup></a>) to prevent malicious manipulations. But the fundamental <em>operation preserved under encryption</em> is precisely a homomorphism property.</p>
<div class="no-row-height column-margin column-container"><div id="fn33"><p><sup>33</sup>&nbsp;When we say that RSA is multiplicatively homomorphic in its raw form, we mean the basic mathematical version of RSA without any padding scheme. In this form, encrypting a product of two messages is equivalent to multiplying their individual encryptions. However, this “raw” RSA is not secure in practice because it is deterministic and vulnerable to certain attacks. Real-world RSA implementations include padding (like OAEP) to ensure security, but these padding schemes break the homomorphic property.</p></div></div></section>
</section>
</section>
<section id="the-rsa-cryptosystem" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="the-rsa-cryptosystem">The RSA cryptosystem</h2>
<p>The RSA cryptosystem, introduced in 1977 by Ronald Rivest, Adi Shamir, and Leonard Adleman, marked a turning point in the history of cryptography. It was the first widely applicable public-key encryption scheme, enabling secure communication over insecure channels without requiring the sender and receiver to share a secret key in advance. This was revolutionary. Before RSA, virtually all cryptographic systems were symmetric, meaning that both parties had to agree on a shared key, typically through a secure channel—a serious limitation in distributed and open environments like the internet.</p>
<p>The concept of public-key cryptography itself had been proposed only a year earlier, in 1976, by Whitfield Diffie and Martin Hellman. Their work introduced the theoretical foundation for asymmetric key exchange but did not include a concrete implementation. RSA was the first practical realization of this idea, immediately demonstrating how public-key systems could be used not just for key exchange but also for encryption and digital signatures, enabling crucial capabilities like authentication, confidentiality, and integrity.</p>
<p>RSA’s security is based on the mathematical challenge of factoring large composite numbers, a problem for which no efficient classical algorithm is known. Specifically, RSA relies on the assumption that it is computationally infeasible to factor a number <span class="math inline">n</span> that is the product of two large primes. This difficulty underpins the security of RSA keys, making it extremely hard for an attacker to recover the private key from the public one, as long as the key size is sufficiently large.</p>
<p>Over the decades, RSA has become one of the most studied and widely deployed cryptographic algorithms in the world. It serves as the backbone of countless security protocols and standards, including SSL/TLS for secure web browsing, PGP for encrypted email, and many digital certificate infrastructures. RSA also introduced a new generation of cryptographic thinking that spurred the development of modern cryptography as a scientific field, leading to innovations such as zero-knowledge proofs, elliptic curve cryptography, and homomorphic encryption.</p>
<p>In this tutorial, RSA is used as a stepping stone toward understanding more advanced techniques like PHE and eventually FHE. By studying RSA’s structure, limitations, and homomorphic properties (particularly its ability to multiply encrypted values), we lay the groundwork for exploring encryption systems that support computation on encrypted data—a key enabler for secure cloud computing, privacy-preserving machine learning, and other emerging technologies.</p>
<section id="key-generation" class="level3">
<h3 class="anchored" data-anchor-id="key-generation">Key generation</h3>
<p>The RSA algorithm begins with the generation of a key pair: a <strong>public key</strong> that can be shared with anyone, and a <strong>private key</strong> that must be kept secret. The strength of RSA comes from the mathematical properties of prime numbers and modular arithmetic. The key generation process proceeds as follows:</p>
<ol type="1">
<li><p>Select two large prime numbers, <span class="math inline">p</span> and <span class="math inline">q</span>, at random. These primes should be of similar bit-length and large enough (e.g., 1024 bits each) to resist modern factoring attacks. The security of RSA depends on the fact that, while multiplying <span class="math inline">p</span> and <span class="math inline">q</span> is easy, factoring their product is computationally hard.</p></li>
<li><p>Compute the modulus: <span class="math display">
n = p \times q
</span> The value <span class="math inline">n</span> will be used as the modulus for both encryption and decryption operations. It defines the modular arithmetic setting of RSA, namely the ring <span class="math inline">\mathbb{Z}_n</span> and, for invertible elements, the multiplicative group <span class="math inline">\mathbb{Z}_n^*</span>.</p></li>
<li><p>Compute Euler’s totient function: <span class="math display">
\phi(n) = (p - 1)(q - 1)
</span> Since <span class="math inline">p</span> and <span class="math inline">q</span> are prime, <span class="math inline">\phi(n)</span> simply equals the product of <span class="math inline">p-1</span> and <span class="math inline">q-1</span>. This value is used to define the multiplicative group structure necessary for decryption.</p></li>
<li><p>Choose an encryption exponent <span class="math inline">e</span> such that: <span class="math display">
1 &lt; e &lt; \phi(n), \quad \gcd(e, \phi(n)) = 1
</span> The value <span class="math inline">e</span> must be coprime with <span class="math inline">\phi(n)</span> to ensure that it has a modular inverse. A widely adopted choice is <span class="math inline">e = 65537</span>, which provides a good balance between efficiency and security.</p></li>
<li><p>Compute the decryption exponent <span class="math inline">d</span> as the modular inverse of <span class="math inline">e</span> modulo <span class="math inline">\phi(n)</span>: <span class="math display">
d \equiv e^{-1} \pmod{\phi(n)}
</span> This means that <span class="math inline">d</span> satisfies <span class="math inline">e \cdot d \equiv 1 \pmod{\phi(n)}</span>. It can be computed using the extended Euclidean algorithm.</p></li>
<li><p>Publish the public key <span class="math inline">(n, e)</span> and keep the private key <span class="math inline">d</span> secret. The public key is used to encrypt messages or verify digital signatures. The private key is used to decrypt messages or sign them. Together, they form the asymmetric key pair.</p></li>
</ol>
<p>The security of RSA depends on the computational difficulty of factoring the modulus <span class="math inline">n</span> into its two prime factors <span class="math inline">p</span> and <span class="math inline">q</span>. As long as <span class="math inline">n</span> is large enough (typically at least 2048 bits), and proper cryptographic padding is used, RSA remains secure against known classical attacks.</p>
</section>
<section id="encryption-and-decryption" class="level3">
<h3 class="anchored" data-anchor-id="encryption-and-decryption">Encryption and decryption</h3>
<p>Once the RSA keys have been generated, the public key <span class="math inline">(n, e)</span> can be used to encrypt messages, while the private key <span class="math inline">d</span> is used to decrypt them. The encryption and decryption processes are mathematical inverses of each other, relying on modular exponentiation.</p>
<section id="encryption" class="level4">
<h4 class="anchored" data-anchor-id="encryption">Encryption</h4>
<p>To encrypt a message <span class="math inline">m</span>, it must first be represented as an integer such that: <span class="math display">
0 &lt; m &lt; n
</span></p>
<p>This is usually achieved through a standardized encoding scheme that converts the plaintext (e.g., a string or file) into an integer in the valid range. Once <span class="math inline">m</span> is obtained, the ciphertext <span class="math inline">c</span> is computed using the public key exponent <span class="math inline">e</span>: <span class="math display">
c = m^e \pmod{n}
</span></p>
<p>This operation is efficient due to fast exponentiation algorithms and can be performed by anyone who has access to the public key.</p>
</section>
<section id="decryption" class="level4">
<h4 class="anchored" data-anchor-id="decryption">Decryption</h4>
<p>To recover the original message from the ciphertext, the recipient uses their private key <span class="math inline">d</span> and performs the following operation: <span class="math display">
m = c^d \pmod{n}
</span></p>
<p>Because of how <span class="math inline">d</span> was computed (as the modular inverse of <span class="math inline">e</span>), this operation correctly reverses the encryption process. That is: <span class="math display">
(m^e)^d \equiv m \pmod{n}
</span></p>
<p>This symmetry between encryption and decryption lies at the heart of RSA’s functionality: encrypting with the public key and decrypting with the private key yields the original message, and vice versa (this property also enables RSA digital signatures).</p>
<p>In practice, messages are almost never encrypted <em>raw</em> like this. Real-world RSA implementations use padding schemes such as OAEP (Optimal Asymmetric Encryption Padding) to ensure semantic security and protect against various attacks.</p>
</section>
</section>
<section id="homomorphic-evaluation" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="homomorphic-evaluation">Homomorphic evaluation</h3>
<p>One notable property of RSA is its support for <strong>homomorphic multiplication</strong>. If two plaintext messages <span class="math inline">m_1</span> and <span class="math inline">m_2</span> are encrypted separately to produce ciphertexts <span class="math inline">c_1 = m_1^e \pmod{n}</span> and <span class="math inline">c_2 = m_2^e \pmod{n}</span>, then their product: <span class="math display">
c = c_1 \cdot c_2 \pmod{n}
</span> is itself a valid ciphertext. Specifically, it decrypts to the product of the original plaintexts: <span class="math display">
\text{Dec}(c) = (m_1 \cdot m_2) \pmod{n}
</span></p>
<p>This means that multiplication on ciphertexts corresponds to multiplication on plaintexts. In homomorphic encryption terminology, this is an <span class="math inline">Eval</span> operation: <span class="math display">
\text{Eval}(\times, c_1, c_2) = c_1 \cdot c_2 \pmod{n}
</span></p>
<p>Because RSA only supports multiplication homomorphically (not addition), it is classified as a PHE scheme. This property, while limited, has important applications in cryptographic protocols such as <strong>blind signatures</strong><a href="#fn34" class="footnote-ref" id="fnref34" role="doc-noteref"><sup>34</sup></a> and <strong>verifiable computation</strong><a href="#fn35" class="footnote-ref" id="fnref35" role="doc-noteref"><sup>35</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn34"><p><sup>34</sup>&nbsp;A cryptographic protocol that allows a message to be signed by a signer without revealing its content. This is useful in privacy-preserving systems such as electronic voting or anonymous digital cash, where a user wants a valid signature on a message without exposing the message itself.</p></div><div id="fn35"><p><sup>35</sup>&nbsp;A cryptographic technique that enables a client to outsource a computation to an untrusted server and later verify that the result was computed correctly, without redoing the computation. This is particularly important in cloud computing and delegated data processing.</p></div></div></section>
<section id="example" class="level3">
<h3 class="anchored" data-anchor-id="example">Example</h3>
<p>Let’s walk through a hands-on example of RSA’s multiplicative homomorphism.</p>
<p>Suppose we pick two small primes: <span class="math inline">p = 11</span> and <span class="math inline">q = 13</span>, so <span class="math inline">n = pq = 143</span>. Compute Euler’s totient:</p>
<p><span class="math display">
\phi(n) = (p - 1)(q - 1) = 10 \cdot 12 = 120
</span></p>
<p>Choose the public exponent <span class="math inline">e = 7</span>, which is coprime with <span class="math inline">\phi(n)</span>. Compute the private exponent <span class="math inline">d = e^{-1} \pmod{\phi(n)} = 103</span>.</p>
<p>Now encrypt two messages, <span class="math inline">m_1 = 5</span> and <span class="math inline">m_2 = 7</span>:</p>
<ul>
<li><span class="math inline">c_1 = 5^7 \pmod{143} = 78</span></li>
<li><span class="math inline">c_2 = 7^7 \pmod{143} = 47</span></li>
</ul>
<p>Multiply the ciphertexts:</p>
<p><span class="math display">
c = c_1 \cdot c_2 \pmod{143} = 78 \cdot 47 \pmod{143} = 45
</span></p>
<p>Now decrypt:</p>
<p><span class="math display">
m = 45^{103} \pmod{143} = 35 = 5 \cdot 7
</span></p>
<p>The decrypted result equals the product of the original messages. This confirms that:</p>
<p><span class="math display">
\text{Dec}(c_1 \cdot c_2 \pmod{n}) = m_1 \cdot m_2 \pmod{n}
</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="annotated-cell-1"><pre class="sourceCode numberSource python code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-1-1"><a href="#annotated-cell-1-1"></a><span class="kw">def</span> modinv(a, m):</span>
<span id="annotated-cell-1-2"><a href="#annotated-cell-1-2"></a>    t, new_t <span class="op">=</span> <span class="dv">0</span>, <span class="dv">1</span></span>
<span id="annotated-cell-1-3"><a href="#annotated-cell-1-3"></a>    r, new_r <span class="op">=</span> m, a</span>
<span id="annotated-cell-1-4"><a href="#annotated-cell-1-4"></a></span>
<span id="annotated-cell-1-5"><a href="#annotated-cell-1-5"></a>    <span class="cf">while</span> new_r <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="annotated-cell-1-6"><a href="#annotated-cell-1-6"></a>        quotient <span class="op">=</span> r <span class="op">//</span> new_r</span>
<span id="annotated-cell-1-7"><a href="#annotated-cell-1-7"></a>        t, new_t <span class="op">=</span> new_t, t <span class="op">-</span> quotient <span class="op">*</span> new_t</span>
<span id="annotated-cell-1-8"><a href="#annotated-cell-1-8"></a>        r, new_r <span class="op">=</span> new_r, r <span class="op">-</span> quotient <span class="op">*</span> new_r</span>
<span id="annotated-cell-1-9"><a href="#annotated-cell-1-9"></a></span>
<span id="annotated-cell-1-10"><a href="#annotated-cell-1-10"></a>    <span class="cf">return</span> t <span class="op">%</span> m <span class="cf">if</span> r <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="va">None</span></span>
<span id="annotated-cell-1-11"><a href="#annotated-cell-1-11"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-1-12" class="code-annotation-target"><a href="#annotated-cell-1-12"></a>p, q <span class="op">=</span> <span class="dv">11</span>, <span class="dv">13</span></span>
<span id="annotated-cell-1-13"><a href="#annotated-cell-1-13"></a>n <span class="op">=</span> p <span class="op">*</span> q</span>
<span id="annotated-cell-1-14"><a href="#annotated-cell-1-14"></a>phi_n <span class="op">=</span> (p <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> (q <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="annotated-cell-1-15"><a href="#annotated-cell-1-15"></a>e <span class="op">=</span> <span class="dv">7</span></span>
<span id="annotated-cell-1-16"><a href="#annotated-cell-1-16"></a>d <span class="op">=</span> modinv(e, phi_n)</span>
<span id="annotated-cell-1-17"><a href="#annotated-cell-1-17"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-1-18" class="code-annotation-target"><a href="#annotated-cell-1-18"></a>m1, m2 <span class="op">=</span> <span class="dv">5</span>, <span class="dv">7</span></span>
<span id="annotated-cell-1-19"><a href="#annotated-cell-1-19"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-1-20" class="code-annotation-target"><a href="#annotated-cell-1-20"></a>c1 <span class="op">=</span> <span class="bu">pow</span>(m1, e, n)</span>
<span id="annotated-cell-1-21"><a href="#annotated-cell-1-21"></a>c2 <span class="op">=</span> <span class="bu">pow</span>(m2, e, n)</span>
<span id="annotated-cell-1-22"><a href="#annotated-cell-1-22"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-1-23" class="code-annotation-target"><a href="#annotated-cell-1-23"></a>c_mul <span class="op">=</span> (c1 <span class="op">*</span> c2) <span class="op">%</span> n</span>
<span id="annotated-cell-1-24"><a href="#annotated-cell-1-24"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="5" onclick="event.preventDefault();">5</a><span id="annotated-cell-1-25" class="code-annotation-target"><a href="#annotated-cell-1-25"></a>m_mul <span class="op">=</span> <span class="bu">pow</span>(c_mul, d, n)</span>
<span id="annotated-cell-1-26"><a href="#annotated-cell-1-26"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="6" onclick="event.preventDefault();">6</a><span id="annotated-cell-1-27" class="code-annotation-target"><a href="#annotated-cell-1-27"></a><span class="bu">print</span>(<span class="ss">f"Encrypted m1: </span><span class="sc">{</span>c1<span class="sc">}</span><span class="ss">"</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="7" onclick="event.preventDefault();">7</a><span id="annotated-cell-1-28" class="code-annotation-target"><a href="#annotated-cell-1-28"></a><span class="bu">print</span>(<span class="ss">f"Encrypted m2: </span><span class="sc">{</span>c2<span class="sc">}</span><span class="ss">"</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="8" onclick="event.preventDefault();">8</a><span id="annotated-cell-1-29" class="code-annotation-target"><a href="#annotated-cell-1-29"></a><span class="bu">print</span>(<span class="ss">f"Encrypted product: </span><span class="sc">{</span>c_mul<span class="sc">}</span><span class="ss">"</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="9" onclick="event.preventDefault();">9</a><span id="annotated-cell-1-30" class="code-annotation-target"><a href="#annotated-cell-1-30"></a><span class="bu">print</span>(<span class="ss">f"Decrypted product: </span><span class="sc">{</span>m_mul<span class="sc">}</span><span class="ss">"</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-1" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="12" data-code-annotation="1">RSA setup.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="18" data-code-annotation="2">Plaintexts.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="20" data-code-annotation="3">Encrypt.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="23" data-code-annotation="4">Homomorphic multiplication.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="25" data-code-annotation="5">Decrypt result.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="27" data-code-annotation="6">Output: <code>78</code>.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="7">7</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="28" data-code-annotation="7">Output: <code>47</code>.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="8">8</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="29" data-code-annotation="8">Output: <code>45</code>.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="9">9</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="30" data-code-annotation="9">Output: <code>35</code>.</span>
</dd>
</dl>
</section>
</section>
<section id="fhe-programming-example" class="level2">
<h2 class="anchored" data-anchor-id="fhe-programming-example">FHE programming example</h2>
<p>Below is a simple FHE example using the <strong>Microsoft SEAL</strong> library in Python. Note that this requires installing the Python bindings for SEAL. Depending on your platform, you can either compile them yourself or obtain a precompiled distribution (often referred to as <a href="https://github.com/Huelse/seal-python">SEAL-Python</a>.</p>
<section id="installation" class="level3">
<h3 class="anchored" data-anchor-id="installation">Installation</h3>
<ol type="1">
<li><p><strong>Install SEAL</strong> (C++ library) by following the official <a href="https://github.com/microsoft/SEAL">Microsoft SEAL GitHub</a> instructions.</p></li>
<li><p><strong>Install Python bindings</strong>. For many environments, you can try:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="ex">pip</span> install seal</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>or</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a><span class="ex">pip</span> install seal-python</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>If you encounter errors, consult the seal-python or pybind_seal repository for build instructions on your specific platform (Windows, macOS, Linux).</p></li>
</ol>
</section>
<section id="code" class="level3">
<h3 class="anchored" data-anchor-id="code">Code</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="annotated-cell-2"><pre class="sourceCode numberSource python code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode python"><a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-2-1" class="code-annotation-target"><a href="#annotated-cell-2-1"></a><span class="im">import</span> seal</span>
<span id="annotated-cell-2-2"><a href="#annotated-cell-2-2"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-2-3" class="code-annotation-target"><a href="#annotated-cell-2-3"></a><span class="kw">def</span> bfv_demo():</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-2-4" class="code-annotation-target"><a href="#annotated-cell-2-4"></a>    parms <span class="op">=</span> seal.EncryptionParameters(seal.scheme_type.BFV)</span>
<span id="annotated-cell-2-5"><a href="#annotated-cell-2-5"></a>    </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-2-6" class="code-annotation-target"><a href="#annotated-cell-2-6"></a>    parms.set_poly_modulus_degree(<span class="dv">4096</span>)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="5" onclick="event.preventDefault();">5</a><span id="annotated-cell-2-7" class="code-annotation-target"><a href="#annotated-cell-2-7"></a>    parms.set_coeff_modulus(seal.CoeffModulus.BFVDefault(<span class="dv">4096</span>))</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="6" onclick="event.preventDefault();">6</a><span id="annotated-cell-2-8" class="code-annotation-target"><a href="#annotated-cell-2-8"></a>    parms.set_plain_modulus(<span class="dv">65537</span>)</span>
<span id="annotated-cell-2-9"><a href="#annotated-cell-2-9"></a>    </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="7" onclick="event.preventDefault();">7</a><span id="annotated-cell-2-10" class="code-annotation-target"><a href="#annotated-cell-2-10"></a>    context <span class="op">=</span> seal.SEALContext(parms)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="8" onclick="event.preventDefault();">8</a><span id="annotated-cell-2-11" class="code-annotation-target"><a href="#annotated-cell-2-11"></a>    keygen <span class="op">=</span> seal.KeyGenerator(context)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="9" onclick="event.preventDefault();">9</a><span id="annotated-cell-2-12" class="code-annotation-target"><a href="#annotated-cell-2-12"></a>    public_key <span class="op">=</span> keygen.public_key()</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="10" onclick="event.preventDefault();">10</a><span id="annotated-cell-2-13" class="code-annotation-target"><a href="#annotated-cell-2-13"></a>    secret_key <span class="op">=</span> keygen.secret_key()</span>
<span id="annotated-cell-2-14"><a href="#annotated-cell-2-14"></a>    </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="11" onclick="event.preventDefault();">11</a><span id="annotated-cell-2-15" class="code-annotation-target"><a href="#annotated-cell-2-15"></a>    encryptor <span class="op">=</span> seal.Encryptor(context, public_key)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="12" onclick="event.preventDefault();">12</a><span id="annotated-cell-2-16" class="code-annotation-target"><a href="#annotated-cell-2-16"></a>    decryptor <span class="op">=</span> seal.Decryptor(context, secret_key)</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="13" onclick="event.preventDefault();">13</a><span id="annotated-cell-2-17" class="code-annotation-target"><a href="#annotated-cell-2-17"></a>    evaluator <span class="op">=</span> seal.Evaluator(context)</span>
<span id="annotated-cell-2-18"><a href="#annotated-cell-2-18"></a>    </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="14" onclick="event.preventDefault();">14</a><span id="annotated-cell-2-19" class="code-annotation-target"><a href="#annotated-cell-2-19"></a>    encoder <span class="op">=</span> seal.IntegerEncoder(context)</span>
<span id="annotated-cell-2-20"><a href="#annotated-cell-2-20"></a>    </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="15" onclick="event.preventDefault();">15</a><span id="annotated-cell-2-21" class="code-annotation-target"><a href="#annotated-cell-2-21"></a>    m1, m2 <span class="op">=</span> <span class="dv">12</span>, <span class="dv">23</span></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="16" onclick="event.preventDefault();">16</a><span id="annotated-cell-2-22" class="code-annotation-target"><a href="#annotated-cell-2-22"></a>    plain1 <span class="op">=</span> encoder.encode(m1)</span>
<span id="annotated-cell-2-23"><a href="#annotated-cell-2-23"></a>    plain2 <span class="op">=</span> encoder.encode(m2)</span>
<span id="annotated-cell-2-24"><a href="#annotated-cell-2-24"></a>    </span>
<span id="annotated-cell-2-25"><a href="#annotated-cell-2-25"></a>    ciphertext1 <span class="op">=</span> seal.Ciphertext()</span>
<span id="annotated-cell-2-26"><a href="#annotated-cell-2-26"></a>    ciphertext2 <span class="op">=</span> seal.Ciphertext()</span>
<span id="annotated-cell-2-27"><a href="#annotated-cell-2-27"></a>    </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="17" onclick="event.preventDefault();">17</a><span id="annotated-cell-2-28" class="code-annotation-target"><a href="#annotated-cell-2-28"></a>    encryptor.encrypt(plain1, ciphertext1)</span>
<span id="annotated-cell-2-29"><a href="#annotated-cell-2-29"></a>    encryptor.encrypt(plain2, ciphertext2)</span>
<span id="annotated-cell-2-30"><a href="#annotated-cell-2-30"></a>    </span>
<span id="annotated-cell-2-31"><a href="#annotated-cell-2-31"></a>    result_add <span class="op">=</span> seal.Ciphertext()</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="18" onclick="event.preventDefault();">18</a><span id="annotated-cell-2-32" class="code-annotation-target"><a href="#annotated-cell-2-32"></a>    evaluator.add(ciphertext1, ciphertext2, result_add)</span>
<span id="annotated-cell-2-33"><a href="#annotated-cell-2-33"></a>    </span>
<span id="annotated-cell-2-34"><a href="#annotated-cell-2-34"></a>    result_mul <span class="op">=</span> seal.Ciphertext()</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="19" onclick="event.preventDefault();">19</a><span id="annotated-cell-2-35" class="code-annotation-target"><a href="#annotated-cell-2-35"></a>    evaluator.multiply(ciphertext1, ciphertext2, result_mul)</span>
<span id="annotated-cell-2-36"><a href="#annotated-cell-2-36"></a>    </span>
<span id="annotated-cell-2-37"><a href="#annotated-cell-2-37"></a>    dec_add <span class="op">=</span> seal.Plaintext()</span>
<span id="annotated-cell-2-38"><a href="#annotated-cell-2-38"></a>    dec_mul <span class="op">=</span> seal.Plaintext()</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="20" onclick="event.preventDefault();">20</a><span id="annotated-cell-2-39" class="code-annotation-target"><a href="#annotated-cell-2-39"></a>    decryptor.decrypt(result_add, dec_add)</span>
<span id="annotated-cell-2-40"><a href="#annotated-cell-2-40"></a>    decryptor.decrypt(result_mul, dec_mul)</span>
<span id="annotated-cell-2-41"><a href="#annotated-cell-2-41"></a>    </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="21" onclick="event.preventDefault();">21</a><span id="annotated-cell-2-42" class="code-annotation-target"><a href="#annotated-cell-2-42"></a>    res_add <span class="op">=</span> encoder.decode_int32(dec_add)</span>
<span id="annotated-cell-2-43"><a href="#annotated-cell-2-43"></a>    res_mul <span class="op">=</span> encoder.decode_int32(dec_mul)</span>
<span id="annotated-cell-2-44"><a href="#annotated-cell-2-44"></a>    </span>
<span id="annotated-cell-2-45"><a href="#annotated-cell-2-45"></a>    <span class="bu">print</span>(<span class="ss">f"Original: m1=</span><span class="sc">{</span>m1<span class="sc">}</span><span class="ss">, m2=</span><span class="sc">{</span>m2<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="annotated-cell-2-46"><a href="#annotated-cell-2-46"></a>    <span class="bu">print</span>(<span class="ss">f"Homomorphic sum: </span><span class="sc">{</span>res_add<span class="sc">}</span><span class="ss"> (expected </span><span class="sc">{</span>m1 <span class="op">+</span> m2<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="annotated-cell-2-47"><a href="#annotated-cell-2-47"></a>    <span class="bu">print</span>(<span class="ss">f"Homomorphic product: </span><span class="sc">{</span>res_mul<span class="sc">}</span><span class="ss"> (expected </span><span class="sc">{</span>m1 <span class="op">*</span> m2<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="annotated-cell-2-48"><a href="#annotated-cell-2-48"></a></span>
<span id="annotated-cell-2-49"><a href="#annotated-cell-2-49"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="22" onclick="event.preventDefault();">22</a><span id="annotated-cell-2-50" class="code-annotation-target"><a href="#annotated-cell-2-50"></a>    bfv_demo()</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-2" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="1" data-code-annotation="1"><code>import seal</code>: Loads the Microsoft SEAL Python bindings.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="3" data-code-annotation="2"><code>bfv_demo()</code>: Our main function demonstrating the BFV workflow.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="4" data-code-annotation="3"><code>EncryptionParameters</code>: Creates a parameter object for BFV.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="6" data-code-annotation="4"><code>set_poly_modulus_degree(4096)</code>: Sets the polynomial modulus degree (must be a power of 2).<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="7" data-code-annotation="5"><code>set_coeff_modulus(BFVDefault(4096))</code>: Sets default coefficient moduli for BFV at degree 4096.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="8" data-code-annotation="6"><code>set_plain_modulus(65537)</code>: The plain modulus that defines the max range of plaintext values.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="7">7</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="10" data-code-annotation="7"><code>SEALContext</code>: Builds a context object from the chosen parameters.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="8">8</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="11" data-code-annotation="8"><code>KeyGenerator</code>: Object that creates public/secret keys.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="9">9</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="12" data-code-annotation="9"><code>public_key = ...</code>: Retrieve the encryption (public) key.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="10">10</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="13" data-code-annotation="10"><code>secret_key = ...</code>: Retrieve the decryption (secret) key.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="11">11</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="15" data-code-annotation="11"><code>Encryptor</code>: Used to encrypt plaintexts with the public key.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="12">12</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="16" data-code-annotation="12"><code>Decryptor</code>: Used to decrypt ciphertexts with the secret key.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="13">13</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="17" data-code-annotation="13"><code>Evaluator</code>: Executes homomorphic operations (add, multiply, etc.).<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="14">14</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="19" data-code-annotation="14"><code>IntegerEncoder</code>: Encodes small integers into the BFV plaintext representation.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="15">15</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="21" data-code-annotation="15"><code>m1, m2 = 12, 23</code>: Two integers for the demo.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="16">16</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="22" data-code-annotation="16"><code>encoder.encode(m1)</code>: Converts integer to a SEAL plaintext polynomial.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="17">17</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="28" data-code-annotation="17"><code>encryptor.encrypt(...)</code>: Transforms the plaintext polynomial into a ciphertext.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="18">18</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="32" data-code-annotation="18"><code>evaluator.add(...)</code>: Homomorphically add the two ciphertexts.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="19">19</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="35" data-code-annotation="19"><code>evaluator.multiply(...)</code>: Homomorphically multiply the ciphertexts.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="20">20</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="39" data-code-annotation="20"><code>decryptor.decrypt(result_add, dec_add)</code>: Transforms ciphertext back to a plaintext polynomial.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="21">21</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="42" data-code-annotation="21"><code>encoder.decode_int32(dec_add)</code>: Converts the plaintext polynomial to a Python integer.<br>
</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="22">22</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="50" data-code-annotation="22"><code>bfv_demo()</code>: Runs our entire demonstration when the script is invoked directly.</span>
</dd>
</dl>
<p>Running this script will print the homomorphic sum and product, confirming that the decrypted results match the original integer arithmetic—even though the intermediate computation was performed on encrypted data.</p>
</section>
<section id="further-experiments" class="level3">
<h3 class="anchored" data-anchor-id="further-experiments">Further experiments</h3>
<p>Now that you’ve seen a basic BFV demo, here are three advanced topics that can enhance or vary your homomorphic encryption workflows:</p>
<ol type="1">
<li>Circuit depth: If you chain multiple multiplications, the ciphertext “noise” grows. Past a certain depth, you risk decryption failures unless you use larger parameters or bootstrapping.</li>
<li>BatchEncoder: BFV can pack vectors of integers into a single ciphertext, enabling “SIMD” style batch operations. This is crucial for large-scale tasks, like matrix multiplications or simple neural-network layers.</li>
<li>CKKS: For real or floating-point arithmetic, switch to <strong>CKKS</strong>. It’s approximate but often sufficient (and more efficient) for ML or signal-processing tasks.</li>
</ol>
<p>Below is an example snippet that illustrates chaining multiplications (circuit depth) and using BatchEncoder in BFV. You’ll also see where you’d optionally switch from BFV to CKKS.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="annotated-cell-3"><pre class="sourceCode numberSource python code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-3-1"><a href="#annotated-cell-3-1"></a><span class="im">import</span> seal</span>
<span id="annotated-cell-3-2"><a href="#annotated-cell-3-2"></a></span>
<span id="annotated-cell-3-3"><a href="#annotated-cell-3-3"></a><span class="kw">def</span> further_experiments_demo():                   </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="1" onclick="event.preventDefault();">1</a><span id="annotated-cell-3-4" class="code-annotation-target"><a href="#annotated-cell-3-4"></a>    parms <span class="op">=</span> seal.EncryptionParameters(seal.scheme_type.BFV)</span>
<span id="annotated-cell-3-5"><a href="#annotated-cell-3-5"></a>    parms.set_poly_modulus_degree(<span class="dv">4096</span>)</span>
<span id="annotated-cell-3-6"><a href="#annotated-cell-3-6"></a>    parms.set_coeff_modulus(seal.CoeffModulus.BFVDefault(<span class="dv">4096</span>))</span>
<span id="annotated-cell-3-7"><a href="#annotated-cell-3-7"></a>    parms.set_plain_modulus(<span class="dv">65537</span>)</span>
<span id="annotated-cell-3-8"><a href="#annotated-cell-3-8"></a></span>
<span id="annotated-cell-3-9"><a href="#annotated-cell-3-9"></a>    context <span class="op">=</span> seal.SEALContext(parms)</span>
<span id="annotated-cell-3-10"><a href="#annotated-cell-3-10"></a>    keygen <span class="op">=</span> seal.KeyGenerator(context)</span>
<span id="annotated-cell-3-11"><a href="#annotated-cell-3-11"></a>    public_key <span class="op">=</span> keygen.public_key()</span>
<span id="annotated-cell-3-12"><a href="#annotated-cell-3-12"></a>    secret_key <span class="op">=</span> keygen.secret_key()</span>
<span id="annotated-cell-3-13"><a href="#annotated-cell-3-13"></a>    encryptor <span class="op">=</span> seal.Encryptor(context, public_key)</span>
<span id="annotated-cell-3-14"><a href="#annotated-cell-3-14"></a>    decryptor <span class="op">=</span> seal.Decryptor(context, secret_key)</span>
<span id="annotated-cell-3-15"><a href="#annotated-cell-3-15"></a>    evaluator <span class="op">=</span> seal.Evaluator(context)</span>
<span id="annotated-cell-3-16"><a href="#annotated-cell-3-16"></a>       </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="2" onclick="event.preventDefault();">2</a><span id="annotated-cell-3-17" class="code-annotation-target"><a href="#annotated-cell-3-17"></a>    batch_encoder <span class="op">=</span> seal.BatchEncoder(context)</span>
<span id="annotated-cell-3-18"><a href="#annotated-cell-3-18"></a>    slot_count <span class="op">=</span> batch_encoder.slot_count()</span>
<span id="annotated-cell-3-19"><a href="#annotated-cell-3-19"></a>    <span class="bu">print</span>(<span class="ss">f"Slot count: </span><span class="sc">{</span>slot_count<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="annotated-cell-3-20"><a href="#annotated-cell-3-20"></a></span>
<span id="annotated-cell-3-21"><a href="#annotated-cell-3-21"></a>    <span class="co"># We'll encode a vector of integers [0, 1, 2, ..., slot_count-1].</span></span>
<span id="annotated-cell-3-22"><a href="#annotated-cell-3-22"></a>    sample_vec <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(slot_count))</span>
<span id="annotated-cell-3-23"><a href="#annotated-cell-3-23"></a>    plain_sample <span class="op">=</span> seal.Plaintext()</span>
<span id="annotated-cell-3-24"><a href="#annotated-cell-3-24"></a>    batch_encoder.encode(sample_vec, plain_sample)</span>
<span id="annotated-cell-3-25"><a href="#annotated-cell-3-25"></a></span>
<span id="annotated-cell-3-26"><a href="#annotated-cell-3-26"></a>    ciph_sample <span class="op">=</span> seal.Ciphertext()</span>
<span id="annotated-cell-3-27"><a href="#annotated-cell-3-27"></a>    encryptor.encrypt(plain_sample, ciph_sample)</span>
<span id="annotated-cell-3-28"><a href="#annotated-cell-3-28"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="3" onclick="event.preventDefault();">3</a><span id="annotated-cell-3-29" class="code-annotation-target"><a href="#annotated-cell-3-29"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="annotated-cell-3-30"><a href="#annotated-cell-3-30"></a>        evaluator.multiply_inplace(ciph_sample, ciph_sample)</span>
<span id="annotated-cell-3-31"><a href="#annotated-cell-3-31"></a>        evaluator.relinearize_inplace(ciph_sample, keygen.relin_keys())</span>
<span id="annotated-cell-3-32"><a href="#annotated-cell-3-32"></a>        <span class="co"># (Optional) check noise budget with decryptor.invariant_noise_budget()</span></span>
<span id="annotated-cell-3-33"><a href="#annotated-cell-3-33"></a>        <span class="co"># noise = decryptor.invariant_noise_budget(ciph_sample)</span></span>
<span id="annotated-cell-3-34"><a href="#annotated-cell-3-34"></a>        <span class="co"># print(f"Multiplication #{i+1}: noise budget = {noise} bits")</span></span>
<span id="annotated-cell-3-35"><a href="#annotated-cell-3-35"></a></span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="4" onclick="event.preventDefault();">4</a><span id="annotated-cell-3-36" class="code-annotation-target"><a href="#annotated-cell-3-36"></a>    plain_out <span class="op">=</span> seal.Plaintext()</span>
<span id="annotated-cell-3-37"><a href="#annotated-cell-3-37"></a>    decryptor.decrypt(ciph_sample, plain_out)</span>
<span id="annotated-cell-3-38"><a href="#annotated-cell-3-38"></a>    decoded_vec <span class="op">=</span> []</span>
<span id="annotated-cell-3-39"><a href="#annotated-cell-3-39"></a>    batch_encoder.decode(plain_out, decoded_vec)</span>
<span id="annotated-cell-3-40"><a href="#annotated-cell-3-40"></a>    <span class="bu">print</span>(<span class="st">"Decoded vector (first 10):"</span>, decoded_vec[:<span class="dv">10</span>])</span>
<span id="annotated-cell-3-41"><a href="#annotated-cell-3-41"></a>   </span>
<a class="code-annotation-anchor" data-target-cell="annotated-cell-3" data-target-annotation="5" onclick="event.preventDefault();">5</a><span id="annotated-cell-3-42" class="code-annotation-target"><a href="#annotated-cell-3-42"></a>    <span class="co">#   ckks_parms = seal.EncryptionParameters(seal.scheme_type.CKKS)</span></span>
<span id="annotated-cell-3-43"><a href="#annotated-cell-3-43"></a>    <span class="co">#   (Set poly_modulus_degree, coeff_modulus, scale, etc.)</span></span>
<span id="annotated-cell-3-44"><a href="#annotated-cell-3-44"></a>    <span class="co">#   This would allow real-number arithmetic, ideal for ML tasks.</span></span>
<span id="annotated-cell-3-45"><a href="#annotated-cell-3-45"></a></span>
<span id="annotated-cell-3-46"><a href="#annotated-cell-3-46"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="annotated-cell-3-47"><a href="#annotated-cell-3-47"></a>    further_experiments_demo()</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<dl class="code-annotation-container-grid">
<dt data-target-cell="annotated-cell-3" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="4" data-code-annotation="1">We choose BFV for integer arithmetic. This snippet sets polynomial modulus degree and coefficient moduli. You could scale them up for deeper circuits or bigger integer ranges.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="17" data-code-annotation="2">We create a <code>BatchEncoder</code> to pack vectors of integers into a single ciphertext. Greatly improves performance in large-scale tasks by exploiting SIMD-like parallelism.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="29" data-code-annotation="3">We multiply the ciphertext by itself repeatedly, relinearizing each time. Each multiplication consumes <em>noise budget</em>. If you do enough multiplications without large enough parameters or bootstrapping, you’ll eventually exceed the noise limit, causing decryption failures.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="36" data-code-annotation="4">We decrypt and decode to confirm that, despite multiple multiplications, the result is still coherent—unless the noise budget is used up.</span>
</dd>
<dt data-target-cell="annotated-cell-3" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-3" data-code-lines="42" data-code-annotation="5">Shows a placeholder for switching to CKKS, which supports floating-point arithmetic. This scheme is approximate but powerful for neural networks, signal processing, etc.</span>
</dd>
</dl>
<p>With these ideas, you can explore how parameter selection, batching, and scheme type impact your HE performance and functionality. This snippet offers a practical launch pad for deeper experimentation in BFV or CKKS.</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>HE represents a significant step forward in our ability to process data securely without ever exposing sensitive information. By allowing computations to be performed on ciphertexts—and yielding valid results upon decryption, HE enables a new paradigm where encryption need not be a barrier to data analysis. Whether it is applied to federated learning in healthcare, collaborative fraud detection across financial institutions, or privacy‐preserving smart contracts in blockchain, HE offers a unique combination of confidentiality and functionality.</p>
<p>Looking forward, several emerging trends will likely shape the future of HE:</p>
<ul>
<li><p>Performance breakthroughs: Continued research on more efficient polynomial arithmetic, improved parameter selection, and specialized hardware (such as GPUs, FPGAs, or custom ASICs) will help bring HE closer to production‐level performance.</p></li>
<li><p>Hybrid protocols: As cryptographic methods converge, we will see hybrid protocols that combine FHE with secure enclaves, MPC, or advanced zero‐knowledge systems for even richer functionality. These layered approaches leverage the best of each technique and help manage performance–security trade‐offs.</p></li>
<li><p>Industry adoption: Finance, healthcare, and governmental agencies are already piloting HE solutions for regulated data. Wider adoption will likely hinge on stable open‐source libraries, well‐tested APIs, and standardized best practices that make HE deployments easier and cheaper.</p></li>
<li><p>Post‐quantum readiness: Many leading HE schemes rely on lattice‐based cryptography, which is believed (though not guaranteed) to be resistant to quantum attacks. As the cryptographic community refines post‐quantum standards, we can expect lattice‐based FHE to align with future‐proofing measures.</p></li>
</ul>
<p>Ultimately, HE illustrates how security and functionality need not be an either–or proposition. By preserving data confidentiality during computation, HE opens up possibilities for collaborative analytics, regulatory compliance, and new cryptographic protocols that were previously unattainable under conventional encryption. While there is more to do—particularly in reducing computational overhead—HE stands poised to become an integral component of next‐generation privacy solutions across industries.</p>


</section>


<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a><div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{montano2022,
  author = {Montano, Antonio},
  title = {Homomorphic {Encryption} for {Developers}},
  date = {2022-06-23},
  url = {https://antomon.github.io/posts/homomorphic-encryption-developers/},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-montano2022" class="csl-entry quarto-appendix-citeas" role="listitem">
Montano, Antonio. 2022. <span>“Homomorphic Encryption for
Developers.”</span> June 23, 2022. <a href="https://antomon.github.io/posts/homomorphic-encryption-developers/">https://antomon.github.io/posts/homomorphic-encryption-developers/</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/antomon\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="antomon/antomon-utterances" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Antonio Montano’s Personal Website</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../about.html">
<p>About</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../../contents/services.html">
<p>Services</p>
</a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/montano/">
      <i class="bi bi-linkedin" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/antomon">
      <i class="bi bi-twitter" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/antomon">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 © Antonio Montano, 2022-2025
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>