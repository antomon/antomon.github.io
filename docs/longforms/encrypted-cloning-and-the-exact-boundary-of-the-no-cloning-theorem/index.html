<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.9.16">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Antonio Montano">
<meta name="dcterms.date" content="2026-01-16">
<meta name="description" content="The No-Cloning Theorem is a foundational constraint of quantum mechanics, prohibiting the deterministic duplication of arbitrary unknown quantum states. This limitation has profound consequences for quantum computing, shaping how information can be stored, transmitted, protected, and recovered. A recent Physical Review Letters paper, Encrypted Qubits Can Be Cloned, introduces a protocol that appears, at first glance, to challenge this constraint by allowing multiple ‚Äúclones‚Äù of a quantum state to exist simultaneously. This article provides a technical commentary on that result, clarifying why encrypted cloning does not violate the No-Cloning Theorem and instead operates precisely at its boundary. The protocol achieves redundancy by producing multiple encrypted representations of a quantum state whose reduced subsystems are information-theoretically opaque, while enforcing one-time recoverability through unitary dynamics and overlapping access structures. At no point do multiple independent plaintext copies become simultaneously accessible. By revisiting the No-Cloning Theorem from first principles and analyzing the protocol through the lens of quantum channel capacity, antidegradability, and multipartite entanglement, this commentary situates encrypted cloning within the broader landscape of quantum information primitives. It argues that encrypted cloning introduces a new systems-level capability‚Äîrecoverable redundancy without replication‚Äîthat expands the design space of quantum architectures without weakening any known no-go theorems. The implications for quantum storage, distributed computation, and security are discussed, highlighting how constraints imposed by unitarity can be respected while still enabling novel operational functionality.">

<title>Encrypted Cloning and the Exact Boundary of the No-Cloning Theorem ‚Äì Random Bits of Knowledge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-3ae586159be244f9b7da5612ca3882f5.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-a197ee5f2d4eaaf2c66dc03ab5ac86cb.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=663ff7b280d7c0001914e592&amp;product=sticky-share-buttons" async="async"></script>
<script src="https://cdn.jsdelivr.net/npm/typewriter-effect@latest/dist/core.js"></script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="Encrypted Cloning and the Exact Boundary of the No-Cloning Theorem ‚Äì Random Bits of Knowledge">
<meta property="og:description" content="The No-Cloning Theorem is a foundational constraint of quantum mechanics, prohibiting the deterministic duplication of arbitrary unknown quantum states. This limitation has profound consequences for quantum computing, shaping how information can be stored, transmitted, protected, and recovered. A recent Physical Review Letters paper, Encrypted Qubits Can Be Cloned, introduces a protocol that appears, at first glance, to challenge this constraint by allowing multiple ‚Äúclones‚Äù of a quantum state to exist simultaneously. This article provides a technical commentary on that result, clarifying why encrypted cloning does not violate the No-Cloning Theorem and instead operates precisely at its boundary. The protocol achieves redundancy by producing multiple encrypted representations of a quantum state whose reduced subsystems are information-theoretically opaque, while enforcing one-time recoverability through unitary dynamics and overlapping access structures. At no point do multiple independent plaintext copies become simultaneously accessible. By revisiting the No-Cloning Theorem from first principles and analyzing the protocol through the lens of quantum channel capacity, antidegradability, and multipartite entanglement, this commentary situates encrypted cloning within the broader landscape of quantum information primitives. It argues that encrypted cloning introduces a new systems-level capability‚Äîrecoverable redundancy without replication‚Äîthat expands the design space of quantum architectures without weakening any known no-go theorems. The implications for quantum storage, distributed computation, and security are discussed, highlighting how constraints imposed by unitarity can be respected while still enabling novel operational functionality.">
<meta property="og:image" content="https://antomon.github.io/longforms/encrypted-cloning-and-the-exact-boundary-of-the-no-cloning-theorem/encrypted-cloning-cover.jpeg">
<meta property="og:site_name" content="Random Bits of Knowledge">
<meta name="twitter:title" content="Encrypted Cloning and the Exact Boundary of the No-Cloning Theorem ‚Äì Random Bits of Knowledge">
<meta name="twitter:description" content="The No-Cloning Theorem is a foundational constraint of quantum mechanics, prohibiting the deterministic duplication of arbitrary unknown quantum states. This limitation has profound consequences for quantum computing, shaping how information can be stored, transmitted, protected, and recovered. A recent Physical Review Letters paper, Encrypted Qubits Can Be Cloned, introduces a protocol that appears, at first glance, to challenge this constraint by allowing multiple ‚Äúclones‚Äù of a quantum state to exist simultaneously. This article provides a technical commentary on that result, clarifying why encrypted cloning does not violate the No-Cloning Theorem and instead operates precisely at its boundary. The protocol achieves redundancy by producing multiple encrypted representations of a quantum state whose reduced subsystems are information-theoretically opaque, while enforcing one-time recoverability through unitary dynamics and overlapping access structures. At no point do multiple independent plaintext copies become simultaneously accessible. By revisiting the No-Cloning Theorem from first principles and analyzing the protocol through the lens of quantum channel capacity, antidegradability, and multipartite entanglement, this commentary situates encrypted cloning within the broader landscape of quantum information primitives. It argues that encrypted cloning introduces a new systems-level capability‚Äîrecoverable redundancy without replication‚Äîthat expands the design space of quantum architectures without weakening any known no-go theorems. The implications for quantum storage, distributed computation, and security are discussed, highlighting how constraints imposed by unitarity can be respected while still enabling novel operational functionality.">
<meta name="twitter:image" content="https://antomon.github.io/longforms/encrypted-cloning-and-the-exact-boundary-of-the-no-cloning-theorem/encrypted-cloning-cover.jpeg">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar docked nav-fixed slimcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../favicon.png" alt="AM logo" class="navbar-logo light-content">
    <img src="../../favicon.png" alt="AM logo" class="navbar-logo dark-content">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Random Bits of Knowledge</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../contents/services.html"> 
<span class="menu-text">Services</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../longforms.html"> 
<span class="menu-text">Longforms</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-collections" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Collections</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-collections">    
        <li>
    <a class="dropdown-item" href="../../collections/bookmarks-inspiration.html">
 <span class="dropdown-text">Bookmarks of Inspiration</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../collections/cabinet-digital-curiosities.html">
 <span class="dropdown-text">Cabinet of Digital Curiosities</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../collections/free-knowledge.html">
 <span class="dropdown-text">Free Knowledge</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://4m4.it/corso-python/">
 <span class="dropdown-text">Corso Python</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/montano/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/antomon"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/antomon"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <a class="flex-grow-1 no-decor" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
          <h1 class="quarto-secondary-nav-title">Encrypted Cloning and the Exact Boundary of the No-Cloning Theorem</h1>
        </a>     
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="3">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#the-no-cloning-theorem-revisited-what-is-actually-forbidden" id="toc-the-no-cloning-theorem-revisited-what-is-actually-forbidden" class="nav-link" data-scroll-target="#the-no-cloning-theorem-revisited-what-is-actually-forbidden">The No-Cloning Theorem revisited: what is actually forbidden</a></li>
  <li><a href="#encrypted-cloning-as-physical-encoding-not-state-duplication" id="toc-encrypted-cloning-as-physical-encoding-not-state-duplication" class="nav-link" data-scroll-target="#encrypted-cloning-as-physical-encoding-not-state-duplication">Encrypted cloning as physical encoding, not state duplication</a></li>
  <li><a href="#why-only-one-decryption-is-possible" id="toc-why-only-one-decryption-is-possible" class="nav-link" data-scroll-target="#why-only-one-decryption-is-possible">Why only one decryption is possible</a></li>
  <li><a href="#encrypted-cloning-in-relation-to-existing-quantum-primitives" id="toc-encrypted-cloning-in-relation-to-existing-quantum-primitives" class="nav-link" data-scroll-target="#encrypted-cloning-in-relation-to-existing-quantum-primitives">Encrypted cloning in relation to existing quantum primitives</a>
  <ul class="collapse">
  <li><a href="#relation-to-quantum-error-correction" id="toc-relation-to-quantum-error-correction" class="nav-link" data-scroll-target="#relation-to-quantum-error-correction">Relation to quantum error correction</a></li>
  <li><a href="#relation-to-quantum-secret-sharing" id="toc-relation-to-quantum-secret-sharing" class="nav-link" data-scroll-target="#relation-to-quantum-secret-sharing">Relation to quantum secret sharing</a></li>
  <li><a href="#consistency-with-entanglement-monogamy" id="toc-consistency-with-entanglement-monogamy" class="nav-link" data-scroll-target="#consistency-with-entanglement-monogamy">Consistency with entanglement monogamy</a></li>
  <li><a href="#consistency-with-quantum-summoning" id="toc-consistency-with-quantum-summoning" class="nav-link" data-scroll-target="#consistency-with-quantum-summoning">Consistency with quantum summoning</a></li>
  </ul></li>
  <li><a href="#encrypted-cloning-as-a-systems-primitive-for-quantum-computing" id="toc-encrypted-cloning-as-a-systems-primitive-for-quantum-computing" class="nav-link" data-scroll-target="#encrypted-cloning-as-a-systems-primitive-for-quantum-computing">Encrypted cloning as a systems primitive for quantum computing</a>
  <ul class="collapse">
  <li><a href="#redundancy-without-replication" id="toc-redundancy-without-replication" class="nav-link" data-scroll-target="#redundancy-without-replication">Redundancy without replication</a></li>
  <li><a href="#quantum-encrypted-multicloud-storage" id="toc-quantum-encrypted-multicloud-storage" class="nav-link" data-scroll-target="#quantum-encrypted-multicloud-storage">Quantum encrypted multicloud storage</a></li>
  <li><a href="#one-time-recovery-as-a-design-constraint" id="toc-one-time-recovery-as-a-design-constraint" class="nav-link" data-scroll-target="#one-time-recovery-as-a-design-constraint">One-time recovery as a design constraint</a></li>
  <li><a href="#sensitivity-and-robustness-tradeoffs" id="toc-sensitivity-and-robustness-tradeoffs" class="nav-link" data-scroll-target="#sensitivity-and-robustness-tradeoffs">Sensitivity and robustness tradeoffs</a></li>
  <li><a href="#relationship-to-classical-cryptographic-intuition" id="toc-relationship-to-classical-cryptographic-intuition" class="nav-link" data-scroll-target="#relationship-to-classical-cryptographic-intuition">Relationship to classical cryptographic intuition</a></li>
  </ul></li>
  <li><a href="#encrypted-cloning-as-a-pattern-for-working-within-unitarity-constraints" id="toc-encrypted-cloning-as-a-pattern-for-working-within-unitarity-constraints" class="nav-link" data-scroll-target="#encrypted-cloning-as-a-pattern-for-working-within-unitarity-constraints">Encrypted cloning as a pattern for working within unitarity constraints</a>
  <ul class="collapse">
  <li><a href="#beyond-storage-potential-extensions" id="toc-beyond-storage-potential-extensions" class="nav-link" data-scroll-target="#beyond-storage-potential-extensions">Beyond storage: potential extensions</a></li>
  <li><a href="#what-encrypted-cloning-does-not-do" id="toc-what-encrypted-cloning-does-not-do" class="nav-link" data-scroll-target="#what-encrypted-cloning-does-not-do">What encrypted cloning does not do</a></li>
  <li><a href="#implications-for-quantum-computing-as-a-discipline" id="toc-implications-for-quantum-computing-as-a-discipline" class="nav-link" data-scroll-target="#implications-for-quantum-computing-as-a-discipline">Implications for quantum computing as a discipline</a></li>
  </ul></li>
  <li><a href="#implications-for-cybersecurity-when-quantum-data-become-backupable-but-not-copyable" id="toc-implications-for-cybersecurity-when-quantum-data-become-backupable-but-not-copyable" class="nav-link" data-scroll-target="#implications-for-cybersecurity-when-quantum-data-become-backupable-but-not-copyable">Implications for cybersecurity: when quantum data become backupable but not copyable</a>
  <ul class="collapse">
  <li><a href="#threat-model-baseline-what-the-attacker-can-physically-access" id="toc-threat-model-baseline-what-the-attacker-can-physically-access" class="nav-link" data-scroll-target="#threat-model-baseline-what-the-attacker-can-physically-access">Threat model baseline: what the attacker can physically access</a></li>
  <li><a href="#a-new-key-management-regime-quantum-keys-as-consumable-capabilities" id="toc-a-new-key-management-regime-quantum-keys-as-consumable-capabilities" class="nav-link" data-scroll-target="#a-new-key-management-regime-quantum-keys-as-consumable-capabilities">A new key management regime: quantum keys as consumable capabilities</a></li>
  <li><a href="#confidentiality-is-information-theoretic-but-integrity-becomes-the-dominant-risk" id="toc-confidentiality-is-information-theoretic-but-integrity-becomes-the-dominant-risk" class="nav-link" data-scroll-target="#confidentiality-is-information-theoretic-but-integrity-becomes-the-dominant-risk">Confidentiality is information theoretic, but integrity becomes the dominant risk</a></li>
  <li><a href="#incident-response-semantics-change-single-restore-means-single-rollback" id="toc-incident-response-semantics-change-single-restore-means-single-rollback" class="nav-link" data-scroll-target="#incident-response-semantics-change-single-restore-means-single-rollback">Incident response semantics change: single restore means single rollback</a></li>
  <li><a href="#multi-party-control-and-key-splitting-opportunity-and-constraint" id="toc-multi-party-control-and-key-splitting-opportunity-and-constraint" class="nav-link" data-scroll-target="#multi-party-control-and-key-splitting-opportunity-and-constraint">Multi party control and key splitting: opportunity and constraint</a></li>
  <li><a href="#new-attack-classes-rollback-and-replay-at-the-unitary-level" id="toc-new-attack-classes-rollback-and-replay-at-the-unitary-level" class="nav-link" data-scroll-target="#new-attack-classes-rollback-and-replay-at-the-unitary-level">New attack classes: rollback and replay at the unitary level</a></li>
  <li><a href="#practical-security-boundary-where-the-classical-world-re-enters" id="toc-practical-security-boundary-where-the-classical-world-re-enters" class="nav-link" data-scroll-target="#practical-security-boundary-where-the-classical-world-re-enters">Practical security boundary: where the classical world re-enters</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#appendix-a-encrypted-cloning-and-the-exact-boundary-of-quantum-secret-sharing" id="toc-appendix-a-encrypted-cloning-and-the-exact-boundary-of-quantum-secret-sharing" class="nav-link" data-scroll-target="#appendix-a-encrypted-cloning-and-the-exact-boundary-of-quantum-secret-sharing">Appendix A ‚Äî Encrypted cloning and the exact boundary of quantum secret sharing</a>
  <ul class="collapse">
  <li><a href="#access-structures-in-quantum-secret-sharing" id="toc-access-structures-in-quantum-secret-sharing" class="nav-link" data-scroll-target="#access-structures-in-quantum-secret-sharing">Access structures in quantum secret sharing</a></li>
  <li><a href="#access-structure-induced-by-encrypted-cloning" id="toc-access-structure-induced-by-encrypted-cloning" class="nav-link" data-scroll-target="#access-structure-induced-by-encrypted-cloning">Access structure induced by encrypted cloning</a></li>
  <li><a href="#maximal-overlap-and-impossibility-of-simultaneous-recovery" id="toc-maximal-overlap-and-impossibility-of-simultaneous-recovery" class="nav-link" data-scroll-target="#maximal-overlap-and-impossibility-of-simultaneous-recovery">Maximal overlap and impossibility of simultaneous recovery</a></li>
  <li><a href="#complementary-unauthorized-sets-and-antidegradability" id="toc-complementary-unauthorized-sets-and-antidegradability" class="nav-link" data-scroll-target="#complementary-unauthorized-sets-and-antidegradability">Complementary unauthorized sets and antidegradability</a></li>
  <li><a href="#encrypted-cloning-as-an-extremal-qss-construction" id="toc-encrypted-cloning-as-an-extremal-qss-construction" class="nav-link" data-scroll-target="#encrypted-cloning-as-an-extremal-qss-construction">Encrypted cloning as an extremal QSS construction</a></li>
  <li><a href="#implications-of-the-access-structure-viewpoint" id="toc-implications-of-the-access-structure-viewpoint" class="nav-link" data-scroll-target="#implications-of-the-access-structure-viewpoint">Implications of the access-structure viewpoint</a></li>
  </ul></li>
  <li><a href="#appendix-b-impossibility-results-implied-by-encrypted-cloning" id="toc-appendix-b-impossibility-results-implied-by-encrypted-cloning" class="nav-link" data-scroll-target="#appendix-b-impossibility-results-implied-by-encrypted-cloning">Appendix B ‚Äî Impossibility results implied by encrypted cloning</a>
  <ul class="collapse">
  <li><a href="#impossibility-of-multiple-independent-decryptions" id="toc-impossibility-of-multiple-independent-decryptions" class="nav-link" data-scroll-target="#impossibility-of-multiple-independent-decryptions">Impossibility of multiple independent decryptions</a></li>
  <li><a href="#impossibility-of-threshold-recovery-without-overlap" id="toc-impossibility-of-threshold-recovery-without-overlap" class="nav-link" data-scroll-target="#impossibility-of-threshold-recovery-without-overlap">Impossibility of threshold recovery without overlap</a></li>
  <li><a href="#impossibility-of-key-delegation-without-key-custody" id="toc-impossibility-of-key-delegation-without-key-custody" class="nav-link" data-scroll-target="#impossibility-of-key-delegation-without-key-custody">Impossibility of key delegation without key custody</a></li>
  <li><a href="#impossibility-of-fair-multi-party-recovery" id="toc-impossibility-of-fair-multi-party-recovery" class="nav-link" data-scroll-target="#impossibility-of-fair-multi-party-recovery">Impossibility of fair multi-party recovery</a></li>
  <li><a href="#impossibility-of-non-destructive-auditing-of-recovery" id="toc-impossibility-of-non-destructive-auditing-of-recovery" class="nav-link" data-scroll-target="#impossibility-of-non-destructive-auditing-of-recovery">Impossibility of non-destructive auditing of recovery</a></li>
  <li><a href="#impossibility-of-strengthening-encrypted-cloning-into-replication" id="toc-impossibility-of-strengthening-encrypted-cloning-into-replication" class="nav-link" data-scroll-target="#impossibility-of-strengthening-encrypted-cloning-into-replication">Impossibility of strengthening encrypted cloning into replication</a></li>
  <li><a href="#encrypted-cloning-as-a-generator-of-no-go-boundaries" id="toc-encrypted-cloning-as-a-generator-of-no-go-boundaries" class="nav-link" data-scroll-target="#encrypted-cloning-as-a-generator-of-no-go-boundaries">Encrypted cloning as a generator of no-go boundaries</a></li>
  </ul></li>
  <li><a href="#appendix-c-recoverability-as-a-conserved-quantum-resource" id="toc-appendix-c-recoverability-as-a-conserved-quantum-resource" class="nav-link" data-scroll-target="#appendix-c-recoverability-as-a-conserved-quantum-resource">Appendix C ‚Äî Recoverability as a conserved quantum resource</a>
  <ul class="collapse">
  <li><a href="#recoverability-versus-information-content" id="toc-recoverability-versus-information-content" class="nav-link" data-scroll-target="#recoverability-versus-information-content">Recoverability versus information content</a></li>
  <li><a href="#a-recoverability-monotone" id="toc-a-recoverability-monotone" class="nav-link" data-scroll-target="#a-recoverability-monotone">A recoverability monotone</a></li>
  <li><a href="#decryption-as-recoverability-consumption" id="toc-decryption-as-recoverability-consumption" class="nav-link" data-scroll-target="#decryption-as-recoverability-consumption">Decryption as recoverability consumption</a></li>
  <li><a href="#why-recoverability-cannot-be-cloned" id="toc-why-recoverability-cannot-be-cloned" class="nav-link" data-scroll-target="#why-recoverability-cannot-be-cloned">Why recoverability cannot be cloned</a></li>
  <li><a href="#relation-to-quantum-capacity" id="toc-relation-to-quantum-capacity" class="nav-link" data-scroll-target="#relation-to-quantum-capacity">Relation to quantum capacity</a></li>
  <li><a href="#why-classical-intuition-fails" id="toc-why-classical-intuition-fails" class="nav-link" data-scroll-target="#why-classical-intuition-fails">Why classical intuition fails</a></li>
  <li><a href="#implications-beyond-encrypted-cloning" id="toc-implications-beyond-encrypted-cloning" class="nav-link" data-scroll-target="#implications-beyond-encrypted-cloning">Implications beyond encrypted cloning</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block">Encrypted Cloning and the Exact Boundary of the No-Cloning Theorem</h1>
<p class="subtitle lead">Redundancy without Replication in Quantum Information Processing</p>
  <div class="quarto-categories">
    <div class="quarto-category">quantum computing</div>
    <div class="quarto-category">üá¨üáß</div>
  </div>
  </div>

<div>
  <div class="description">
    The <em>No-Cloning Theorem</em> is a foundational constraint of quantum mechanics, prohibiting the deterministic duplication of arbitrary unknown quantum states. This limitation has profound consequences for quantum computing, shaping how information can be stored, transmitted, protected, and recovered. A recent Physical Review Letters paper, Encrypted Qubits Can Be Cloned, introduces a protocol that appears, at first glance, to challenge this constraint by allowing multiple ‚Äúclones‚Äù of a quantum state to exist simultaneously. This article provides a technical commentary on that result, clarifying why encrypted cloning does not violate the No-Cloning Theorem and instead operates precisely at its boundary. The protocol achieves redundancy by producing multiple encrypted representations of a quantum state whose reduced subsystems are information-theoretically opaque, while enforcing one-time recoverability through unitary dynamics and overlapping access structures. At no point do multiple independent plaintext copies become simultaneously accessible. By revisiting the No-Cloning Theorem from first principles and analyzing the protocol through the lens of quantum channel capacity, antidegradability, and multipartite entanglement, this commentary situates encrypted cloning within the broader landscape of quantum information primitives. It argues that encrypted cloning introduces a new systems-level capability‚Äîrecoverable redundancy without replication‚Äîthat expands the design space of quantum architectures without weakening any known no-go theorems. The implications for quantum storage, distributed computation, and security are discussed, highlighting how constraints imposed by unitarity can be respected while still enabling novel operational functionality.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Antonio Montano </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 16, 2026</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">January 16, 2026</p>
    </div>
  </div>
    
  </div>
  


</header>



<div class="no-row-height column-margin column-container"><div class="">
<p><img src="encrypted-cloning-cover.jpeg" class="img-fluid"></p>
</div></div><section id="introduction" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In classical information theory, replication is an elementary operation. A bit string can be copied arbitrarily many times without altering its informational content or its future usability. This property is not an implementation detail but a structural feature of classical computation, and it underpins redundancy, fault tolerance, checkpointing, and distributed storage.</p>
<p>Quantum information does not share this property. A quantum state is not a passive container of data but a physical object whose evolution is constrained by linear, unitary dynamics. From these constraints follows the No-Cloning Theorem<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>: there exists no physical operation that can take an <em>arbitrary unknown</em> quantum state and produce two identical, independent copies of that state. This is not a technological limitation but a direct consequence of the mathematical structure of quantum mechanics.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;See: Wootters, W. K., &amp; Zurek, W. H. (1982). <strong>A single quantum cannot be cloned</strong>. <em>Nature</em>, 299(5886), 802‚Äì803. <a href="https://doi.org/10.1038/299802a0">DOI</a> and Dieks, D. (1982). <strong>Communication by EPR devices</strong>. <em>Physics Letters A</em>, 92(6), 271‚Äì272. <a href="https://doi.org/10.1016/0375-9601(82)90084-6">DOI</a></p></div></div><p>The No-Cloning Theorem has deep and far-reaching consequences for quantum computing. It shapes how error correction must be designed, why quantum teleportation consumes the original state, why quantum cryptography can offer information-theoretic security, and why classical notions such as backups and retries do not directly translate into the quantum domain.</p>
<p>The purpose of this article is to provide a technical commentary on the recent Physical Review Letters paper <strong>Encrypted Qubits Can Be Cloned</strong><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, which introduces a protocol that, at first sight, appears to challenge this foundational limitation. The paper demonstrates that it is possible to generate multiple <em>encrypted</em> instances of a quantum state, each of which can later be decrypted to recover the original state, but notably, only once.</p>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;See: Yamaguchi, K., &amp; Kempf, A. (2026). <strong>Encrypted qubits can be cloned</strong>. <em>Physical Review Letters</em>, 136(1), 010801. <a href="https://doi.org/10.1103/y4y1-1ll6">DOI</a></p></div></div><p>This commentary does not treat the result as a violation or relaxation of the No-Cloning Theorem. Instead, its goal is to clarify why the protocol remains fully consistent with the theorem, to formalize the distinction between cloning <em>states</em> and cloning <em>encrypted representations</em>, and to analyze what this distinction implies for quantum computing as a discipline.</p>
<p>In particular, the article aims to:</p>
<ul>
<li>Revisit the No-Cloning Theorem from first principles, emphasizing precisely what is forbidden and what is not.</li>
<li>Explain how the encrypted-cloning protocol avoids contradiction by enforcing one-time recoverability at the physical level.</li>
<li>Analyze the conceptual and practical implications of this result for quantum architectures, including storage, fault tolerance, and distributed quantum systems.</li>
</ul>
<p>By framing the paper as an exploration of what becomes possible <em>because</em> of the no-cloning constraint rather than in spite of it, the commentary positions encrypted cloning as a new primitive that reshapes how redundancy and recovery may be approached in quantum computing, without undermining its foundational limits.</p>
</section>
<section id="the-no-cloning-theorem-revisited-what-is-actually-forbidden" class="level2">
<h2 class="anchored" data-anchor-id="the-no-cloning-theorem-revisited-what-is-actually-forbidden">The No-Cloning Theorem revisited: what is actually forbidden</h2>
<p>The No-Cloning Theorem is often summarized informally as <em>quantum states cannot be copied</em>. While this statement is directionally correct, it is imprecise in ways that matter for understanding both the theorem itself and the contribution of the encrypted-cloning protocol. To assess what the recent result does and does not change, it is necessary to restate the theorem in its exact operational meaning.</p>
<p>At its core, the No-Cloning Theorem is a statement about the impossibility of a <em>universal physical process</em> that duplicates arbitrary unknown quantum states. Formally, there exists no unitary operation, and more generally no completely positive trace-preserving map, that implements the transformation</p>
<p><span class="math display">
|\psi\rangle \otimes |0\rangle \mapsto |\psi\rangle \otimes |\psi\rangle
</span></p>
<p>for all possible input states <span class="math inline">|\psi\rangle</span>.</p>
<p>This impossibility follows directly from two bedrock properties of quantum mechanics: linearity and the preservation of inner products under physical evolution. If such a universal cloner existed, it would necessarily preserve overlaps between states. However, duplicating states would square those overlaps, producing a contradiction unless all states were mutually orthogonal. Since arbitrary quantum states are not orthogonal in general, universal cloning is ruled out.</p>
<p>Several clarifications follow immediately from this formulation. First, the theorem applies only to <em>arbitrary unknown</em> states. If a state is known classically, it can be re-prepared as many times as desired. This is not cloning in the physical sense prohibited by the theorem, but repeated state preparation using classical information. The No-Cloning Theorem therefore constrains operations on quantum information that has not already been reduced to classical description.</p>
<p>Second, the theorem forbids the creation of <em>multiple independent, simultaneously accessible</em> perfect copies. It does not forbid all forms of correlation, redundancy, or encoding. Quantum error-correcting codes, for example, distribute logical information across many physical qubits through entanglement. None of the physical subsystems individually contains the logical state, and no operation produces two standalone instances of it. Error correction works precisely because it respects the no-cloning constraint rather than circumventing it.</p>
<p>Third, the theorem does not prohibit approximate cloning, probabilistic cloning, or state-dependent cloning. Each of these relaxes at least one of the theorem‚Äôs premises. Approximate cloners sacrifice fidelity, probabilistic cloners succeed only with non-unit probability, and state-dependent cloners work only on restricted sets of inputs. These constructions are well understood and do not challenge the fundamental result.</p>
<p>What the theorem categorically forbids is a deterministic, universal process that yields two or more perfect, reusable copies of an unknown quantum state. This distinction is critical when evaluating the claim that <em>encrypted qubits can be cloned</em>. The result does not assert that multiple usable instances of a quantum state are created. Instead, it demonstrates that multiple <em>representations</em> of a state can exist such that each representation is individually information-theoretically opaque, and such that at most one representation can ever be transformed back into the original state.</p>
<p>From the perspective of the No-Cloning Theorem, this is not a loophole but a compliant construction. At no point does the protocol allow two independent systems to simultaneously carry the same unknown quantum state in usable form. The constraint that only one decryption can succeed is not an external rule or software policy. It is enforced by the structure of the quantum correlations and by the unitary dynamics of the protocol itself.</p>
<p>Recasting the No-Cloning Theorem in these precise terms reframes the contribution of the encrypted-cloning protocol. The result does not weaken the theorem. Instead, it exploits the exact boundary of what the theorem forbids to introduce a new operational primitive: redundancy without replicability, and recoverability without reuse. This reframing is essential before turning to the protocol itself. Without it, the result appears paradoxical. With it, the result can be understood as a controlled and principled extension of how quantum information may be distributed and later recovered, fully consistent with the foundational limits of quantum mechanics.</p>
</section>
<section id="encrypted-cloning-as-physical-encoding-not-state-duplication" class="level2">
<h2 class="anchored" data-anchor-id="encrypted-cloning-as-physical-encoding-not-state-duplication">Encrypted cloning as physical encoding, not state duplication</h2>
<p>The central contribution of <em>Encrypted Qubits Can Be Cloned</em> is not the duplication of quantum states, but the construction of a <strong>unitary encoding that produces multiple encrypted representations of a quantum state</strong>, each of which can later be decrypted exactly once. The authors are explicit that what is generated are not multiple simultaneously accessible copies of an unknown quantum state, but rather <em>redundant, indirectly accessible encrypted clones</em> that remain fully consistent with the No-Cloning Theorem.</p>
<p>The protocol begins with a precise physical setup. An unknown qubit <span class="math inline">A</span>, held by Alice, is the quantum data to be protected. In addition, Alice prepares <span class="math inline">n</span> pairs of qubits <span class="math inline">(S_i, N_i)</span>, where each pair is initialized in a maximally entangled Bell state. The qubits <span class="math inline">S_i</span> are designated as <strong>signal qubits</strong>, while the qubits <span class="math inline">N_i</span> are designated as <strong>noise qubits</strong>. This initial entanglement is not a side condition; it is the mechanism that provides information-theoretic masking of the quantum state.</p>
<p>The encrypted cloning step consists of a single unitary operation <span class="math inline">U^{(n)}_{\mathrm{enc}}</span> acting jointly on the plaintext qubit <span class="math inline">A</span> and all signal qubits <span class="math inline">S_1,\dots,S_n</span>. This unitary acts as the identity on all noise qubits <span class="math inline">N_i</span>. As a result, no gate ever couples the plaintext qubit to the noise qubits directly. The authors stress that the noise qubits are not directly coupled to the plaintext qubit during encoding and do not individually contain accessible information about the state of <span class="math inline">A</span>. Their role is instead to participate in the correlations that encode the quantum noise introduced by the initial entanglement and that later enable its removal during decryption.</p>
<p>After the encoding operation, the information content of qubit <span class="math inline">A</span> has been distributed across the signal qubits <span class="math inline">S_i</span> and the noise qubits through multipartite entanglement. However, each imprint is perfectly masked. The reduced state of every signal qubit is maximally mixed and therefore statistically independent of the original state of <span class="math inline">A</span>. This property is proven explicitly and reiterated in the conclusion: each encrypted clone is <em>perfectly encrypted in the sense that each individually is in a maximally mixed state</em>.</p>
<p>At this stage, the terminology <em>clone</em> must be interpreted precisely. Each signal qubit is a clone only in the sense that, together with the full set of noise qubits, it contains sufficient information to reconstruct the original state. Taken alone, it contains no usable information whatsoever. There is therefore no violation of the No-Cloning Theorem at the level of accessible quantum states.</p>
<p>Decryption is implemented by a second unitary <span class="math inline">U^{(n)}_{\mathrm{dec}}</span>, which acts on <strong>one chosen signal qubit</strong> <span class="math inline">S_k</span> and <strong>all noise qubits</strong> <span class="math inline">N_1,\dots,N_n</span>. The authors provide an explicit construction and prove that this operation recovers the original state of qubit <span class="math inline">A</span> in qubit <span class="math inline">S_k</span> with fidelity 1. This establishes that each encrypted clone is individually decryptable, provided the entire noise register is available.</p>
<p>The essential constraint appears immediately after decryption. The decryption operation consumes the recoverability of the plaintext: after decrypting one signal qubit, the joint state of the remaining signal qubits and noise qubits no longer contains recoverable information about Alice‚Äôs original state, unless the system is coherently reverted to its encoded configuration. This fact is not asserted informally but derived directly from the unitary structure of the protocol and made explicit in the paper‚Äôs discussion of consistency with the No-Cloning Theorem. As the authors state, <em>after decoding, the state of the unused signal qubits and noise qubits is independent of Alice‚Äôs information</em>.</p>
<p>This structure explains why the protocol does not permit two successful decryptions. Any attempt to decrypt a second signal qubit without reversing the first decryption would necessarily fail, because the physical correlations required for recovery no longer exist. The limitation is enforced by quantum dynamics, not by external control or measurement-based restrictions.</p>
<p>From a channel-theoretic perspective, the encoding map does not implement <span class="math inline">\rho \mapsto \rho \otimes \rho</span>. Instead, it implements a map from a single-qubit system into a larger system in which <strong>multiple overlapping recovery sets</strong> exist. Each recovery set contains one signal qubit and all noise qubits. Because these sets overlap on the full noise register, they cannot be used simultaneously to recover multiple plaintext copies. The authors explicitly connect this overlap structure to consistency with both the No-Cloning Theorem and entanglement monogamy.</p>
<p>The result is therefore best understood as a new form of <strong>quantum redundancy without replication</strong>. It enables parallel storage, distribution, and deferred choice of recovery location, while preserving the fundamental prohibition against multiple simultaneous plaintext copies. The paper emphasizes that this paradigm enables functionality that is routine in classical systems, such as redundant off-site storage, but that is otherwise forbidden in quantum mechanics.</p>
</section>
<section id="why-only-one-decryption-is-possible" class="level2">
<h2 class="anchored" data-anchor-id="why-only-one-decryption-is-possible">Why only one decryption is possible</h2>
<p>The fact that only one encrypted clone can be decrypted is not an informal property of the protocol. It is a precise consequence of the quantum channel structure induced by the encoding unitary and of well-established results in quantum information theory. In the paper, this constraint is formalized using <strong>quantum channel capacity</strong> and <strong>antidegradability</strong>, not merely by appeal to intuition.</p>
<p>After encrypted cloning, Alice‚Äôs original qubit <span class="math inline">A</span> has been mapped into a larger joint system consisting of the signal qubits <span class="math inline">S_1,\dots,S_n</span> and the noise qubits <span class="math inline">N_1,\dots,N_n</span>. To analyze recoverability, the authors define a family of quantum channels</p>
<p><span class="math display">
\mathcal{N}^{(n)}_{A \to B}(\rho_A)
\;\equiv\;
\operatorname{Tr}_{\bar{B}}
\!\left[
U^{(n)}_{\mathrm{enc}}
\left(
\rho_A \otimes \bigotimes_{i=1}^{n} \phi_{S_i N_i}
\right)
U^{(n)\dagger}_{\mathrm{enc}}
\right].
</span></p>
<p>where <span class="math inline">B</span> denotes the subsystem that Bob chooses to access, and <span class="math inline">\bar{B}</span> denotes its complement.</p>
<p>The first key result is positive: if Bob chooses <strong>one signal qubit</strong> <span class="math inline">S_i</span> together with <strong>all noise qubits</strong> <span class="math inline">N_1,\dots,N_n</span>, then the channel from <span class="math inline">A</span> to <span class="math inline">B = S_i N_1\dots N_n</span> has <strong>full quantum capacity</strong>:</p>
<p><span class="math display">
C_Q\!\left(\mathcal{N}^{(n)}_{A \to S_i N_1 \dots N_n}\right) = 1.
</span></p>
<p>This equality means that the channel is capable of transmitting one qubit of quantum information perfectly. The authors prove this by explicitly constructing the decoding unitary <span class="math inline">U^{(n)}_{\mathrm{dec}}</span> and showing that it recovers the original state of <span class="math inline">A</span> with fidelity 1 for arbitrary input states. This is not an asymptotic or approximate statement; it is exact.</p>
<p>The second key result is negative and is where no-cloning consistency enters in a rigorous way. If Bob omits <strong>even a single noise qubit</strong>, or attempts to recover the state using <strong>only a signal qubit</strong>, the channel capacity collapses to zero:</p>
<p><span class="math display">
C_Q\!\left(\mathcal{N}^{(n)}_{A \to S_i}\right) = 0.
</span></p>
<p>The authors justify this by showing that the channel <span class="math inline">\mathcal{N}^{(n)}_{A \to S_i}</span> is <strong>antidegradable</strong>, and therefore has zero quantum capacity. Due to the permutation symmetry among signal qubits, the environment of any single signal qubit contains at least as much information as the signal qubit itself. For antidegradable channels, the quantum capacity vanishes identically. This is a standard result in quantum Shannon theory, and the authors explicitly cite it to ground their conclusion.</p>
<p>This capacity-based argument explains why decryption cannot be repeated. After decrypting one signal qubit, the remaining system consists of <span class="math inline">(n-1)</span> signal qubits together with the same noise qubits. However, the paper shows that after decoding, the joint state of the unused signal qubits and the noise qubits is <strong>independent of Alice‚Äôs original information</strong>. In other words, the effective channel from <span class="math inline">A</span> to any remaining subsystem has zero quantum capacity. There is no physical operation that can recover the original state again without reversing the first decryption.</p>
<p>This point deserves emphasis. The impossibility of a second decryption is not enforced by measurement, classical control, or external assumptions about key destruction. It is enforced by the <strong>structure of the quantum correlations</strong> created by the protocol. The noise qubits function as a one-time resource because their correlations with the signal qubits are reorganized during decryption in such a way that no remaining subsystem retains recoverable quantum information about <span class="math inline">A</span>.</p>
<p>The authors make this explicit when they note that it would not violate the No-Cloning Theorem if Bob were to <em>reverse</em> the decoding unitary and then decrypt a different signal qubit. In that case, the system is returned to its pre-decryption state, and only one plaintext copy exists at any time. What is forbidden is the simultaneous existence of two independent plaintext copies, and the protocol never allows this configuration to arise.</p>
<p>From a foundational standpoint, this analysis clarifies why encrypted cloning does not weaken the No-Cloning Theorem. The theorem prohibits the existence of a channel that outputs two perfect, independent copies of an unknown state. Encrypted cloning instead creates a family of overlapping recovery channels, each of which individually has full capacity, but whose simultaneous use is impossible because of their shared dependence on the same noise registers.</p>
<p>In this sense, the protocol can be viewed as exploiting a sharp boundary condition imposed by unitarity. The system is enlarged with ancillas, quantum noise is deliberately introduced via maximal entanglement, and that noise is later removable‚Äîbut only once. The No-Cloning Theorem remains intact, but the operational landscape around it is expanded.</p>
</section>
<section id="encrypted-cloning-in-relation-to-existing-quantum-primitives" class="level2">
<h2 class="anchored" data-anchor-id="encrypted-cloning-in-relation-to-existing-quantum-primitives">Encrypted cloning in relation to existing quantum primitives</h2>
<p>A key strength of <em>Encrypted Qubits Can Be Cloned</em> is that it does not present encrypted cloning as an isolated curiosity, but explicitly situates it within the landscape of known quantum information primitives. The authors carefully demonstrate that encrypted cloning is <strong>consistent with</strong>, yet <strong>operationally distinct from</strong>, quantum error correction, quantum secret sharing, entanglement monogamy, and quantum summoning. This positioning is essential to understanding its implications for quantum computing.</p>
<section id="relation-to-quantum-error-correction" class="level3">
<h3 class="anchored" data-anchor-id="relation-to-quantum-error-correction">Relation to quantum error correction</h3>
<p>At a technical level, encrypted cloning shares tools with quantum error correction. Both rely on multipartite entanglement, ancilla systems, and unitary encoding and decoding operations. However, the operational goals are fundamentally different.</p>
<p>Quantum error correction is designed to protect quantum information against <em>noise introduced by the environment</em>. Its success criterion is the ability to correct a specified class of errors repeatedly, allowing a logical qubit to survive indefinitely under fault-tolerant operations.</p>
<p>Encrypted cloning, by contrast, is not designed to protect against computational errors. Instead, it introduces quantum noise deliberately, through maximal entanglement between signal and noise qubits. This noise is not an error to be corrected repeatedly, but an encryption mechanism that can be removed exactly once. The authors explicitly state that encrypted cloning is not meant to replace error correction, but to enable a different functionality: redundancy and recoverability where direct duplication is forbidden.</p>
<p>That said, encrypted cloning can still be interpreted as an error-correcting code in a limited sense. Because the original state can be recovered even if up to <span class="math inline">n-1</span> signal qubits are lost, the scheme corrects erasure errors on the complementary system to any authorized recovery set. This connection is not metaphorical; it follows directly from the quantum secret sharing structure discussed below.</p>
</section>
<section id="relation-to-quantum-secret-sharing" class="level3">
<h3 class="anchored" data-anchor-id="relation-to-quantum-secret-sharing">Relation to quantum secret sharing</h3>
<p>The authors explicitly show that encrypted cloning is consistent with the theory of quantum secret sharing. In secret sharing, one defines an <strong>access structure</strong>: a collection of authorized sets from which the secret can be recovered, and unauthorized sets from which it cannot.</p>
<p>In encrypted cloning, any subsystem consisting of one signal qubit together with all noise qubits is an authorized set. Any subsystem consisting of fewer resources, such as only signal qubits or only noise qubits, is unauthorized. The authors verify that the two necessary and sufficient conditions for quantum secret sharing hold: the complement of any authorized set is unauthorized, and the access structure is monotonic.</p>
<p>This perspective reinforces why encrypted cloning does not violate the No-Cloning Theorem. Although multiple authorized recovery sets exist, they are not disjoint. All authorized sets overlap on the full noise register. As a result, only one recovery can succeed unless the system is first reverted to its encoded state.</p>
<p>From a systems viewpoint, this overlap property is the formal reason encrypted cloning provides redundancy without replication. It also clarifies why encrypted cloning can tolerate loss of signal qubits but not loss of the full noise register.</p>
</section>
<section id="consistency-with-entanglement-monogamy" class="level3">
<h3 class="anchored" data-anchor-id="consistency-with-entanglement-monogamy">Consistency with entanglement monogamy</h3>
<p>A potential source of confusion addressed directly by the authors concerns entanglement monogamy. Suppose the original qubit <span class="math inline">A</span> is maximally entangled with an ancilla <span class="math inline">\tilde{A}</span>. After encrypted cloning, <span class="math inline">\tilde{A}</span> appears to be maximally entangled with multiple different recovery sets.</p>
<p>This does not violate monogamy because monogamy constraints apply only to <strong>disjoint subsystems</strong>. In encrypted cloning, every recovery set overlaps with every other recovery set on the noise qubits. There are no two disjoint subsystems that can simultaneously recover the state. The apparent proliferation of entanglement is therefore an artifact of overlapping access structures, not a violation of fundamental constraints. This observation is important for quantum computing architectures that rely heavily on entanglement accounting. It shows that encrypted cloning introduces no hidden violations of known entanglement bounds.</p>
</section>
<section id="consistency-with-quantum-summoning" class="level3">
<h3 class="anchored" data-anchor-id="consistency-with-quantum-summoning">Consistency with quantum summoning</h3>
<p>The authors also relate encrypted cloning to the no-quantum-summoning theorem, which concerns the impossibility of guaranteeing the delivery of an unknown quantum state at spacelike-separated locations.</p>
<p>Encrypted cloning remains consistent with this theorem, but it enables a <em>restricted variant</em> of summoning. By depositing encrypted clones at multiple spacetime locations and carrying the noise qubits as a decryption key, an agent can later choose where to reconstruct the state, even if the candidate locations are spacelike separated. The crucial constraint is that the key must be physically brought to the chosen location, and only one reconstruction can occur.</p>
<p>This reinforces a recurring theme of the paper: encrypted cloning does not evade quantum no-go theorems by weakening them, but by reshaping the operational question so that the forbidden configuration never arises.</p>
</section>
</section>
<section id="encrypted-cloning-as-a-systems-primitive-for-quantum-computing" class="level2">
<h2 class="anchored" data-anchor-id="encrypted-cloning-as-a-systems-primitive-for-quantum-computing">Encrypted cloning as a systems primitive for quantum computing</h2>
<p>Having established that encrypted cloning is consistent with the No-Cloning Theorem and with existing quantum information frameworks, the paper‚Äôs central implication is architectural rather than purely theoretical. Encrypted cloning introduces a <strong>new systems primitive</strong> for quantum computing: one-time recoverable redundancy.</p>
<p>This primitive sits in a conceptual gap between classical copying and quantum error correction. Classical systems rely on unrestricted replication. Quantum systems, constrained by no-cloning, rely on continuous protection through encoding and syndrome-based correction. Encrypted cloning offers a third option: the ability to create multiple encrypted stand-ins for a quantum state, from which exactly one faithful recovery can later be performed.</p>
<section id="redundancy-without-replication" class="level3">
<h3 class="anchored" data-anchor-id="redundancy-without-replication">Redundancy without replication</h3>
<p>The authors emphasize that encrypted cloning provides redundancy in a setting where replication is forbidden. After encoding, the quantum information originally localized in <span class="math inline">A</span> is distributed across the signal and noise qubits, so retaining <span class="math inline">A</span> is no longer necessary for recovery. The quantum information it carried is no longer localized but distributed across many signal qubits and a noise-based key. Each signal qubit is independently useless, yet any one of them can later serve as the recovery point.</p>
<p>This form of redundancy is fundamentally different from replication. It does not increase the number of usable copies of the state. Instead, it increases the number of <em>locations</em> from which recovery is possible. In classical terms, it resembles a system with many encrypted backups and a single-use decryption capability.</p>
<p>From a quantum computing perspective, this reframes how resilience can be achieved. Rather than ensuring that a logical qubit survives arbitrary noise indefinitely, encrypted cloning ensures that a quantum state can be <em>recovered once</em> despite losses in storage or transmission, provided that at least one encrypted clone and the full key remain available.</p>
</section>
<section id="quantum-encrypted-multicloud-storage" class="level3">
<h3 class="anchored" data-anchor-id="quantum-encrypted-multicloud-storage">Quantum encrypted multicloud storage</h3>
<p>The paper‚Äôs primary concrete application is <strong>quantum encrypted multicloud storage</strong>, and it is worth restating its logic precisely, because it captures the architectural significance of the primitive.</p>
<p>After encrypted cloning, the encrypted clones <span class="math inline">S_1,\dots,S_n</span> can be distributed across independent quantum storage providers. Each provider stores a qubit whose reduced state is maximally mixed and contains no information about the underlying quantum data. The owner retains the noise qubits locally as a key.</p>
<p>This arrangement satisfies three constraints simultaneously: the data are stored off site, they are stored redundantly, and they are encrypted with a key that never leaves the owner‚Äôs possession. Recovery requires physically bringing the key to one chosen storage location, and recovery can succeed only once. The authors stress that this functionality is not achievable by direct quantum copying and does not rely on measurement, classical communication, or probabilistic success.</p>
<p>From an architectural standpoint, this introduces a notion of <em>quantum backup with single restore semantics</em>. This is weaker than classical backups, but significantly stronger than having no viable backup mechanism at all.</p>
</section>
<section id="one-time-recovery-as-a-design-constraint" class="level3">
<h3 class="anchored" data-anchor-id="one-time-recovery-as-a-design-constraint">One-time recovery as a design constraint</h3>
<p>A defining feature of encrypted cloning is that recovery is consumptive. The noise qubits function as a one-time key not by convention but by physics. After decryption, the remaining system no longer contains recoverable information about the original state.</p>
<p>This has direct implications for how such a primitive could be integrated into quantum software and hardware stacks. Encrypted cloning is suitable for scenarios where recovery is expected to be rare, deliberate, and final. It is not suitable for iterative rollback or repeated retries. The paper is explicit on this point by contrasting encrypted cloning with error correction and by emphasizing that decryption consumes the key.</p>
<p>In system design terms, encrypted cloning aligns with <em>checkpoint and abort</em> semantics rather than <em>checkpoint and resume</em> semantics. This distinction is essential for avoiding overinterpretation of the result.</p>
</section>
<section id="sensitivity-and-robustness-tradeoffs" class="level3">
<h3 class="anchored" data-anchor-id="sensitivity-and-robustness-tradeoffs">Sensitivity and robustness tradeoffs</h3>
<p>The authors also highlight two complementary properties that emerge as the number of encrypted clones increases.</p>
<p>On the one hand, robustness improves. If <span class="math inline">n</span> encrypted clones are distributed, it suffices that even one survives intact to enable full recovery. This makes the transmission and storage of signal qubits highly tolerant to loss.</p>
<p>On the other hand, sensitivity to interactions with the noise qubits increases. For large <span class="math inline">n</span>, the ability to recover the original state becomes extremely sensitive to any disturbance of the noise register. This sensitivity is not presented as a flaw, but as a potential feature for applications such as quantum sensing, where small interactions could be amplified into detectable loss of recoverability.</p>
</section>
<section id="relationship-to-classical-cryptographic-intuition" class="level3">
<h3 class="anchored" data-anchor-id="relationship-to-classical-cryptographic-intuition">Relationship to classical cryptographic intuition</h3>
<p>The authors explicitly draw an analogy between encrypted cloning and the classical one-time pad. Each encrypted clone is perfectly masked, and the noise qubits function as a pad that enables decryption. However, the analogy is deliberately incomplete.</p>
<p>In the classical one-time pad, the key cannot be reused without compromising security. In encrypted cloning, the encryption and decryption operations are unitary, and after decryption the maximally entangled pairs can, in principle, be restored and reused. What cannot be reused is the <em>recovery of the same plaintext without reverting the system</em>. This distinction underscores that the one-time nature of the protocol is enforced by recoverability constraints, not by information leakage.</p>
</section>
</section>
<section id="encrypted-cloning-as-a-pattern-for-working-within-unitarity-constraints" class="level2">
<h2 class="anchored" data-anchor-id="encrypted-cloning-as-a-pattern-for-working-within-unitarity-constraints">Encrypted cloning as a pattern for working within unitarity constraints</h2>
<p>In its concluding discussion, <em>Encrypted Qubits Can Be Cloned</em> frames encrypted cloning not merely as a new protocol, but as an instance of a broader methodological pattern: <strong>evading constraints imposed by unitarity without violating them</strong>. This perspective is essential for understanding the paper‚Äôs significance beyond its immediate application to storage or redundancy.</p>
<p>The No-Cloning Theorem is a consequence of unitarity and linearity. Encrypted cloning does not weaken these principles. Instead, it enlarges the system by introducing ancillas and deliberately injecting quantum noise through maximal entanglement. This noise masks the information in such a way that the system becomes effectively open, even though the global evolution remains unitary. Later, the noise can be removed‚Äîbut only under carefully constrained conditions.</p>
<p>This strategy mirrors a well-known phenomenon in quantum physics: quantum linear amplifiers must introduce noise to preserve unitarity. The authors explicitly draw this analogy and suggest that encrypted cloning may inspire new amplifier architectures in which noise is introduced through entangled ancillas, enabling partial or conditional denoising at a later stage.</p>
<section id="beyond-storage-potential-extensions" class="level3">
<h3 class="anchored" data-anchor-id="beyond-storage-potential-extensions">Beyond storage: potential extensions</h3>
<p>While the paper‚Äôs main concrete application is quantum encrypted multicloud storage, the authors outline several broader directions where encrypted cloning could play a role.</p>
<p>One such direction is <strong>quantum computation on encrypted data</strong>. Because encrypted cloning operates entirely unitarily and without measurements, it is compatible with coherent processing. The authors speculate that encrypted cloning may support forms of quantum multicloud parallel homomorphic or <em>blind</em> computation, where encrypted quantum data are processed across distributed systems without revealing the underlying state. This is presented as an open research direction rather than a solved problem.</p>
<p>Another direction is <strong>quantum sensing</strong>. The authors note that for large numbers of encrypted clones, the ability to recover the original state becomes extremely sensitive to interactions affecting the noise qubits. This sensitivity could be exploited as a sensing mechanism, where small perturbations manifest as a loss of decryptability. Conversely, encrypted cloning also enhances robustness in the transmission of signal qubits, since only one needs to arrive intact to enable recovery.</p>
<p>The paper also draws conceptual parallels with the <strong>Hayden‚ÄìPreskill model</strong> of black hole information recovery. In that model, information thrown into a black hole becomes rapidly scrambled and can later be recovered from emitted radiation given sufficient prior entanglement. The authors emphasize that encrypted cloning shares a similar structure: information is imprinted into many degrees of freedom and can be recovered using a specific auxiliary resource. This analogy is not used to claim equivalence, but to situate encrypted cloning within a broader class of scrambling-and-recovery phenomena.</p>
</section>
<section id="what-encrypted-cloning-does-not-do" class="level3">
<h3 class="anchored" data-anchor-id="what-encrypted-cloning-does-not-do">What encrypted cloning does not do</h3>
<p>Equally important is what encrypted cloning does not claim to achieve. The protocol does not allow multiple simultaneous recoveries. It does not enable unrestricted copying. It does not replace quantum error correction, nor does it provide ongoing protection against noise. The authors are careful to delimit the scope of their contribution and to avoid overstating its implications.</p>
<p>Encrypted cloning is therefore best understood as a <strong>one-time recoverability primitive</strong>, not as a general-purpose duplication or resilience mechanism.</p>
</section>
<section id="implications-for-quantum-computing-as-a-discipline" class="level3">
<h3 class="anchored" data-anchor-id="implications-for-quantum-computing-as-a-discipline">Implications for quantum computing as a discipline</h3>
<p>From the standpoint of quantum computing, the significance of encrypted cloning lies in how it reshapes design space. Classical computing is built on unrestricted copying. Quantum computing is built on entanglement and error correction under strict no-go theorems. Encrypted cloning introduces an intermediate capability: recoverable redundancy without replicability.</p>
<p>This capability suggests new ways to think about storage, distribution, and lifecycle management of quantum data. It also illustrates a broader lesson: quantum no-go theorems often constrain <em>direct</em> implementations of classical ideas, but they do not necessarily forbid achieving similar operational goals through indirect, carefully structured mechanisms.</p>
<p>The paper‚Äôs contribution is therefore twofold. Technically, it provides a concrete, unitary protocol with proven properties. Conceptually, it demonstrates that unitarity-imposed limits such as no-cloning can be respected while still enabling new forms of functionality that were previously thought inaccessible.</p>
</section>
</section>
<section id="implications-for-cybersecurity-when-quantum-data-become-backupable-but-not-copyable" class="level2">
<h2 class="anchored" data-anchor-id="implications-for-cybersecurity-when-quantum-data-become-backupable-but-not-copyable">Implications for cybersecurity: when quantum data become backupable but not copyable</h2>
<p>Encrypted cloning is presented in the paper as a response to a systems problem that classical cybersecurity has already solved many times: how to store sensitive data off site, redundantly, and encrypted, without trusting the storage provider. What is novel here is that the constraint set is quantum mechanical. The plaintext is not a bitstring. It is an unknown quantum state, and direct duplication is forbidden. The protocol therefore creates a new security primitive that is not equivalent to classical encryption, even when it plays a similar architectural role.</p>
<p>The purpose of this section is to translate the protocol‚Äôs guarantees into cybersecurity properties that can be reasoned about at the level of threat models, key management, access control, and incident response.</p>
<section id="threat-model-baseline-what-the-attacker-can-physically-access" class="level3">
<h3 class="anchored" data-anchor-id="threat-model-baseline-what-the-attacker-can-physically-access">Threat model baseline: what the attacker can physically access</h3>
<p>Start from a minimal, falsifiable model. Assume an adversary can compromise one or more quantum cloud providers that store encrypted clones (S_i). The adversary may extract the entire quantum state of those systems, delay measurements, and apply arbitrary quantum operations. Assume also that the owner retains the noise qubits <span class="math inline">N_1,\dots,N_n</span> locally as the decryption key, as in the paper‚Äôs multicloud storage scenario.</p>
<p>In this model, the paper gives an information theoretic security claim: each encrypted clone <span class="math inline">S_i</span> is individually maximally mixed, hence statistically independent of the plaintext state of <span class="math inline">A</span>. A compromised cloud holding any number of <span class="math inline">S_i</span> systems but no access to the full noise register lacks recoverable information about the plaintext. This is stronger than most classical encryption claims, because it does not rest on computational hardness. It is a statement about reduced density matrices. That is the core confidentiality property.</p>
</section>
<section id="a-new-key-management-regime-quantum-keys-as-consumable-capabilities" class="level3">
<h3 class="anchored" data-anchor-id="a-new-key-management-regime-quantum-keys-as-consumable-capabilities">A new key management regime: quantum keys as consumable capabilities</h3>
<p>Classical key management assumes keys are classical strings. They can be copied, escrowed, split via threshold schemes, and rotated without physically changing the ciphertext. The encrypted cloning protocol changes that regime because the <em>key</em> is a quantum system <span class="math inline">N^n</span> that participates unitarily in decryption. Decryption is consumptive in the sense relevant to recoverability: after decrypting one clone, the remaining system state is independent of the plaintext, so the key cannot be reused to decrypt a second clone without first reversing the operation.</p>
<p>Cybersecurity implication: authorization becomes a one-time capability enforced by physics rather than by policy. In classical systems, preventing reuse is a control objective implemented via process and logging. Here, the primitive itself enforces <em>one successful open per encoding episode</em>.</p>
<p>This suggests a novel design for high assurance access to quantum secrets: instead of relying on auditability to prevent illicit duplication, the system can be engineered so that successful access consumes the ability to access again. That is a different security contract than classical decryption.</p>
</section>
<section id="confidentiality-is-information-theoretic-but-integrity-becomes-the-dominant-risk" class="level3">
<h3 class="anchored" data-anchor-id="confidentiality-is-information-theoretic-but-integrity-becomes-the-dominant-risk">Confidentiality is information theoretic, but integrity becomes the dominant risk</h3>
<p>In classical storage, encryption mostly addresses confidentiality. Integrity is handled by MACs, signatures, and redundancy. In encrypted cloning, confidentiality against a cloud adversary is strong, but integrity risks become comparatively more severe because recoverability depends on coherent quantum correlations.</p>
<p>The paper states that for large <span class="math inline">n</span>, the ability to recover <span class="math inline">A</span> can become extremely sensitive to interactions with the noise qubits. In security terms, this means a new denial of service surface: an attacker who cannot learn the plaintext may still be able to prevent recovery by inducing decoherence or perturbation in the key register or in stored clones.</p>
<p>This shifts the risk balance: confidentiality: strong by construction for single clones and generally for unauthorized sets. Availability and integrity of recoverability: fragile unless the key register is protected as a high value quantum asset. For security architecture, that implies the key register must be treated less like a password and more like a hardware protected root of trust. Loss, disturbance, or subtle interaction may be as damaging as theft.</p>
</section>
<section id="incident-response-semantics-change-single-restore-means-single-rollback" class="level3">
<h3 class="anchored" data-anchor-id="incident-response-semantics-change-single-restore-means-single-rollback">Incident response semantics change: single restore means single rollback</h3>
<p>Classical incident response often relies on repeated restore points and iterative rollback. Encrypted cloning enables something closer to <em>single restore semantics</em>. In the multicloud scenario, the owner can choose any one stored clone to decrypt and recover the plaintext. After that, the system no longer supports recovering an additional plaintext instance from the remaining clones without reverting the global state.</p>
<p>Cybersecurity implication: recovery planning must assume that a restore is a one-time action. That affects how you would design business continuity and disaster recovery for quantum workloads. You would treat restore as an irreversible event, closer to key material being burned after use, than to a routine restore operation.</p>
<p>This is novel relative to classical operational security because it merges cryptographic access control with lifecycle constraints on the data itself.</p>
</section>
<section id="multi-party-control-and-key-splitting-opportunity-and-constraint" class="level3">
<h3 class="anchored" data-anchor-id="multi-party-control-and-key-splitting-opportunity-and-constraint">Multi party control and key splitting: opportunity and constraint</h3>
<p>The paper shows encrypted cloning is consistent with quantum secret sharing via its access structure, and notes that recovery sets overlap. This immediately invites cybersecurity patterns such as split custody and dual control.</p>
<p>However, unlike classical secret sharing, naively splitting the quantum key is not simply a matter of copying shares. If you distribute parts of (N^n), you introduce transport and storage risks that are physical and coherence dependent. The Appendix also discusses variants where some noise qubits are lost and recovery remains possible with modified authorized sets, but also notes that loss of even one full pair can drop capacity to zero.</p>
<p>Cybersecurity implication: you can design access control structures, but availability becomes a central design variable. In classical schemes, adding more parties can increase robustness if threshold parameters are chosen. In quantum schemes, more distribution can increase the attack surface for decoherence and denial of recovery. Security engineering becomes a tradeoff between insider risk reduction and physical fragility.</p>
</section>
<section id="new-attack-classes-rollback-and-replay-at-the-unitary-level" class="level3">
<h3 class="anchored" data-anchor-id="new-attack-classes-rollback-and-replay-at-the-unitary-level">New attack classes: rollback and replay at the unitary level</h3>
<p>The authors explicitly state that it would not violate no-cloning if, after decrypting one signal qubit, Bob runs the decoding unitary in reverse and then decrypts another signal qubit.</p>
<p>That statement has a cybersecurity reading: if an attacker gains sufficient control of the computation environment to apply unitaries coherently, the system may support a form of <em>state rollback</em> to the pre-decryption state, which restores the ability to choose a different clone to decrypt. This is not cloning, but it is a control surface.</p>
<p>The implication is that security policies cannot be defined solely by which clone gets decrypted. They must also control who can run inverse operations, where those operations can run, and what constitutes an authorized lifecycle transition. In classical terms, this is analogous to restricting privileged operations that can revert secure enclaves to pre-attestation states. Here, the analogue is coherent reversal of the decryption transformation.</p>
</section>
<section id="practical-security-boundary-where-the-classical-world-re-enters" class="level3">
<h3 class="anchored" data-anchor-id="practical-security-boundary-where-the-classical-world-re-enters">Practical security boundary: where the classical world re-enters</h3>
<p>All of the above is quantum native. But any real system will interact with classical control planes: authentication, orchestration, scheduling, billing, and monitoring. The most likely security failures will therefore occur at the boundary where classical systems decide when and where to perform the encoding and decoding unitaries, and how the key register is handled operationally.</p>
<p>Encrypted cloning narrows one class of risks (cloud learns plaintext) and widens another (key mishandling, denial of recoverability, unauthorized unitary control). This is a standard tradeoff pattern in security: strengthening confidentiality often increases sensitivity to availability and key custody.</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>This commentary set out to analyze <em>Encrypted Qubits Can Be Cloned</em> as more than a technical construction, treating it instead as a boundary case that clarifies how far quantum information processing can be pushed without violating unitarity and the No-Cloning Theorem. After working through the protocol, its proofs, and its stated relationships to existing quantum primitives, the result can be summarized with precision.</p>
<p>First, the paper does <strong>not</strong> weaken the No-Cloning Theorem. On the contrary, it sharpens its operational meaning. What is forbidden is the simultaneous existence of multiple, independently accessible plaintext copies of an unknown quantum state. What is permitted is the creation of multiple <em>encrypted representations</em> whose usefulness is gated by a shared quantum resource and whose recovery paths necessarily overlap. The distinction between <em>copying a state</em> and <em>copying an encrypted encoding</em> is not semantic; it is enforced by channel capacity, antidegradability, and the structure of multipartite entanglement.</p>
<p>Second, encrypted cloning introduces a <strong>new quantum systems primitive</strong>: one-time recoverable redundancy. This primitive is strictly weaker than classical replication and strictly different from quantum error correction. It enables redundancy across space and infrastructure without enabling replication across time. From a computing perspective, this is a meaningful expansion of design space. It allows quantum data to be backed up, distributed, and deferred in ways that were previously assumed impossible under no-cloning constraints, while still preserving all known no-go theorems.</p>
<p>Third, when viewed through a cybersecurity lens, encrypted cloning implies a <strong>shift in the security contract</strong> for quantum data. Confidentiality against untrusted storage is information-theoretic for unauthorized subsystems, not computational. Authorization is embodied in a quantum key that behaves like a consumable capability rather than a reusable secret. Availability and integrity of recoverability become the dominant risks, because denial of recovery is easier to induce than unauthorized disclosure. This tradeoff is not accidental; it is a direct consequence of enforcing security through physics rather than policy.</p>
<p>More broadly, the paper exemplifies a recurring pattern in quantum information science: when unitarity forbids a direct analogue of a classical operation, useful functionality can sometimes be recovered by enlarging the system, introducing structured noise via entanglement, and constraining how and when that noise can be removed. The same logic underlies quantum error correction, quantum amplification limits, and several no-programming results. Encrypted cloning adds redundancy and deferred recoverability to that list.</p>
<p>Finally, the contribution of <em>Encrypted Qubits Can Be Cloned</em> should be read neither as a curiosity nor as an immediate blueprint for deployment, but as an existence proof with architectural consequences. It shows that <em>backup without copying</em> is not a contradiction in quantum mechanics, but a well-defined operational regime. Whether this regime becomes practically relevant will depend on advances in coherent control, fault tolerance, and quantum cloud infrastructure. What the paper establishes decisively is that the conceptual barrier was never the No-Cloning Theorem itself, but an overly narrow interpretation of what redundancy must mean in a quantum world.</p>
</section>
<section id="appendix-a-encrypted-cloning-and-the-exact-boundary-of-quantum-secret-sharing" class="level2">
<h2 class="anchored" data-anchor-id="appendix-a-encrypted-cloning-and-the-exact-boundary-of-quantum-secret-sharing">Appendix A ‚Äî Encrypted cloning and the exact boundary of quantum secret sharing</h2>
<p>Encrypted cloning can be understood most precisely by situating it within the formal framework of <strong>quantum secret sharing (QSS)</strong>. Doing so clarifies why the protocol enables redundancy without violating the No-Cloning Theorem and why its one-time recoverability is not an implementation artifact but a structural consequence of its access structure.</p>
<section id="access-structures-in-quantum-secret-sharing" class="level3">
<h3 class="anchored" data-anchor-id="access-structures-in-quantum-secret-sharing">Access structures in quantum secret sharing</h3>
<p>A quantum secret sharing scheme is defined by an <strong>access structure</strong> <span class="math inline">\mathcal{A}</span>, which is a family of authorized subsets of a multipartite system from which the secret can be reconstructed. Subsets not in <span class="math inline">\mathcal{A}</span> are unauthorized and must contain no recoverable information about the secret. Two necessary conditions characterize valid QSS schemes:</p>
<ol type="1">
<li><strong>Monotonicity</strong>. If a subset <span class="math inline">X</span> is authorized, then any superset <span class="math inline">Y \supseteq X</span> is also authorized.</li>
<li><strong>No-cloning consistency</strong>. The complements of authorized sets must be unauthorized. In particular, no two disjoint subsets may both be authorized, as this would permit simultaneous recovery of two independent copies of an unknown quantum state, violating the No-Cloning Theorem.</li>
</ol>
<p>Encrypted cloning realizes a highly constrained but valid access structure that satisfies both conditions exactly.</p>
</section>
<section id="access-structure-induced-by-encrypted-cloning" class="level3">
<h3 class="anchored" data-anchor-id="access-structure-induced-by-encrypted-cloning">Access structure induced by encrypted cloning</h3>
<p>After the encoding operation <span class="math inline">U^{(n)}_{\mathrm{enc}}</span>, the original qubit <span class="math inline">A</span> is mapped into a joint system consisting of signal qubits <span class="math inline">S_1,\dots,S_n</span> and noise qubits <span class="math inline">N_1,\dots,N_n</span>. The authors show that recovery is possible if and only if one signal qubit and the entire noise register are jointly available.</p>
<p>This induces the access structure:</p>
<p><span class="math display">
\mathcal{A}
;=;
\left{
{S_i} \cup {N_1,\dots,N_n}
;\middle|;
i = 1,\dots,n
\right}.
</span></p>
<p>Each authorized set consists of exactly one signal qubit together with all noise qubits. Any subset that omits at least one noise qubit, or that contains only signal qubits, is unauthorized and has zero quantum capacity. Monotonicity holds trivially: adding additional systems to an authorized set cannot destroy recoverability.</p>
</section>
<section id="maximal-overlap-and-impossibility-of-simultaneous-recovery" class="level3">
<h3 class="anchored" data-anchor-id="maximal-overlap-and-impossibility-of-simultaneous-recovery">Maximal overlap and impossibility of simultaneous recovery</h3>
<p>The defining property of this access structure is that <strong>all authorized sets overlap on the full noise register</strong>. For any two distinct indices <span class="math inline">i \neq j</span>,</p>
<p><span class="math display">
\left( {S_i} \cup N^n \right)
;\cap;
\left( {S_j} \cup N^n \right)
;=;
N^n,
</span></p>
<p>where <span class="math inline">N^n = {N_1,\dots,N_n}</span>.</p>
<p>This overlap is not incidental. It is the precise mechanism by which encrypted cloning remains consistent with the No-Cloning Theorem. Because no two authorized sets are disjoint, there exists no physical configuration in which two independent recovery operations can be executed simultaneously. Any attempt to recover from one authorized set necessarily disturbs the shared noise register in a way that destroys recoverability for all other sets.</p>
<p>In secret sharing terms, encrypted cloning realizes a <strong>maximally overlapping access structure</strong>: the number of authorized sets is as large as possible, but their intersection is also as large as possible.</p>
</section>
<section id="complementary-unauthorized-sets-and-antidegradability" class="level3">
<h3 class="anchored" data-anchor-id="complementary-unauthorized-sets-and-antidegradability">Complementary unauthorized sets and antidegradability</h3>
<p>Quantum secret sharing requires that the complement of any authorized set be unauthorized. In encrypted cloning, the complement of an authorized set <span class="math inline">{S_i} \cup N^n</span> consists of the remaining signal qubits <span class="math inline">{S_j}_{j \neq i}</span>.</p>
<p>The paper shows that any channel from <span class="math inline">A</span> to a subsystem consisting only of signal qubits is antidegradable and therefore has zero quantum capacity. This establishes that the complement of each authorized set is not merely unauthorized by definition, but provably incapable of transmitting quantum information. This property reinforces the physical nature of the access structure: unauthorized sets are not excluded by policy or convention, but by the structure of the induced quantum channels.</p>
</section>
<section id="encrypted-cloning-as-an-extremal-qss-construction" class="level3">
<h3 class="anchored" data-anchor-id="encrypted-cloning-as-an-extremal-qss-construction">Encrypted cloning as an extremal QSS construction</h3>
<p>Most quantum secret sharing schemes aim to distribute trust among multiple parties using threshold or ramp structures. Encrypted cloning occupies a different corner of the design space. It maximizes <strong>spatial redundancy</strong> while enforcing <strong>temporal exclusivity</strong> of recovery.</p>
<p>Formally, encrypted cloning realizes an extremal point in the space of QSS schemes:</p>
<ul>
<li>The number of authorized recovery locations is <span class="math inline">n</span>.</li>
<li>The intersection of all authorized sets is the full noise register.</li>
<li>The secret can be recovered exactly once unless the system is coherently reverted.</li>
</ul>
<p>This construction demonstrates that the No-Cloning Theorem does not prohibit redundancy per se. Instead, it constrains the geometry of access structures: redundancy is permitted only when authorized sets overlap sufficiently to prevent simultaneous recovery.</p>
</section>
<section id="implications-of-the-access-structure-viewpoint" class="level3">
<h3 class="anchored" data-anchor-id="implications-of-the-access-structure-viewpoint">Implications of the access-structure viewpoint</h3>
<p>Viewing encrypted cloning through the lens of quantum secret sharing resolves the apparent paradox in its name. The protocol does not clone quantum states. It constructs multiple authorized recovery paths whose overlap enforces one-time recoverability by physical law.</p>
<p>This perspective also explains why encrypted cloning cannot be strengthened into a threshold scheme with multiple independent recoveries. Any attempt to reduce overlap between authorized sets would immediately violate the no-cloning consistency condition of QSS.</p>
<p>In this sense, encrypted cloning sits exactly at the boundary of what quantum mechanics permits: it realizes maximal redundancy subject to the strictest possible overlap constraints. The No-Cloning Theorem remains intact, but its operational consequences are revealed to be subtler and more permissive than a naive reading might suggest.</p>
</section>
</section>
<section id="appendix-b-impossibility-results-implied-by-encrypted-cloning" class="level2">
<h2 class="anchored" data-anchor-id="appendix-b-impossibility-results-implied-by-encrypted-cloning">Appendix B ‚Äî Impossibility results implied by encrypted cloning</h2>
<p>Encrypted cloning is often read primarily as an enabling construction: it shows that redundancy and deferred recovery of quantum information are possible under carefully constrained conditions. Equally important, however, are the <strong>negative results</strong> that follow from the same structure. By examining which extensions of the protocol are <em>not</em> possible, encrypted cloning sharpens the boundary of what quantum mechanics permits in distributed recovery, delegation, and access control.</p>
<p>This appendix collects several impossibility results that are not stated explicitly in the paper, but that follow directly from its channel-theoretic and access-structure analysis.</p>
<section id="impossibility-of-multiple-independent-decryptions" class="level3">
<h3 class="anchored" data-anchor-id="impossibility-of-multiple-independent-decryptions">Impossibility of multiple independent decryptions</h3>
<p>The most immediate impossibility result is also the most fundamental: encrypted cloning cannot be extended to allow two successful decryptions without coherent reversal.</p>
<p>Suppose, for contradiction, that there existed a physical process that, after encoding, allowed two disjoint subsystems to independently recover the original state of qubit <span class="math inline">A</span>. Each such recovery would define a channel with nonzero quantum capacity from <span class="math inline">A</span> to the corresponding subsystem. If the subsystems were disjoint, this would constitute a channel implementing two independent recoveries of an unknown quantum state.</p>
<p>This configuration is forbidden by the No-Cloning Theorem. The paper avoids it by construction: all authorized recovery sets overlap on the full noise register. Any attempt to create two disjoint authorized sets would immediately violate no-cloning consistency.</p>
<p>Thus, encrypted cloning implies a strong impossibility result: <strong>there exists no physical extension of the protocol that yields two independent plaintext recoveries without reversing the first recovery</strong>.</p>
</section>
<section id="impossibility-of-threshold-recovery-without-overlap" class="level3">
<h3 class="anchored" data-anchor-id="impossibility-of-threshold-recovery-without-overlap">Impossibility of threshold recovery without overlap</h3>
<p>A natural question is whether encrypted cloning can be generalized into a threshold scheme, where any <span class="math inline">k</span> out of <span class="math inline">n</span> encrypted clones suffice to recover the state, possibly with different keys. The access-structure analysis in Appendix A already hints that this is impossible without overlap, but encrypted cloning makes the obstruction explicit.</p>
<p>In threshold quantum secret sharing, authorized sets can be disjoint as long as their complements are unauthorized. Encrypted cloning, however, requires that <em>all</em> authorized sets overlap on the noise register to prevent simultaneous recovery. Any threshold construction that permitted two disjoint authorized sets would allow two decryptions to occur in parallel.</p>
<p>Therefore, encrypted cloning implies the following impossibility: <strong>there is no threshold variant of encrypted cloning that allows multiple independent recoveries without violating the No-Cloning Theorem</strong>. Redundancy is possible only when recoverability is globally exclusive.</p>
</section>
<section id="impossibility-of-key-delegation-without-key-custody" class="level3">
<h3 class="anchored" data-anchor-id="impossibility-of-key-delegation-without-key-custody">Impossibility of key delegation without key custody</h3>
<p>In classical cryptography, it is common to delegate decryption capability by distributing keys or key shares. One might ask whether a similar delegation is possible in encrypted cloning: can the owner distribute parts of the noise register so that different parties can independently decrypt different clones?</p>
<p>The answer is negative. The paper shows that omitting even a single noise qubit reduces the quantum capacity of the recovery channel to zero. This implies that <strong>full custody of the noise register is required for decryption</strong>. Partial access is insufficient.</p>
<p>As a consequence, encrypted cloning enforces an impossibility result that has no classical analogue: <strong>decryption capability cannot be delegated without physically transferring the entire quantum key</strong>. There is no notion of partial authorization that preserves recoverability. This impossibility is structural, not cryptographic. It follows from antidegradability and channel capacity arguments, not from assumptions about adversaries or computational power.</p>
</section>
<section id="impossibility-of-fair-multi-party-recovery" class="level3">
<h3 class="anchored" data-anchor-id="impossibility-of-fair-multi-party-recovery">Impossibility of fair multi-party recovery</h3>
<p>Another classical desideratum is fair recovery: the ability for multiple parties to jointly recover a secret such that no party can gain access without the others. In encrypted cloning, such a notion encounters a fundamental obstruction.</p>
<p>Because recovery consumes the recoverability resource, any party that participates in a successful decryption necessarily deprives all other parties of the ability to recover the same plaintext from the remaining system. There is no unitary operation that allows two parties to emerge simultaneously with valid plaintext states, nor even with symmetric partial access.</p>
<p>Encrypted cloning therefore implies the impossibility of <strong>fair quantum recovery with exclusivity</strong>: when recovery is exclusive by physical law, it cannot be made fair without abandoning determinism or introducing measurements that destroy coherence.</p>
</section>
<section id="impossibility-of-non-destructive-auditing-of-recovery" class="level3">
<h3 class="anchored" data-anchor-id="impossibility-of-non-destructive-auditing-of-recovery">Impossibility of non-destructive auditing of recovery</h3>
<p>In classical systems, it is often possible to audit access to encrypted data without consuming the data itself. One might ask whether encrypted cloning permits a similar capability: can one verify that a recovery has occurred without destroying recoverability?</p>
<p>The structure of the protocol rules this out. Recovery corresponds to a unitary transformation that reorganizes correlations between signal and noise qubits. There exists no measurement or unitary that can both certify that recovery has occurred and preserve the correlations required for another recovery.</p>
<p>This yields another impossibility: <strong>there is no non-destructive audit of plaintext recovery in encrypted cloning</strong>. Observability and recoverability are mutually exclusive.</p>
</section>
<section id="impossibility-of-strengthening-encrypted-cloning-into-replication" class="level3">
<h3 class="anchored" data-anchor-id="impossibility-of-strengthening-encrypted-cloning-into-replication">Impossibility of strengthening encrypted cloning into replication</h3>
<p>Finally, encrypted cloning rules out its own overinterpretation. It cannot be strengthened into true replication by adding more ancillas, more entanglement, or more complex unitaries. Any such strengthening would require either:</p>
<ul>
<li>increasing the recoverability monotone beyond one, or</li>
<li>creating two disjoint authorized sets with nonzero quantum capacity.</li>
</ul>
<p>Both are forbidden by unitarity and no-cloning. Encrypted cloning therefore occupies a maximal position: it achieves the strongest possible form of redundancy compatible with quantum mechanics. Any attempt to go beyond it collapses back into impossibility results already known from foundational no-go theorems.</p>
</section>
<section id="encrypted-cloning-as-a-generator-of-no-go-boundaries" class="level3">
<h3 class="anchored" data-anchor-id="encrypted-cloning-as-a-generator-of-no-go-boundaries">Encrypted cloning as a generator of no-go boundaries</h3>
<p>Taken together, these impossibility results show that encrypted cloning is not merely consistent with the No-Cloning Theorem, but actively clarifies its operational consequences. The protocol exposes which classical intuitions fail in the quantum setting and why.</p>
<p>In this sense, encrypted cloning functions as a <strong>boundary object</strong>: it sits precisely at the edge of what is permitted and makes the surrounding impossibilities sharply visible. By studying not only what the protocol enables, but also what it forbids, one gains a clearer picture of how quantum information can be distributed, protected, and recovered‚Äîonce, and only once.</p>
</section>
</section>
<section id="appendix-c-recoverability-as-a-conserved-quantum-resource" class="level2">
<h2 class="anchored" data-anchor-id="appendix-c-recoverability-as-a-conserved-quantum-resource">Appendix C ‚Äî Recoverability as a conserved quantum resource</h2>
<p>Encrypted cloning is most naturally described in terms of channels, access structures, and unitary encodings. However, an alternative and illuminating perspective is to treat <strong>recoverability itself as a conserved resource</strong>. From this viewpoint, the protocol does not merely hide information; it redistributes a finite, non-duplicable capability across subsystems.</p>
<p>This appendix formalizes that intuition and shows how it clarifies both the power and the limits of encrypted cloning.</p>
<section id="recoverability-versus-information-content" class="level3">
<h3 class="anchored" data-anchor-id="recoverability-versus-information-content">Recoverability versus information content</h3>
<p>In classical systems, recoverability is not a meaningful physical quantity. If a plaintext exists and a key exists, recovery can in principle be repeated arbitrarily many times. Recoverability is limited only by policy, not by physics.</p>
<p>In quantum systems, by contrast, recoverability is constrained by unitarity. An unknown quantum state can be recovered only insofar as the correlations encoding it have not been irreversibly transformed or consumed. The encrypted cloning protocol makes this constraint explicit by separating <strong>information content</strong> from <strong>recoverability</strong>.</p>
<p>After encoding, the information about the state of qubit <span class="math inline">A</span> is delocalized across signal and noise qubits. At the same time, the <em>capacity to recover that information</em> exists exactly once. These two notions are not identical:</p>
<ul>
<li>Information content can be redundantly encoded in overlapping ways.</li>
<li>Recoverability cannot be duplicated.</li>
</ul>
<p>Encrypted cloning exploits this asymmetry.</p>
</section>
<section id="a-recoverability-monotone" class="level3">
<h3 class="anchored" data-anchor-id="a-recoverability-monotone">A recoverability monotone</h3>
<p>Define a recoverability monotone <span class="math inline">R</span> for a quantum system with respect to a reference system <span class="math inline">\tilde{A}</span> that purifies the input state. Informally, <span class="math inline">R</span> measures whether there exists a subsystem from which the original state can be recovered with unit fidelity.</p>
<p>For the purposes of this appendix, it suffices to note three properties of <span class="math inline">R</span> that are implicitly satisfied by the protocol:</p>
<ol type="1">
<li><p><strong>Initialization</strong>. Before encoding, <span class="math inline">R = 1</span> for the system containing <span class="math inline">A</span>, and <span class="math inline">R = 0</span> for all other subsystems.</p></li>
<li><p><strong>Encoding redistribution</strong>. After encoding, <span class="math inline">R</span> is redistributed across multiple overlapping subsystems. Each authorized recovery set has <span class="math inline">R = 1</span>, but these sets are not disjoint.</p></li>
<li><p><strong>Conservation under unitary evolution</strong>. The total recoverability cannot increase under unitary evolution. It can only be redistributed or consumed.</p></li>
</ol>
<p>This last point is critical. Although there are many recovery <em>options</em>, the total recoverability budget remains exactly one.</p>
</section>
<section id="decryption-as-recoverability-consumption" class="level3">
<h3 class="anchored" data-anchor-id="decryption-as-recoverability-consumption">Decryption as recoverability consumption</h3>
<p>From this perspective, decryption is not merely an inverse operation. It is a <strong>consumptive transformation</strong> with respect to recoverability.</p>
<p>When one signal qubit is decrypted using the full noise register, recoverability collapses onto the output qubit. All other subsystems lose their recoverability entirely. Formally, after decryption:</p>
<ul>
<li>The recovered qubit has <span class="math inline">R = 1</span>.</li>
<li>All remaining subsystems have <span class="math inline">R = 0</span>.</li>
</ul>
<p>This explains why the remaining encrypted clones become useless without invoking informal notions such as ‚Äúkey destruction‚Äù. The key is not destroyed as a physical system; rather, the recoverability resource has been irreversibly concentrated.</p>
</section>
<section id="why-recoverability-cannot-be-cloned" class="level3">
<h3 class="anchored" data-anchor-id="why-recoverability-cannot-be-cloned">Why recoverability cannot be cloned</h3>
<p>This resource-based framing makes the no-cloning consistency almost tautological. Cloning would require transforming a state with <span class="math inline">R = 1</span> into a state with <span class="math inline">R = 2</span>. That is impossible under unitary dynamics.</p>
<p>Encrypted cloning succeeds because it never increases <span class="math inline">R</span>. It merely allows <span class="math inline">R = 1</span> to be <em>addressable</em> from multiple overlapping subsystems, with the restriction that only one address can be resolved at a time. This clarifies an important conceptual point: <strong>encrypted cloning does not clone states, and it does not clone recoverability</strong>. It only clones <em>potential recovery paths</em> that share a common bottleneck.</p>
</section>
<section id="relation-to-quantum-capacity" class="level3">
<h3 class="anchored" data-anchor-id="relation-to-quantum-capacity">Relation to quantum capacity</h3>
<p>The recoverability monotone aligns closely with the channel-capacity analysis used in the paper. A subsystem has nonzero recoverability if and only if the corresponding channel has nonzero quantum capacity. Antidegradable channels correspond to subsystems with <span class="math inline">R = 0</span>.</p>
<p>Seen this way, channel capacity is not merely a communication measure, but a diagnostic of recoverability distribution. Encrypted cloning engineers a situation where many channels individually have full capacity, but cannot be used jointly without violating conservation of <span class="math inline">R</span>.</p>
</section>
<section id="why-classical-intuition-fails" class="level3">
<h3 class="anchored" data-anchor-id="why-classical-intuition-fails">Why classical intuition fails</h3>
<p>Classical backup systems implicitly assume that recoverability is free and duplicable. Encrypted cloning demonstrates that in quantum mechanics, recoverability behaves more like energy or entanglement: it is conserved, redistributable, and consumable.</p>
<p>This explains why classical intuitions about retries, restores, and audits fail when naively ported to quantum systems. The limitation is not technological but structural.</p>
</section>
<section id="implications-beyond-encrypted-cloning" class="level3">
<h3 class="anchored" data-anchor-id="implications-beyond-encrypted-cloning">Implications beyond encrypted cloning</h3>
<p>Treating recoverability as a conserved resource suggests a broader methodological lesson. Many quantum no-go theorems can be reinterpreted as conservation laws for operational capabilities rather than for information itself.</p>
<p>Encrypted cloning provides a concrete example of this principle in action. It shows that by carefully managing where recoverability resides and how it can flow, one can achieve functionality that appears paradoxical when viewed only through the lens of state duplication.</p>


</section>
</section>


<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/antomon\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="antomon/antomon-utterances" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Antonio Montano‚Äôs Personal Website</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../about.html">
<p>About</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../../contents/services.html">
<p>Services</p>
</a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/montano/">
      <i class="bi bi-linkedin" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/antomon">
      <i class="bi bi-twitter" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/antomon">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 ¬© Antonio Montano, 2022-2026
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>